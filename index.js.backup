// Importar librer√≠as
require('dotenv').config();
const express = require('express');
const { createClient } = require('@supabase/supabase-js');
const cors = require('cors');
const OpenAI = require('openai');
const fs = require('fs');
const multer = require('multer');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const bodyParser = require('body-parser');
const session = require('express-session');

// Cargar variables de entorno en variables globales para facilitar su uso en toda la aplicaci√≥n
let GUPSHUP_API_KEY = process.env.GUPSHUP_API_KEY;
let GUPSHUP_NUMBER = process.env.GUPSHUP_NUMBER;
let GUPSHUP_USERID = process.env.GUPSHUP_USERID;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_KEY = process.env.SUPABASE_KEY;
const BUSINESS_ID = process.env.BUSINESS_ID;
let CONTROL_PANEL_URL = process.env.CONTROL_PANEL_URL || 'http://localhost:3010/api/register-bot-response';
const ASSISTANT_ID = process.env.ASSISTANT_ID;
const PORT = process.env.PORT || 3090;
const VERIFY_TOKEN = process.env.VERIFY_TOKEN || 'verify_token_whatsapp_webhook';
const WHATSAPP_API_TOKEN = process.env.WHATSAPP_API_TOKEN || '';

// Inicializaci√≥n temprana para verificar variables cr√≠ticas
console.log('üîë Inicializando servidor de WhatsApp con las siguientes credenciales:');
console.log(`üì± GUPSHUP_NUMBER: ${GUPSHUP_NUMBER ? GUPSHUP_NUMBER : 'NO CONFIGURADO ‚ùå'}`);
console.log(`üîë GUPSHUP_API_KEY: ${GUPSHUP_API_KEY ? `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}` : 'NO CONFIGURADO ‚ùå'}`);
console.log(`üë§ GUPSHUP_USERID: ${GUPSHUP_USERID ? `${GUPSHUP_USERID.substring(0, 8)}...` : 'NO CONFIGURADO ‚ùå'}`);
console.log(`üîó SUPABASE_URL: ${SUPABASE_URL ? SUPABASE_URL : 'NO CONFIGURADO ‚ùå'}`);
console.log(`üñ•Ô∏è CONTROL_PANEL_URL: ${CONTROL_PANEL_URL}`);

// SOLUCI√ìN DEFINITIVA: Forzar URL en Render
// Detectar ambiente Render
const RENDER_ENV = process.env.RENDER === 'true' || process.env.RENDER_EXTERNAL_URL !== undefined;
const PROD_ENV = process.env.NODE_ENV === 'production';

// En Render, siempre usar la URL correcta (antes de cualquier otro c√≥digo)
if (RENDER_ENV || PROD_ENV) {
  const correctUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
  process.env.CONTROL_PANEL_URL = correctUrl;
  CONTROL_PANEL_URL = correctUrl;
  console.log(`üõ†Ô∏è CONFIGURACI√ìN TEMPRANA: URL forzada a ${correctUrl}`);
  
  // Guardar tambi√©n variables para Supabase para asegurar que est√©n disponibles
  if (!process.env.SUPABASE_KEY && process.env.SUPABASE_ANON_KEY) {
    process.env.SUPABASE_KEY = process.env.SUPABASE_ANON_KEY;
    console.log('üîë CONFIGURACI√ìN TEMPRANA: Copiando SUPABASE_ANON_KEY a SUPABASE_KEY');
  }
}

// Cargar el parche global que define registerBotResponse
require('./global-patch');

// Inicializar OpenAI
const openai = new OpenAI({
    apiKey: OPENAI_API_KEY,
});

// Verificar el formato de la API Key
if (OPENAI_API_KEY && !OPENAI_API_KEY.startsWith('sk-')) {
    console.warn('‚ö†Ô∏è ADVERTENCIA: El formato de la API Key de OpenAI parece incorrecto. Deber√≠a comenzar con "sk-"');
    console.warn('‚ö†Ô∏è Por favor, verifica tu API Key en https://platform.openai.com/account/api-keys');
}

const SYSTEM_PROMPT = `Eres un asistente de ventas amigable y profesional para concesionarios SEAT y CUPRA. Tu objetivo es ayudar a los clientes a encontrar el veh√≠culo que mejor se adapte a sus necesidades, responder preguntas sobre modelos espec√≠ficos, caracter√≠sticas, financiamiento y promociones.

Reglas importantes:
1. S√© respetuoso y profesional en todo momento.
2. Proporciona informaci√≥n precisa sobre veh√≠culos SEAT y CUPRA.
3. Si no conoces la respuesta, sugi√©rele al cliente que visite el concesionario o hable con un asesor humano.
4. No inventes informaci√≥n sobre precios exactos, promociones o disponibilidad.
5. Mant√©n tus respuestas concisas y directas.
6. No uses emojis.
7. Cuando sugieras un modelo, menciona brevemente sus caracter√≠sticas principales.`;

// Mapeo bidireccional para mantener relaci√≥n entre n√∫meros telef√≥nicos e IDs de conversaci√≥n
const phoneToConversationMap = {};
// Mapeo de IDs de conversaci√≥n a n√∫meros telef√≥nicos
const conversationIdToPhoneMap = {};

// Cach√© del estado del bot por remitente
const senderBotStatusMap = {};

// Cache para evitar procesar mensajes duplicados (por ID + contenido)
const processedMessages = {};

// Set para almacenar mensajes procesados recientemente (evitar duplicados)
const recentlyProcessedMessages = new Set();

// üóÇ Almacena el historial de threads de usuarios
const userThreads = {};

// Funci√≥n para actualizar/mantener los mapeos entre conversaciones y n√∫meros telef√≥nicos
// Debe llamarse cada vez que se crea o accede a una conversaci√≥n
async function updateConversationMappings() {
  console.log('üîÑ Actualizando mapeos de conversaciones y n√∫meros...');
  
  try {
    // Obtener todas las conversaciones activas para el negocio
    const { data, error } = await supabase
      .from('conversations')
      .select('id, user_id')
      .eq('business_id', BUSINESS_ID);
    
    if (error) {
      console.error('‚ùå Error al cargar mapeos:', error.message);
      return;
    }
    
    if (!data || data.length === 0) {
      console.log('‚ÑπÔ∏è No hay conversaciones para mapear');
      return;
    }
    
    console.log(`üîç Encontradas ${data.length} conversaciones para mapeo`);
    
    // Actualizar mapeos en memoria
    data.forEach(conv => {
      if (conv.id && conv.user_id) {
        // Solo actualizar si ambos valores existen
        phoneToConversationMap[conv.user_id] = conv.id;
        conversationIdToPhoneMap[conv.id] = conv.user_id;
      }
    });
    
    console.log(`‚úÖ Mapeos actualizados: ${Object.keys(phoneToConversationMap).length} n√∫meros mapeados`);
  } catch (e) {
    console.error('‚ùå Error cr√≠tico en actualizaci√≥n de mapeos:', e.message);
  }
}

// üîß Parche de URL: Corregir CONTROL_PANEL_URL si es necesario
console.log("üîß APLICANDO PARCHE PARA CORREGIR URLs DEL BOT WHATSAPP");

// Usar constantes definidas al inicio
console.log("Ambiente:", PROD_ENV ? "Producci√≥n" : "Desarrollo");
console.log("Render detectado:", RENDER_ENV ? "S√ç" : "NO");

// En Render, siempre usar la URL correcta
if (RENDER_ENV && PROD_ENV) {
  const renderUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
  console.log(`üèóÔ∏è Ambiente Render detectado, forzando URL correcta: ${renderUrl}`);
  process.env.CONTROL_PANEL_URL = renderUrl;
  CONTROL_PANEL_URL = renderUrl;
  console.log(`‚úÖ URL configurada para Render: ${CONTROL_PANEL_URL}`);
} else {
  // Procesar la URL para otros entornos
  let originalUrl = process.env.CONTROL_PANEL_URL || (PROD_ENV ? 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response' : 'http://localhost:3000');
console.log("CONTROL_PANEL_URL actual:", originalUrl);

  // Si estamos en producci√≥n y la URL contiene localhost, corregirla
  if (PROD_ENV && originalUrl.includes('localhost')) {
    console.log("‚ö†Ô∏è Detectada URL de localhost en ambiente de producci√≥n. Corrigiendo...");
    originalUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
    console.log("‚úÖ URL corregida para producci√≥n:", originalUrl);
  }

// Corregir URL duplicada
if (originalUrl.includes('/register-bot-response/register-bot-response')) {
    originalUrl = originalUrl.replace('/register-bot-response/register-bot-response', '/register-bot-response');
}

// Verificar dominios antiguos y corregirlos
  if (PROD_ENV && originalUrl.includes('panel-control-whatsapp.onrender.com')) {
    originalUrl = originalUrl.replace('panel-control-whatsapp.onrender.com', 'whatsapp-bot-if6z.onrender.com');
}

// Si la URL contiene el dominio antiguo, actualizarlo
if (originalUrl.includes('render-wa.onrender.com')) {
    originalUrl = originalUrl.replace('render-wa.onrender.com', 'whatsapp-bot-if6z.onrender.com');
    console.log("URL actualizada a dominio correcto:", originalUrl);
}

// Corregir estructura
if (originalUrl.endsWith('/register-bot-response')) {
    // URL ya tiene el endpoint, no necesita cambios
    process.env.CONTROL_PANEL_URL = originalUrl.trim();
    CONTROL_PANEL_URL = originalUrl.trim();
} else if (originalUrl.includes('/register-bot-response/')) {
    // URL tiene endpoint duplicado
    process.env.CONTROL_PANEL_URL = originalUrl.split('/register-bot-response/')[0] + '/register-bot-response';
    CONTROL_PANEL_URL = process.env.CONTROL_PANEL_URL;
} else {
    // URL no tiene endpoint, agregar si no termina en /
    const formattedUrl = originalUrl.endsWith('/') 
        ? originalUrl.slice(0, -1) + '/register-bot-response'
        : originalUrl + '/register-bot-response';
    process.env.CONTROL_PANEL_URL = formattedUrl;
    CONTROL_PANEL_URL = formattedUrl;
  }
}

console.log("URL final que se usar√°:", CONTROL_PANEL_URL);
console.log("‚úÖ Parche aplicado correctamente");
console.log("üìù De ahora en adelante, las URLs duplicadas ser√°n corregidas autom√°ticamente");
console.log("üåê En ambiente de producci√≥n, se usar√°:", PROD_ENV ? CONTROL_PANEL_URL : "URL de desarrollo");
console.log("üîç Tambi√©n puedes usar la funci√≥n global registerBotResponse() para enviar mensajes");

const LOG_LEVEL = process.env.LOG_LEVEL || 'info';

// Configuraci√≥n express
const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Configurar CORS
const corsOptions = {
  origin: ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002', 'https://whatsapp-mern-front.vercel.app'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  preflightContinue: false,
  optionsSuccessStatus: 204,
  exposedHeaders: ['Access-Control-Allow-Origin', 'Access-Control-Allow-Credentials']
};
app.use(cors(corsOptions));

// Variable global para activar modo debug
const DEBUG_MODE = process.env.DEBUG_MODE === 'true' || process.env.NODE_ENV === 'development';

// Middleware para registro de solicitudes CORS
app.use((req, res, next) => {
  if (DEBUG_MODE) {
    console.log(`üîÑ ${req.method} ${req.url} - Origin: ${req.headers.origin || 'Unknown'}`);
  }
  // Establecer headers CORS adicionales para todas las respuestas
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
});

// Middleware para opciones preflight
app.options('*', cors(corsOptions));

// Middleware para logs detallados
app.use((req, res, next) => {
  console.log(`üì• ${req.method} ${req.url}`);
  next();
});

// üîÉ Control de mensajes procesados para evitar duplicados
const MESSAGE_EXPIRE_TIME = 60000; // 60 segundos para expirar mensajes procesados

// Funci√≥n para verificar si un mensaje ya fue procesado
function isMessageProcessed(messageId, sender, text) {
  // Si tenemos un ID espec√≠fico del mensaje
  if (messageId) {
    return processedMessages.has(messageId);
  }
  
  // Si no tenemos ID, usamos una combinaci√≥n de remitente + texto + timestamp aproximado
  const messageKey = `${sender}:${text}`;
  const now = Date.now();
  
  // Verificar si ya existe una entrada reciente con esta combinaci√≥n
  for (const [key, timestamp] of processedMessages.entries()) {
    if (key.startsWith(messageKey) && (now - timestamp) < MESSAGE_EXPIRE_TIME) {
      return true;
    }
  }
  
  return false;
}

// Funci√≥n para marcar un mensaje como procesado
function markMessageAsProcessed(messageId, sender, text) {
  const key = messageId || `${sender}:${text}:${Date.now()}`;
  processedMessages.set(key, Date.now());
  
  // Limpieza de mensajes expirados (cada 100 mensajes)
  if (processedMessages.size > 100) {
    const now = Date.now();
    for (const [key, timestamp] of processedMessages.entries()) {
      if (now - timestamp > MESSAGE_EXPIRE_TIME) {
        processedMessages.delete(key);
      }
    }
  }
}

// üöÄ Verificar API Keys
console.log("üîë API Keys cargadas:");
console.log("OPENAI_API_KEY:", OPENAI_API_KEY ? "‚úÖ OK" : "‚ùå FALTA");
console.log("GUPSHUP_API_KEY:", GUPSHUP_API_KEY ? "‚úÖ OK" : "‚ùå FALTA");
console.log("GUPSHUP_NUMBER:", GUPSHUP_NUMBER ? "‚úÖ OK" : "‚ùå FALTA");
console.log("GUPSHUP_USERID:", GUPSHUP_USERID ? "‚úÖ OK" : "‚ùå FALTA");
console.log("CONTROL_PANEL_URL:", CONTROL_PANEL_URL);

// Verificar si CONTROL_PANEL_URL es v√°lido
if (CONTROL_PANEL_URL.includes('api.openai.com')) {
    console.error("üö® ERROR GRAVE: CONTROL_PANEL_URL est√° configurado incorrectamente a api.openai.com");
    console.error("üõë Esta configuraci√≥n causar√° problemas con la API. Por favor corrige el valor.");
} else if (CONTROL_PANEL_URL.includes('localhost') && PROD_ENV) {
    console.warn("‚ö†Ô∏è Advertencia: CONTROL_PANEL_URL est√° configurado a localhost en entorno de producci√≥n");
    // Actualizar una √∫ltima vez para asegurar que est√° correcto
    if (PROD_ENV) {
        const correctProdUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
        console.log(`‚öôÔ∏è Actualizando autom√°ticamente CONTROL_PANEL_URL a: ${correctProdUrl}`);
        process.env.CONTROL_PANEL_URL = correctProdUrl;
        CONTROL_PANEL_URL = correctProdUrl;
    }
    console.warn("‚ö†Ô∏è Esto podr√≠a causar problemas al registrar respuestas");
}

// ‚ùå Si faltan claves, detener el servidor
if (!OPENAI_API_KEY || !GUPSHUP_API_KEY || !GUPSHUP_NUMBER) {
    console.error("‚ö†Ô∏è ERROR: Faltan claves de API. Verifica las variables de entorno.");
    process.exit(1);
}

// Configuraci√≥n de Supabase
const supabaseUrl = process.env.SUPABASE_URL || 'https://wscijkxwevgxbgwhbqtm.supabase.co';
// Intentar obtener la clave de Supabase de diferentes variables de entorno posibles
// Verificamos todas las posibles variables donde podr√≠a estar la clave de Supabase
const supabaseKey = process.env.SUPABASE_ANON_KEY || 
                   process.env.SUPABASE_KEY || 
                   process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 
                   'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndzY2lqa3h3ZXZneGJnd2hicXRtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4MjI3NjgsImV4cCI6MjA1NzM5ODc2OH0._HSnvof7NUk6J__qqq3gJvbJRZnItCAmlI5HYAL8WVI';

console.log('üîë DEBUG - Variables de entorno para Supabase:');
console.log('- SUPABASE_URL:', process.env.SUPABASE_URL || 'no definido');
console.log('- SUPABASE_ANON_KEY:', process.env.SUPABASE_ANON_KEY ? process.env.SUPABASE_ANON_KEY.substring(0, 10) + '...' : 'no definido');
console.log('- SUPABASE_KEY:', process.env.SUPABASE_KEY ? process.env.SUPABASE_KEY.substring(0, 10) + '...' : 'no definido');
console.log('- NEXT_PUBLIC_SUPABASE_ANON_KEY:', process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY.substring(0, 10) + '...' : 'no definido');

if (!supabaseUrl) {
    console.error('‚ùå ERROR: Falta la URL de Supabase');
    process.exit(1);
}

if (!supabaseKey) {
    console.error('‚ùå ERROR: Faltan credenciales de Supabase (ninguna variable de clave est√° definida)');
    process.exit(1);
}

console.log('‚úÖ Credenciales de Supabase encontradas correctamente');
console.log(`üîë Usando clave de Supabase (primeros 10 caracteres): ${supabaseKey.substring(0, 10)}...`);

const supabase = createClient(supabaseUrl, supabaseKey);

// Funci√≥n auxiliar para verificar la estructura de la tabla messages
async function getMessagesTableStructure() {
    try {
        // Intentamos usar el procedimiento RPC, pero puede no existir
        const { data: tableInfo, error: tableError } = await supabase
            .rpc('get_table_metadata', { table_name: 'messages' });
        
        if (tableError) {
            console.warn('‚ö†Ô∏è No se pudo obtener metadata de la tabla mediante RPC:', tableError.message);
            
            // Alternativa: obtener una fila para ver estructura
            const { data: sampleRow, error: sampleError } = await supabase
                .from('messages')
                .select('*')
                .limit(1);
            
            if (sampleError) {
                console.warn('‚ö†Ô∏è No se pudo obtener muestra de la tabla:', sampleError.message);
                return null;
            }
            
            // Si tenemos una fila, podemos ver sus propiedades
            if (sampleRow && sampleRow.length > 0) {
                return Object.keys(sampleRow[0]);
            }
            
            // Si no hay datos, asumimos estructura b√°sica
            return ['conversation_id', 'content', 'sender_type', 'created_at'];
        }
        
        // Si obtuvimos datos del RPC, extraer nombres de columnas
        if (tableInfo && Array.isArray(tableInfo)) {
            return tableInfo.map(col => col.column_name);
        }
        
        return null;
    } catch (error) {
        console.error('‚ùå Error verificando estructura de tabla:', error);
        return null;
    }
}

// Formato de fecha seguro para cualquier tipo de entrada
function safeISODate(timestamp) {
  if (!timestamp) {
    return new Date().toISOString();
  }
  
  try {
    // Si es n√∫mero directo (segundos desde epoch)
    if (typeof timestamp === 'number') {
      return new Date(timestamp * 1000).toISOString();
    }
    
    // Si es string que parece n√∫mero
    if (typeof timestamp === 'string' && /^\d+$/.test(timestamp)) {
      return new Date(parseInt(timestamp) * 1000).toISOString();
    }
    
    // Si ya es un objeto Date
    if (timestamp instanceof Date) {
      return timestamp.toISOString();
    }
    
    // Si es un string de fecha ISO
    if (typeof timestamp === 'string' && /^\d{4}-\d{2}-\d{2}/.test(timestamp)) {
      return new Date(timestamp).toISOString();
    }
    
    // Caso por defecto
    return new Date().toISOString();
    } catch (error) {
    console.warn(`‚ö†Ô∏è Error al formatear fecha ${timestamp}:`, error);
    return new Date().toISOString();
  }
}

// Funci√≥n para guardar mensaje en Supabase
async function saveMessageToSupabase({ sender, message, messageId, timestamp, conversationId, isBotActive }) {
    try {
        if (!sender || !message) {
            console.warn('‚ùå Datos incompletos para guardar mensaje en Supabase');
            return null;
        }

        console.log(`üíæ Guardando mensaje de tipo 'user' para: ${sender}`);
        
        // Si no tenemos conversation_id, intentar encontrarlo
        let existingConversationId = conversationId;
        
        if (!existingConversationId) {
            // Verificar si ya existe una conversaci√≥n para este remitente
            console.log(`üîç Buscando conversaci√≥n para: ${sender}`);
            
            const { data: existingConv, error: convError } = await supabase
                .from('conversations')
                .select('id, is_bot_active')
                .eq('user_id', sender)
                .eq('business_id', BUSINESS_ID);
            
            if (convError) {
                console.error('‚ùå Error buscando conversaci√≥n:', convError);
            } else if (existingConv && existingConv.length > 0) {
                existingConversationId = existingConv[0].id;
                // Actualizar el estado del bot si lo recibimos
                if (typeof isBotActive !== 'undefined') {
                    // Forzar la actualizaci√≥n del estado en cach√©
                    senderBotStatusMap[sender] = isBotActive === true;
                } else {
                    // Usar el estado de la DB
                    isBotActive = existingConv[0].is_bot_active === true;
                    senderBotStatusMap[sender] = isBotActive;
                }
                
                console.log(`‚ÑπÔ∏è Usando conversaci√≥n existente con ID: ${existingConversationId} (bot activo: ${isBotActive ? 'S√ç' : 'NO'})`);
            } else {
                // Crear nueva conversaci√≥n
                console.log(`üìù Creando nueva conversaci√≥n para ${sender}`);
                const { data: newConv, error: createError } = await supabase
                    .from('conversations')
                    .insert([
                        { 
                            user_id: sender,
                            business_id: BUSINESS_ID,
                            is_bot_active: false, // Por defecto inactivo
                            sender_name: sender
                        }
                    ])
                    .select();
                
                if (createError) {
                    console.error('‚ùå Error creando conversaci√≥n:', createError);
                    return null;
                }
                
                if (newConv && newConv.length > 0) {
                    existingConversationId = newConv[0].id;
                    isBotActive = false; // Nueva conversaci√≥n, bot inactivo por defecto
                    
                    // Actualizar mapeos
                    phoneToConversationMap[sender] = existingConversationId;
                    conversationIdToPhoneMap[existingConversationId] = sender;
                    
                    // Actualizar estado en cach√©
                    senderBotStatusMap[sender] = false;
                    
                    console.log(`‚úÖ Nueva conversaci√≥n creada: ${existingConversationId} para ${sender} (bot inactivo por defecto)`);
                }
            }
        }
        
        if (!existingConversationId) {
            console.error('‚ùå No se pudo crear o encontrar conversaci√≥n');
            return null;
        }

        // Guardar el mensaje en la tabla messages
        const tableColumns = await getMessagesTableStructure();
        
        // Usar la funci√≥n segura para formatear la fecha
        const safeTimestamp = safeISODate(timestamp);
        console.log(`üìÖ Timestamp formateado: ${safeTimestamp}`);
        
        let messageData = {
            conversation_id: existingConversationId,
            content: message,
            sender_type: 'user',
            created_at: safeTimestamp
        };
        
        // Solo a√±adir business_id si existe en la tabla
        if (tableColumns && tableColumns.includes('business_id')) {
            messageData.business_id = BUSINESS_ID;
        }
        
        const { error: saveError } = await supabase
            .from('messages')
            .insert([messageData]);
        
        if (saveError) {
            console.error('‚ùå Error guardando mensaje:', saveError);
            
            // Si el error es sobre business_id, intentar sin √©l
            if (saveError.message && saveError.message.includes('business_id')) {
                console.log('‚ÑπÔ∏è Intentando guardar mensaje sin business_id...');
                
                delete messageData.business_id;
                
                const { error: retryError } = await supabase
                    .from('messages')
                    .insert([messageData]);
                
                if (retryError) {
                    console.error('‚ùå Error en segundo intento para guardar mensaje:', retryError);
                    return null;
                }
            } else {
                return null;
            }
        }
        
        // Actualizar la conversaci√≥n con el √∫ltimo mensaje
        await updateConversationLastActivity(existingConversationId, message);
        
        console.log('‚úÖ Mensaje guardado en Supabase correctamente');
        return existingConversationId;
        
    } catch (error) {
        console.error('‚ùå Error general guardando mensaje en Supabase:', error);
        return null;
    }
}

// Funci√≥n para actualizar √∫ltima actividad de conversaci√≥n
async function updateConversationLastActivity(conversationId, lastMessage) {
    try {
        console.log('üîÑ Actualizando √∫ltima actividad de conversaci√≥n:', conversationId);
        
        const { data, error } = await supabase
            .from('conversations')
            .update({
                last_message: lastMessage,
                last_message_time: new Date().toISOString()
            })
            .eq('id', conversationId)
            .select();
            
        if (error) {
            console.error('‚ùå Error al actualizar conversaci√≥n:', error);
            throw error;
        }
        
        console.log('‚úÖ Conversaci√≥n actualizada:', data);
        return data;
    } catch (error) {
        console.error('‚ùå Error en updateConversationLastActivity:', error);
        throw error;
    }
}

/**
 * Registra una respuesta del bot (o agente) en Supabase y actualiza la actividad de la conversaci√≥n
 * @param {string} conversationId - ID de la conversaci√≥n (puede ser un n√∫mero telef√≥nico o un UUID)
 * @param {string} message - Contenido del mensaje
 * @param {string} business_id - ID del negocio
 * @param {string} sender_type - Tipo de remitente ('bot', 'user', 'agent')
 * @returns {Promise<object>} - Resultado de la operaci√≥n
 */
async function registerBotResponse(conversationId, message, business_id = BUSINESS_ID, sender_type = 'bot') {
    try {
        if (!conversationId || !message) {
      console.error('‚ùå Faltan par√°metros para registrar respuesta');
      return { success: false, error: 'Faltan par√°metros' };
    }
    
    // Logs detallados para depurar
    console.log('üîÑ Llamada a global.registerBotResponse interceptada');
    console.log(`üì§ Guardando mensaje de tipo '${sender_type}' para: ${conversationId}`);
    console.log(`üöÄ Procesando mensaje para: ${conversationId}`);
    console.log(`üìù Mensaje: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
    
    // 1. Buscar la conversaci√≥n en la base de datos
    console.log(`üîç Buscando conversaci√≥n para: ${conversationId}`);
    let conversationRecord;
    
    // Este ID es a menudo un n√∫mero telef√≥nico, verificar formato
    const isPhoneNumber = /^\+?\d+$/.test(conversationId.toString().trim());
    
    try {
      // Primero buscar por ID exacto (UUID)
      const { data: convById } = await supabase
        .from('conversations')
        .select('*')
        .eq('id', conversationId)
        .single();
      
      if (convById) {
        console.log(`‚úÖ Conversaci√≥n encontrada directamente por ID`);
        conversationRecord = convById;
      } 
      // Si no se encuentra por ID exacto y parece ser un n√∫mero telef√≥nico
      else if (isPhoneNumber) {
        // Normalizar para b√∫squeda (sin el + inicial)
        const normalizedPhone = conversationId.toString().replace(/^\+/, '');
        
        // Buscar por usuario (n√∫mero de tel√©fono)
        const { data: convByPhone } = await supabase
          .from('conversations')
          .select('*')
          .eq('user_id', normalizedPhone)
          .eq('business_id', business_id)
          .single();
        
        if (convByPhone) {
          console.log(`‚úÖ Conversaci√≥n encontrada por tel√©fono: ${normalizedPhone}`);
          conversationRecord = convByPhone;
        }
      }
    } catch (err) {
      console.log(`‚ö†Ô∏è Error o no encontrada en b√∫squeda exacta: ${err.message}`);
    }
    
    // Si no se encuentra la conversaci√≥n, crear un nuevo registro
    if (!conversationRecord) {
      // Determinar si el ID parece un UUID
      const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(conversationId);
      
      if (isUUID) {
        console.log(`‚ö†Ô∏è No se encontr√≥ la conversaci√≥n con ID: ${conversationId}`);
        return { success: false, error: 'Conversaci√≥n no encontrada' };
      }
      
      // Si parece un n√∫mero telef√≥nico, crear la conversaci√≥n
      if (isPhoneNumber) {
        const normalizedPhone = conversationId.toString().replace(/^\+/, '');
        console.log(`üÜï Creando nueva conversaci√≥n para ${normalizedPhone}`);
        
        try {
          const { data: newConversation, error } = await supabase
            .from('conversations')
            .insert({
              user_id: normalizedPhone,
              business_id: business_id,
              last_message: message.substring(0, 100),
              is_bot_active: true // Por defecto activado
            })
            .select()
            .single();
          
          if (error) {
            console.error(`‚ùå Error al crear conversaci√≥n: ${error.message}`);
        return { success: false, error: error.message };
          }
          
          console.log(`‚úÖ Nueva conversaci√≥n creada con ID: ${newConversation.id}`);
          conversationRecord = newConversation;
        } catch (err) {
          console.error(`‚ùå Error al crear la conversaci√≥n: ${err.message}`);
          return { success: false, error: err.message };
        }
      }
    }
    
    // Si a√∫n no tenemos conversaci√≥n, salir con error
    if (!conversationRecord) {
      console.error('‚ùå No se pudo encontrar ni crear la conversaci√≥n');
      return { success: false, error: 'No se pudo encontrar ni crear la conversaci√≥n' };
    }
    
    console.log(`‚ÑπÔ∏è Usando conversaci√≥n existente con ID: ${conversationRecord.id}`);
    
    // Verificar si el bot est√° activo, para mensajes de tipo 'bot'
    if (sender_type === 'bot' && conversationRecord.is_bot_active === false) {
      console.log(`ü§ñ Bot desactivado para conversaci√≥n ${conversationRecord.id}, no se enviar√° respuesta autom√°tica`);
      return { 
        success: true, 
        id: null, 
        message: 'Bot desactivado, no se proces√≥ respuesta autom√°tica',
        conversationId: conversationRecord.id
      };
    }
    
    // 2. Guardar el mensaje en Supabase
    console.log(`üîÑ Guardando mensaje en Supabase...`);
    console.log(`üì§ Tipo de mensaje: ${sender_type}`);
    
    let messageRecord;
    try {
      // Intentar usando el cliente Supabase primero
      const { data, error } = await supabase
        .from('messages')
        .insert({
          conversation_id: conversationRecord.id,
          content: message,
          sender_type: sender_type
        })
        .select()
        .single();
        
      if (error) {
        console.warn(`‚ö†Ô∏è Error guardando mensaje con cliente, usando API REST: ${error.message}`);
        throw error; // Para caer en el catch y usar la alternativa
      }
      
      messageRecord = data;
      console.log(`‚úÖ Mensaje guardado en Supabase con ID: ${messageRecord.id}`);
    } catch (supabaseError) {
      // Alternativa: usar el servicio REST del panel para guardar el mensaje
      console.error(`‚ùå Error al guardar mensaje en Supabase: ${supabaseError.message}`);
      console.error(`  Status: ${supabaseError.status || 'N/A'}`);
      console.error(`  Data: ${JSON.stringify(supabaseError.data || {})}`);
      
      console.error(`‚ùå Error guardando en Supabase, intentando con el servidor: ${supabaseError.message}`);
      
      try {
        // Intentar usando la API del panel
        const serverResponse = await axios.post(
          CONTROL_PANEL_URL,
          {
            conversationId: conversationRecord.id,
            content: message,
            senderType: sender_type,
            businessId: business_id
          },
          {
            headers: { 'Content-Type': 'application/json' }
          }
        );
        
        console.log(`‚úÖ Mensaje enviado correctamente al servidor: ${serverResponse.status}`);
        messageRecord = serverResponse.data;
      } catch (serverError) {
        console.error(`‚ùå Error al guardar el mensaje en el servidor: ${serverError.message}`);
        return { success: false, error: serverError.message };
      }
    }
    
    // 3. Actualizar la √∫ltima actividad de la conversaci√≥n
    try {
      await updateConversationLastActivity(conversationRecord.id, message);
      console.log(`‚úÖ √öltima actividad de conversaci√≥n actualizada`);
    } catch (updateError) {
      console.warn(`‚ö†Ô∏è Error al actualizar actividad de conversaci√≥n: ${updateError.message}`);
      // No fallar por esto, ya tenemos el mensaje guardado
    }
    
    // 4. Devolver resultado exitoso
    return { 
      success: true, 
      id: messageRecord?.id, 
      message: 'Mensaje guardado correctamente',
      conversationId: conversationRecord.id
    };
  } catch (error) {
    console.error(`‚ùå Error general en registerBotResponse: ${error.message}`);
    return { success: false, error: error.message };
  }
}

// Procesar mensaje con OpenAI y generar respuesta
async function processMessageWithOpenAI(sender, message, conversationId) {
    try {
        if (!sender || !message) {
            logDebug('‚ùå Datos incompletos para procesar mensaje con OpenAI');
            return null;
        }

        logDebug(`üîç VERIFICACI√ìN CR√çTICA: Comprobando si el bot debe estar ACTIVO para ${sender}`);
        
        // ‚ö†Ô∏è VERIFICACI√ìN INICIAL - Comprobar que NO est√© desactivado en cach√©
        if (sender in senderBotStatusMap && senderBotStatusMap[sender] === false) {
            logDebug(`üö´ PROTECCI√ìN INICIAL: Bot marcado como INACTIVO en cach√© para ${sender}, CANCELANDO procesamiento`);
            return null;
        }

        // ‚ö†Ô∏è VERIFICACI√ìN EN BASE DE DATOS - Forzar consulta a DB
        let isBotActive = false;
        let actualConversationId = conversationId;
        
        // Si no tenemos ID, intentar buscarlo por n√∫mero
        if (!actualConversationId) {
            logDebug(`üîç Buscando conversaci√≥n para ${sender}...`);
            const { data: convById, error: errorById } = await supabase
                .from('conversations')
                .select('id, is_bot_active')
                .eq('user_id', sender)
                .eq('business_id', BUSINESS_ID);
                
            if (errorById) {
                logDebug('‚ùå ERROR CR√çTICO buscando conversaci√≥n: ' + JSON.stringify(errorById));
                return null; // Salir por seguridad
            }
            
            if (convById && convById.length > 0) {
                actualConversationId = convById[0].id;
                isBotActive = convById[0].is_bot_active === true; // Comparaci√≥n estricta
                logDebug(`üîé Encontrada conversaci√≥n: ${actualConversationId}, bot_active=${isBotActive}`);
            } else {
                logDebug(`‚ö†Ô∏è No se encontr√≥ conversaci√≥n para ${sender}`);
                return null; // No hay conversaci√≥n, no procesar
            }
        } else {
            // Tenemos ID, verificamos directamente
            logDebug(`üîç Verificando estado para conversaci√≥n ${actualConversationId}...`);
            const { data: convData, error: convError } = await supabase
                .from('conversations')
                .select('is_bot_active')
                .eq('id', actualConversationId)
                .single();
                
            if (convError) {
                logDebug(`‚ùå Error consultando estado del bot: ${convError.message}`);
                return null; // Salir por seguridad
            }
            
            if (!convData) {
                logDebug(`‚ùå No se encontr√≥ datos para la conversaci√≥n ${actualConversationId}`);
                return null; // No hay datos, no procesar
            }
            
            isBotActive = convData.is_bot_active === true; // Estricto
            logDebug(`üîé Estado de conversaci√≥n ${actualConversationId}: bot_active=${isBotActive}`);
            
            // Verificaci√≥n final - consultar de nuevo como √∫ltimo recurso
            try {
                const { data: finalCheck, error: finalError } = await supabase
                    .from('conversations')
                    .select('is_bot_active')
                    .eq('id', actualConversationId)
                    .single();
                    
                if (!finalError && finalCheck) {
                    logDebug(`üîé VERIFICACI√ìN FINAL: Consultando nuevamente estado para ${actualConversationId}...`);
                    logDebug(`üîé ESTADO FINAL: is_bot_active=${finalCheck.is_bot_active}`);
                    isBotActive = finalCheck.is_bot_active === true;
                    
                    // Actualizar cach√©
                    const userId = conversationIdToPhoneMap[actualConversationId] || sender;
                    if (userId) {
                        senderBotStatusMap[userId] = isBotActive;
                        logDebug(`üìù Cach√© FINAL actualizada: senderBotStatusMap[${userId}] = ${isBotActive}`);
                    }
                }
            } catch (finalCheckError) {
                logDebug(`‚ö†Ô∏è Error en verificaci√≥n final: ${finalCheckError.message}`);
                // Continuar con el valor que ya ten√≠amos
            }
        }
        
        // Verificaci√≥n final: Si el bot est√° desactivado, no procesar
        if (!isBotActive) {
            logDebug(`üö´ Bot DESACTIVADO para ${sender}, cancelando procesamiento`);
            return null;
        }
        
        logDebug(`‚úÖ VERIFICACIONES COMPLETAS: Bot confirmado como ACTIVO para ${sender}, procediendo con OpenAI`);
        
        // ü§ñ Procesamiento con OpenAI Assistants API
        logDebug(`üîë Usando OpenAI API Key: ${OPENAI_API_KEY.substring(0, 10)}...`);
        logDebug(`ü§ñ Usando Assistant ID: ${ASSISTANT_ID}`);
        
        // Verificar si el usuario tiene un thread existente o crear uno nuevo
        if (!userThreads[sender]) {
            try {
                logDebug(`üßµ Creando nuevo thread para usuario ${sender}`);
                const thread = await openai.beta.threads.create();
                userThreads[sender] = thread.id;
                logDebug(`‚úÖ Thread creado con ID: ${thread.id} para usuario ${sender}`);
            } catch (threadError) {
                logDebug(`‚ùå Error creando thread: ${JSON.stringify(threadError)}`);
                return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo m√°s tarde.";
            }
        }
        
        const threadId = userThreads[sender];
        logDebug(`üßµ Usando thread ${threadId} para usuario ${sender}`);
        
        // A√±adir el mensaje al thread
        try {
            logDebug(`üìù A√±adiendo mensaje al thread: "${message}"`);
            await openai.beta.threads.messages.create(threadId, {
                role: "user",
                content: message
            });
            logDebug(`‚úÖ Mensaje a√±adido al thread ${threadId}`);
        } catch (messageError) {
            logDebug(`‚ùå Error a√±adiendo mensaje al thread: ${JSON.stringify(messageError)}`);
            return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo m√°s tarde.";
        }
        
        // Ejecutar el assistant con el thread
        try {
            logDebug(`ü§ñ Procesando con asistente espec√≠fico: ${ASSISTANT_ID}`);
            const run = await openai.beta.threads.runs.create(threadId, {
                assistant_id: ASSISTANT_ID
            });
            
            const runId = run.id;
            logDebug(`üèÉ Run iniciado con ID: ${runId}`);
            
            // Esperar a que termine el procesamiento
            let runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
            let attempts = 1;
            
            while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts <= 10) {
                logDebug(`üîÑ Estado del run: ${runStatus.status} (intento ${attempts})`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo
                runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
                attempts++;
            }
            
            if (runStatus.status !== 'completed') {
                logDebug(`‚ùå El run no se complet√≥ correctamente: ${runStatus.status}`);
                return "Lo siento, no pude procesar tu mensaje en este momento. Por favor, intenta de nuevo m√°s tarde.";
            }
            
            // Obtener respuesta del asistente
            const messages = await openai.beta.threads.messages.list(threadId);
            const assistantMessages = messages.data.filter(msg => 
                msg.role === "assistant" && msg.run_id === runId
            );
            
            if (assistantMessages.length === 0) {
                logDebug('‚ùå No se encontraron respuestas del asistente');
                return "Lo siento, no pude generar una respuesta adecuada. Por favor, intenta de nuevo.";
            }
            
            // Obtener la respuesta m√°s reciente del asistente
            const response = assistantMessages[0].content[0].text.value;
            logDebug(`‚úÖ Respuesta del asistente: "${response.substring(0, 100)}${response.length > 100 ? '...' : ''}"`);
            
            return response;
            
        } catch (runError) {
            logDebug(`‚ùå Error en la ejecuci√≥n del asistente: ${JSON.stringify(runError)}`);
            return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo m√°s tarde.";
        }
        
    } catch (error) {
        logDebug(`‚ùå Error general en processMessageWithOpenAI: ${JSON.stringify(error)}`);
        return "Lo siento, ha ocurrido un error inesperado. Por favor, intenta de nuevo m√°s tarde.";
    }
}

// Funci√≥n para enviar respuesta a WhatsApp
async function sendWhatsAppResponse(recipient, message) {
    try {
        if (!recipient || !message) {
            console.error('‚ùå Faltan par√°metros para env√≠o de mensaje:', { recipient, message });
            return false;
        }
        
        // Limpiar el n√∫mero de tel√©fono (eliminar espacios, +, etc.)
        const cleanPhone = recipient.toString().replace(/\D/g, '');
        
        // Verificar que tengamos credenciales
        if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
          console.error('‚ùå Faltan credenciales de GupShup para enviar mensaje');
          return false;
        }

        console.log(`üì± Enviando mensaje de texto a GupShup para ${cleanPhone}: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
        
        // URL correcta del endpoint seg√∫n la documentaci√≥n
        const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
        
        // Utilizar URLSearchParams para enviar datos en formato form-urlencoded
        const formData = new URLSearchParams();
        formData.append('channel', 'whatsapp');
        formData.append('source', GUPSHUP_NUMBER);
        formData.append('destination', cleanPhone);
        formData.append('src.name', GUPSHUP_NUMBER);
        formData.append('message', JSON.stringify({
            type: 'text',
            text: message
        }));
        
        // Headers correctos seg√∫n documentaci√≥n
        const headers = {
          'Cache-Control': 'no-cache',
          'Content-Type': 'application/x-www-form-urlencoded',
          'apikey': GUPSHUP_API_KEY,
          'userid': GUPSHUP_USERID  // Incluir el userid es crucial
        };
        
        // Enviar la solicitud a la API de GupShup
        let response;
        try {
          response = await axios.post(apiUrl, formData, { headers });
        } catch (apiError) {
          console.error('‚ùå Error al enviar mensaje a GupShup API:', apiError.message);
          if (apiError.response) {
            console.error('Detalles de error de API:', apiError.response.data);
          }
          return false;
        }
        
        // Verificar la respuesta
        if (response && response.data) {
          console.log(`‚úÖ Mensaje enviado correctamente a ${cleanPhone}`);
          return true;
        } else {
          console.error('‚ùå Error en respuesta de GupShup:', response?.data || 'Respuesta vac√≠a');
          return false;
        }
      } catch (error) {
        console.error('‚ùå Error general al enviar mensaje WhatsApp:', error);
        return false;
      }
}

// Funci√≥n para extraer datos del mensaje de la solicitud de webhook
function extractMessageData(body) {
  try {
    console.log(`üîç Extrayendo datos de mensaje de webhook: ${JSON.stringify(body).substring(0, 200)}...`);
    logDebug(`üîç Extrayendo datos de mensaje de webhook: ${JSON.stringify(body).substring(0, 200)}...`);
    
    // Valores por defecto
    const result = {
      isStatusUpdate: false,
      sender: null,
      message: null,
      messageId: null,
      timestamp: null
    };
    
    // Imprimir la estructura completa para depuraci√≥n
    console.log('üìù Estructura completa del webhook:');
    console.log(JSON.stringify(body, null, 2));
    
    // Verificar si es un mensaje o una actualizaci√≥n de estado
    if (body && body.entry && body.entry.length > 0) {
      const entry = body.entry[0];
      
      if (entry.changes && entry.changes.length > 0) {
        const change = entry.changes[0];
        
        // Para mensajes entrantes normales
        if (change.value && change.value.messages && change.value.messages.length > 0) {
          const messageData = change.value.messages[0];
          const contact = change.value.contacts && change.value.contacts.length > 0 
            ? change.value.contacts[0] 
            : null;
          
          result.sender = contact && contact.wa_id ? contact.wa_id : null;
          result.messageId = messageData.id || null;
          
          console.log(`üì® Datos del mensaje: ${JSON.stringify(messageData)}`);
          
          // Extraer contenido seg√∫n el tipo de mensaje
          if (messageData.text && messageData.text.body) {
            result.message = messageData.text.body;
            console.log(`üí¨ Mensaje de texto encontrado: "${result.message}"`);
          } else if (messageData.type === 'text' && messageData.text) {
            result.message = messageData.text.body;
            console.log(`üí¨ Mensaje de texto (tipo): "${result.message}"`);
          } else if (messageData.type === 'button' && messageData.button) {
            result.message = messageData.button.text;
            console.log(`üîò Mensaje de bot√≥n: "${result.message}"`);
          } else if (messageData.type === 'interactive' && messageData.interactive) {
            // Manejar mensajes interactivos (botones, listas, etc.)
            if (messageData.interactive.button_reply) {
              result.message = messageData.interactive.button_reply.title;
              console.log(`üîò Respuesta interactiva (bot√≥n): "${result.message}"`);
            } else if (messageData.interactive.list_reply) {
              result.message = messageData.interactive.list_reply.title;
              console.log(`üìã Respuesta interactiva (lista): "${result.message}"`);
            }
          }
          
          // Si no pudimos extraer el mensaje, intentar con la estructura completa
          if (!result.message && messageData) {
            console.log('‚ö†Ô∏è No se pudo extraer mensaje con m√©todos conocidos, intentando alternativas...');
            // Intentar extraer de cualquier propiedad que tenga "body" o "text"
            if (messageData.body) {
              result.message = messageData.body;
              console.log(`üîÑ Mensaje alternativo (body): "${result.message}"`);
            } else {
              // Buscar en todas las propiedades de primer nivel
              for (const key in messageData) {
                if (typeof messageData[key] === 'object' && messageData[key] !== null) {
                  if (messageData[key].body) {
                    result.message = messageData[key].body;
                    console.log(`üîÑ Mensaje alternativo (${key}.body): "${result.message}"`);
                    break;
                  } else if (messageData[key].text) {
                    result.message = messageData[key].text;
                    console.log(`üîÑ Mensaje alternativo (${key}.text): "${result.message}"`);
                    break;
                  }
                } else if (key === 'text' || key === 'body') {
                  result.message = messageData[key];
                  console.log(`üîÑ Mensaje alternativo (${key}): "${result.message}"`);
                  break;
                }
              }
            }
          }
          
          // Capturar timestamp si est√° disponible
          result.timestamp = messageData.timestamp
            ? new Date(parseInt(messageData.timestamp) * 1000) 
            : new Date();
          
          console.log(`‚è∞ Timestamp: ${result.timestamp}`);
        } 
        // Para actualizaciones de estado de mensajes
        else if (change.value && change.value.statuses && change.value.statuses.length > 0) {
          result.isStatusUpdate = true;
          const status = change.value.statuses[0];
          result.messageId = status.id;
          result.status = status.status;
          result.timestamp = status.timestamp 
            ? new Date(parseInt(status.timestamp) * 1000) 
            : new Date();
          result.recipient = status.recipient_id;
          console.log(`üìä Actualizaci√≥n de estado: ${result.status} para mensaje ${result.messageId}`);
        }
      }
    }
    
    // Verificar si pudimos extraer los datos necesarios
    if (!result.isStatusUpdate && (!result.sender || !result.message)) {
      console.log(`‚ö†Ô∏è No se pudieron extraer datos completos del mensaje: sender=${result.sender}, message=${result.message}`);
      logDebug(`‚ö†Ô∏è No se pudieron extraer datos completos del mensaje: sender=${result.sender}, message=${result.message}`);
    } else {
      console.log(`‚úÖ Datos extra√≠dos correctamente: ${result.isStatusUpdate ? 'actualizaci√≥n de estado' : `mensaje de ${result.sender}: "${result.message}"`}`);
      logDebug(`‚úÖ Datos extra√≠dos correctamente: ${result.isStatusUpdate ? 'actualizaci√≥n de estado' : `mensaje de ${result.sender}`}`);
    }
    
    return result;
  } catch (error) {
    console.log(`‚ùå Error extrayendo datos del mensaje: ${error.message}`);
    console.log(`‚ùå Stack: ${error.stack}`);
    logDebug(`‚ùå Error extrayendo datos del mensaje: ${error.message}`);
    return {
      isStatusUpdate: false,
      sender: null,
      message: null,
      messageId: null,
      timestamp: new Date()
    };
  }
}

// Exportar funciones para testing
module.exports = {
  app,
  extractMessageData,
  processMessageWithOpenAI,
  sendWhatsAppResponse
};

// Iniciar el servidor en el puerto especificado
app.listen(PORT, async () => {
  console.log(`üöÄ Servidor iniciado en puerto ${PORT}`);
  console.log(`ü§ñ Bot conectado al panel: ${CONTROL_PANEL_URL}`);
  
  // Verificar credenciales de GupShup
  console.log('üîç Verificando credenciales de integraci√≥n...');
  if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
    console.warn('‚ö†Ô∏è ADVERTENCIA: Falta alguna credencial de GupShup:');
    console.warn(`  - API Key: ${GUPSHUP_API_KEY ? '‚úÖ Configurada' : '‚ùå Falta'}`);
    console.warn(`  - N√∫mero: ${GUPSHUP_NUMBER ? '‚úÖ Configurado' : '‚ùå Falta'}`);
    console.warn(`  - User ID: ${GUPSHUP_USERID ? '‚úÖ Configurado' : '‚ùå Falta'}`);
    console.warn('‚ö†Ô∏è La integraci√≥n con WhatsApp no funcionar√° sin estas credenciales.');
  } else {
    console.log('‚úÖ Credenciales de GupShup presentes:');
    console.log(`  - API Key: ${GUPSHUP_API_KEY.substring(0, 8)}...`);
    console.log(`  - N√∫mero de origen: ${GUPSHUP_NUMBER}`);
    console.log(`  - User ID: ${GUPSHUP_USERID.substring(0, 8)}...`);
  }
  
  // Verificar credenciales de OpenAI
  if (!OPENAI_API_KEY) {
    console.warn('‚ö†Ô∏è ADVERTENCIA: Falta la clave API de OpenAI. El bot no podr√° responder.');
  } else {
    console.log(`‚úÖ Clave API de OpenAI configurada: ${OPENAI_API_KEY.substring(0, 8)}...`);
    if (OPENAI_API_KEY.startsWith('sk-proj-') && process.env.NODE_ENV === 'production') {
      console.warn('‚ö†Ô∏è ADVERTENCIA: Parece que est√°s usando una clave de API de prueba en producci√≥n.');
    }
  }
  
  // Cargar mapeos iniciales
  console.log('üîÑ Inicializando mapeos y estados...');
  try {
    // Cargar todos los mapeos de n√∫meros telef√≥nicos a conversaciones
    await updateConversationMappings();
    
    // Actualizar estado de bots activos para tener una cach√© inicial
    console.log('üîÑ Cargando estados de bot activo...');
    const { data, error } = await supabase
      .from('conversations')
      .select('id, user_id, is_bot_active')
      .eq('business_id', BUSINESS_ID);
    
    if (!error && data && data.length > 0) {
      data.forEach(conv => {
        if (conv.user_id) {
          senderBotStatusMap[conv.user_id] = conv.is_bot_active;
          console.log(`‚ÑπÔ∏è Bot para ${conv.user_id}: ${conv.is_bot_active ? 'ACTIVO' : 'INACTIVO'}`);
        }
      });
      console.log(`‚úÖ Estados de bot cargados para ${Object.keys(senderBotStatusMap).length} conversaciones`);
    } else if (error) {
      console.warn('‚ö†Ô∏è Error al cargar estados iniciales de bots:', error.message);
    }
  } catch (e) {
    console.error('‚ùå Error en inicializaci√≥n de mapeos:', e.message);
  }
});

// Webhook para recibir mensajes de WhatsApp
app.post('/webhook', async (req, res) => {
    console.log('üì≤ Webhook recibido:', req.body.type);
    
    // Verificar el tipo de webhook
    if (req.body.type === 'message' && req.body.payload) {
        // Detectar si es un mensaje de imagen
        if (req.body.payload.type === 'image') {
            await handleMediaMessage(req, res);
            return;
        }
        
        // Proceso normal para mensajes de texto
        await handleIncomingMessage(req, res);
        return;
    }
    
    // Para otros tipos de webhooks
    res.status(200).json({ success: true, message: 'Webhook recibido' });
});

// Endpoint para enviar un mensaje a WhatsApp
app.post('/api/messages', async (req, res) => {
  console.log('üì© Mensaje manual recibido del dashboard:', JSON.stringify(req.body));
  
  try {
    const { conversationId, message, senderType = 'agent', businessId } = req.body;
    
    // Validar par√°metros requeridos
    if (!conversationId) {
      return res.status(400).json({ error: 'Se requiere conversationId' });
    }
    
    if (!message) {
      return res.status(400).json({ error: 'Se requiere message (contenido del mensaje)' });
    }
    
    if (!businessId) {
      return res.status(400).json({ error: 'Se requiere businessId' });
    }
    
    // Normalizar el ID de conversaci√≥n para manejar n√∫meros de tel√©fono
    const normalizedId = /^\d+$/.test(conversationId.trim()) 
      ? conversationId.trim().replace(/^\+/, '') // Quitar el + si existe
      : conversationId;
    
    console.log(`üì§ Enviando mensaje a conversaci√≥n ${normalizedId}: ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`);
    
    // IMPORTANTE: Primero desactivar el bot ANTES de enviar el mensaje
    // para evitar que responda autom√°ticamente - GARANTIZAR QUE ESTO FUNCIONE
    console.log('üîÑ PASO 1: Desactivando el bot antes de enviar mensaje desde panel...');
    let botWasDeactivated = false;
    
    try {
      // IMPORTANTE: Intentar M√öLTIPLES estrategias para desactivar el bot
      // Estrategia 1: Actualizar directamente en la base de datos
      const { data: botData, error: botError } = await supabase
        .from('conversations')
        .update({ is_bot_active: false })
        .eq('id', normalizedId)
        .select();
      
      if (botError) {
        console.warn('‚ö†Ô∏è Estrategia 1 fall√≥: No se pudo desactivar bot por ID directo:', botError.message);
        
        // Estrategia 2: Buscar por user_id si el ID parece ser un n√∫mero de tel√©fono
        if (/^\d+$/.test(normalizedId)) {
          console.log('üîÑ Intentando Estrategia 2: Desactivar por user_id (n√∫mero telef√≥nico)');
          const { data: phoneUpdate, error: phoneError } = await supabase
            .from('conversations')
            .update({ is_bot_active: false })
            .eq('user_id', normalizedId)
            .eq('business_id', businessId)
            .select();
          
          if (phoneError) {
            console.warn('‚ö†Ô∏è Estrategia 2 fall√≥:', phoneError.message);
          } else if (phoneUpdate && phoneUpdate.length > 0) {
            console.log('‚úÖ Bot desactivado exitosamente con Estrategia 2 (actualizaci√≥n por user_id)');
            botWasDeactivated = true;
          }
        }
      } else if (botData && botData.length > 0) {
        console.log('‚úÖ Bot desactivado exitosamente con Estrategia 1 (actualizaci√≥n directa por ID)');
        botWasDeactivated = true;
      }
      
      // Estrategia 3: Usar SQL directo si las anteriores fallan
      if (!botWasDeactivated) {
        console.log('üîÑ Intentando Estrategia 3: Desactivar con SQL directo');
        // Crear consulta SQL que maneje ambos casos (por ID o por user_id)
        let sqlQuery = '';
        let params = {};
        
        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(normalizedId)) {
          // Es un UUID
          sqlQuery = 'UPDATE conversations SET is_bot_active = false WHERE id = $1 RETURNING *';
          params = [normalizedId];
      } else {
          // Es un n√∫mero telef√≥nico
          sqlQuery = 'UPDATE conversations SET is_bot_active = false WHERE user_id = $1 AND business_id = $2 RETURNING *';
          params = [normalizedId, businessId];
        }
        
        const { data: sqlUpdate, error: sqlError } = await supabase.rpc('execute_sql', { 
          query_text: sqlQuery, 
          params_array: params 
        });
        
        if (sqlError) {
          console.warn('‚ö†Ô∏è Estrategia 3 fall√≥:', sqlError.message);
        } else if (sqlUpdate && sqlUpdate.length > 0) {
          console.log('‚úÖ Bot desactivado exitosamente con Estrategia 3 (SQL directo)');
          botWasDeactivated = true;
        }
      }
    } catch (botToggleError) {
      console.error('‚ùå Error al intentar desactivar el bot:', botToggleError.message);
      // No interrumpir el flujo si falla la desactivaci√≥n
    }
    
    // PASO 2: Enviar el mensaje (asegur√°ndonos que sender_type es 'bot' para cumplir con restricciones de DB)
    console.log('üîÑ PASO 2: Enviando mensaje...');
    const validSenderType = senderType === 'agent' ? 'bot' : senderType;
    
    let messageResult;
    try {
      // Usar registerBotResponse que ya tiene toda la l√≥gica para manejo de mensajes
      messageResult = await global.registerBotResponse(
        normalizedId,
        message,
        businessId,
        validSenderType
      );
      
      if (!messageResult || !messageResult.success) {
        throw new Error(messageResult?.error || 'Error desconocido al registrar mensaje');
      }
      
      console.log('‚úÖ Mensaje registrado exitosamente:', messageResult.id);
    } catch (registerError) {
      console.error('‚ùå Error al registrar mensaje:', registerError.message);
      return res.status(500).json({ 
        error: 'Error al registrar mensaje', 
        details: registerError.message 
      });
    }
    
    // PASO 3: VERIFICAR nuevamente que el bot sigue desactivado
    console.log('üîÑ PASO 3: Verificando que el bot permanece desactivado...');
    try {
      const { data: verifyData, error: verifyError } = await supabase
        .from('conversations')
        .select('id, is_bot_active')
        .or(`id.eq.${normalizedId},user_id.eq.${normalizedId}`)
        .eq('business_id', businessId)
        .single();
      
      if (verifyError) {
        console.warn('‚ö†Ô∏è No se pudo verificar estado del bot:', verifyError.message);
      } else if (verifyData && verifyData.is_bot_active === true) {
        console.warn('‚ö†Ô∏è Bot sigue activo despu√©s del mensaje, intentando desactivar nuevamente...');
        
        // Forzar desactivaci√≥n una vez m√°s
        const { error: updateError } = await supabase
          .from('conversations')
          .update({ is_bot_active: false })
          .eq('id', verifyData.id);
        
        if (updateError) {
          console.error('‚ùå No se pudo desactivar el bot despu√©s de verificaci√≥n:', updateError.message);
        } else {
          console.log('‚úÖ Bot desactivado nuevamente con √©xito');
        }
      } else {
        console.log('‚úÖ Verificado: El bot est√° correctamente desactivado');
      }
    } catch (verifyError) {
      console.warn('‚ö†Ô∏è Error al verificar estado final del bot:', verifyError.message);
    }
    
    // PASO 4: Enviar mensaje a WhatsApp si es necesario
    let whatsappSuccess = false;
    let whatsappError = null;
    
    try {
      console.log('üì≤ PASO 4: Enviando mensaje a WhatsApp...');
      
      // Obtener n√∫mero telef√≥nico si es un conversationId
      let phoneNumber = normalizedId;
      
      if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(normalizedId)) {
        // Es un UUID, buscar el n√∫mero de tel√©fono asociado
        console.log(`üîç Buscando n√∫mero de tel√©fono para conversaci√≥n ${normalizedId}`);
        
        // Verificar primero en cach√©
        if (conversationIdToPhoneMap[normalizedId]) {
          phoneNumber = conversationIdToPhoneMap[normalizedId];
          console.log(`‚úÖ N√∫mero encontrado en cach√© para conversaci√≥n: ${phoneNumber}`);
        } else {
          // Buscar en base de datos
          try {
            const { data, error } = await supabase
              .from('conversations')
              .select('user_id')
              .eq('id', normalizedId)
              .single();
            
            if (error) {
              console.error(`‚ùå Error buscando n√∫mero para conversaci√≥n: ${error.message}`);
              throw new Error(`No se pudo obtener el n√∫mero de tel√©fono: ${error.message}`);
            }
            
            if (data && data.user_id) {
              phoneNumber = data.user_id;
              console.log(`‚úÖ N√∫mero encontrado en DB para conversaci√≥n: ${phoneNumber}`);
              
              // Actualizar cach√©
              conversationIdToPhoneMap[normalizedId] = phoneNumber;
              phoneToConversationMap[phoneNumber] = normalizedId;
            } else {
              console.error(`‚ùå No se encontr√≥ un n√∫mero de tel√©fono para la conversaci√≥n ${normalizedId}`);
              throw new Error('No se encontr√≥ un n√∫mero de tel√©fono asociado a esta conversaci√≥n');
            }
          } catch (dbError) {
            console.error(`‚ùå Error al buscar n√∫mero en DB: ${dbError.message}`);
            throw dbError;
          }
        }
      }
      
      // Verificar que tenemos un n√∫mero v√°lido
      if (!phoneNumber || !/^\d+$/.test(phoneNumber.toString().replace(/^\+/, ''))) {
        console.error(`‚ùå N√∫mero de tel√©fono inv√°lido: ${phoneNumber}`);
        throw new Error(`Formato de n√∫mero inv√°lido: ${phoneNumber}`);
      }
      
      // Asegurar formato correcto del n√∫mero
      const formattedNumber = phoneNumber.toString().replace(/^\+/, '');
      console.log(`üì± N√∫mero final para env√≠o: ${formattedNumber}`);
      
      // Enviar mensaje a WhatsApp directamente
      const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
      
      const formData = new URLSearchParams();
      formData.append('channel', 'whatsapp');
      formData.append('source', GUPSHUP_NUMBER);
      formData.append('destination', formattedNumber);
      formData.append('src.name', GUPSHUP_NUMBER);
      formData.append('message', JSON.stringify({
          type: 'text',
          text: message
      }));
      
      const headers = {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/x-www-form-urlencoded',
        'apikey': GUPSHUP_API_KEY,
        'userid': GUPSHUP_USERID  // A√±adimos el userid para mejorar la autenticaci√≥n
      };
      
      console.log('üîÑ Enviando mensaje directamente a la API de GupShup...');
      console.log(`üìä Par√°metros de env√≠o: destination=${formattedNumber}, text="${message.substring(0, 30)}${message.length > 30 ? '...' : ''}"`);
      
      try {
        const response = await axios.post(apiUrl, formData, { headers });
        
        if (response.status >= 200 && response.status < 300) {
          console.log('‚úÖ Mensaje enviado exitosamente a WhatsApp');
          console.log('üìä Respuesta de GupShup:', JSON.stringify(response.data));
          whatsappSuccess = true;
        } else {
          console.error(`‚ùå Error en la respuesta de GupShup: ${response.status}`);
          whatsappError = `Error HTTP: ${response.status}`;
        }
      } catch (apiError) {
        console.error('‚ùå Error en la llamada a la API de GupShup:', apiError.message);
        
        if (apiError.response) {
          console.error('üìä Detalles del error:', apiError.response.status, JSON.stringify(apiError.response.data || {}));
          whatsappError = `Error HTTP ${apiError.response.status}: ${JSON.stringify(apiError.response.data || {})}`;
        } else if (apiError.request) {
          console.error('üìä No se recibi√≥ respuesta:', apiError.request);
          whatsappError = 'No se recibi√≥ respuesta del servidor de GupShup';
        } else {
          console.error('üìä Error en la configuraci√≥n:', apiError.message);
          whatsappError = apiError.message;
        }
      }
  } catch (error) {
      console.error('‚ùå Error general al enviar mensaje a WhatsApp:', error.message);
      whatsappError = error.message;
      // No fallamos la petici√≥n principal por un error en el env√≠o a WhatsApp
    }
    
    return res.status(200).json({
      success: true,
      id: messageResult.id,
      message: 'Mensaje enviado y bot desactivado correctamente',
      bot_status: 'deactivated',
      sent_to_whatsapp: whatsappSuccess,
      whatsapp_error: whatsappError
    });
  } catch (error) {
    console.error('‚ùå Error general al procesar mensaje:', error);
    return res.status(500).json({ error: error.message });
  }
});

// Endpoint para verificar que el servidor est√° activo y configurado
app.get('/api/status', (req, res) => {
  res.status(200).json({
    status: 'online',
    version: '1.0',
    gupshupConfigured: !!GUPSHUP_API_KEY && !!GUPSHUP_NUMBER,
    openaiConfigured: !!OPENAI_API_KEY && !!ASSISTANT_ID
  });
});

// Endpoint para verificar que el servidor est√° funcionando
app.get('/', (req, res) => {
    res.status(200).json({
        status: "ok", 
        message: "WhatsApp API server is running",
        config: {
            control_panel: CONTROL_PANEL_URL
        }
    });
});

// Endpoint de prueba para simular un mensaje
app.post('/test-message', async (req, res) => {
  try {
    console.log('üì© Mensaje de prueba recibido:', JSON.stringify(req.body));
    
    const { message, sender } = req.body;
    
    if (!message || !sender) {
      return res.status(400).json({ error: 'Mensaje o remitente faltante' });
    }
    
    // Normalizar el ID del remitente
    const normalizedSender = String(sender).trim().replace(/_TEST.*$/i, '');
    console.log(`üë§ Mensaje de prueba recibido de ${normalizedSender}: ${message}`);
    
    // Guardar el mensaje del usuario en Supabase
    try {
      console.log(`üíæ Guardando mensaje del usuario en Supabase: ${message}`);
      const userMessageResult = await global.registerBotResponse(normalizedSender, message, BUSINESS_ID, 'user');
      
      if (userMessageResult && userMessageResult.success) {
        console.log('‚úÖ Mensaje del usuario guardado correctamente en Supabase');
      } else {
        console.error('‚ùå Error al guardar mensaje del usuario en Supabase');
      }
    } catch (supabaseUserError) {
      console.error('‚ùå Error al guardar mensaje del usuario:', supabaseUserError.message);
      // No interrumpimos el flujo principal por un error en el registro
    }
    
    // Enviar mensaje a OpenAI
    const response = await processMessageWithOpenAI(normalizedSender, message);
    
    // Guardar la respuesta del bot en Supabase
    try {
      console.log(`üîÑ Intentando registrar respuesta del bot con business_id: ${BUSINESS_ID}`);
      
      // Usar la funci√≥n global registerBotResponse para guardar en Supabase
      const result = await global.registerBotResponse(normalizedSender, response, BUSINESS_ID, 'bot');
      
      // Verificar resultado
      if (result && result.success === true) {
        console.log(`‚úÖ Respuesta del bot guardada correctamente en Supabase`);
      } else {
        console.error(`‚ùå Error al guardar respuesta del bot en Supabase: ${result?.error || 'Error desconocido'}`);
      }
    } catch (controlPanelError) {
      console.error(`‚ùå Error al registrar respuesta del bot en Supabase:`, controlPanelError.message);
    }
    
    // Solo devolver la respuesta, no enviar a WhatsApp
    return res.status(200).json({ 
      success: true,
      message: response,
      sender: sender
    });
  } catch (error) {
    console.error('‚ùå Error procesando mensaje de prueba:', error.message);
    return res.status(500).json({ error: error.message });
  }
});

// Endpoint para obtener conversaciones por ID de negocio
app.get('/api/conversations/business/:businessId', async (req, res) => {
  try {
    const { businessId } = req.params;
    console.log(`üîç Buscando conversaciones para el negocio: ${businessId}`);
    
    // Cargar directamente la configuraci√≥n de Supabase para asegurar que siempre use valores correctos
    const supabaseConfig = require('./supabase-config');
    const supabaseUrl = process.env.SUPABASE_URL || supabaseConfig.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_KEY || supabaseConfig.SUPABASE_KEY;
    
    // Construir la URL para consultar las conversaciones
    const url = `${supabaseUrl}/rest/v1/conversations?business_id=eq.${businessId}&order=last_message_time.desc`;
    
    // Realizar la consulta a Supabase
    const response = await axios.get(url, {
      headers: {
        'apikey': supabaseKey,
        'Authorization': `Bearer ${supabaseKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const conversations = response.data;
    console.log(`‚úÖ Se encontraron ${conversations.length} conversaciones para el negocio ${businessId}`);
    
    return res.status(200).json(conversations);
  } catch (error) {
    console.error('‚ùå Error al obtener conversaciones:', error.message);
    if (error.response) {
      console.error('  Status:', error.response.status);
      console.error('  Data:', error.response.data);
    }
    return res.status(500).json({ error: 'Error al obtener conversaciones' });
  }
});

// Endpoint para obtener mensajes de una conversaci√≥n espec√≠fica
app.get('/api/messages/:conversationId', async (req, res) => {
    try {
    const conversationId = req.params.conversationId;
    console.log(`üîç Solicitando mensajes para conversaci√≥n/n√∫mero: ${conversationId}`);
    
    if (!conversationId) {
      return res.status(400).json({ error: 'Se requiere ID de conversaci√≥n o n√∫mero de tel√©fono' });
    }
    
    // Determinar si es un UUID (ID de conversaci√≥n) o un n√∫mero de tel√©fono
    const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(conversationId);
    const isPhoneNumber = /^\+?\d+$/.test(conversationId);
    
    console.log(`üîç Tipo de ID proporcionado: ${isUUID ? 'UUID' : isPhoneNumber ? 'N√∫mero de tel√©fono' : 'Desconocido'}`);
    
    // Cargar directamente la configuraci√≥n de Supabase para asegurar que siempre use valores correctos
    const supabaseConfig = require('./supabase-config');
    const supabaseUrl = process.env.SUPABASE_URL || supabaseConfig.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_KEY || supabaseConfig.SUPABASE_KEY;
    
    // Variable para almacenar el ID real de la conversaci√≥n
    let actualConversationId = conversationId;
    
    // Si es un n√∫mero de tel√©fono, necesitamos encontrar el ID de conversaci√≥n
    if (isPhoneNumber) {
      console.log(`üîç Buscando ID de conversaci√≥n para el n√∫mero de tel√©fono: ${conversationId}`);
      
      // Normalizar el n√∫mero (eliminar el s√≠mbolo + si existe)
      const normalizedPhone = conversationId.replace(/^\+/, '');
      
      // Primero verificar en la cach√©
      if (phoneToConversationMap[normalizedPhone]) {
        actualConversationId = phoneToConversationMap[normalizedPhone];
        console.log(`‚úÖ ID de conversaci√≥n encontrado en cach√©: ${actualConversationId}`);
      } else {
        // Buscar en la base de datos
        try {
          // Consultar Supabase para encontrar la conversaci√≥n asociada al n√∫mero
          const conversationUrl = `${supabaseUrl}/rest/v1/conversations?user_id=eq.${normalizedPhone}&business_id=eq.${BUSINESS_ID}&order=created_at.desc&limit=1`;
          
          const conversationResponse = await axios.get(conversationUrl, {
          headers: {
              'apikey': supabaseKey,
              'Authorization': `Bearer ${supabaseKey}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (conversationResponse.data && conversationResponse.data.length > 0) {
            actualConversationId = conversationResponse.data[0].id;
            console.log(`‚úÖ ID de conversaci√≥n encontrado en DB: ${actualConversationId}`);
            
            // Actualizar cach√© para futuras referencias
            phoneToConversationMap[normalizedPhone] = actualConversationId;
            conversationIdToPhoneMap[actualConversationId] = normalizedPhone;
            console.log(`üìù Cach√© actualizada para futuras referencias`);
          } else {
            console.log(`‚ö†Ô∏è No se encontr√≥ ninguna conversaci√≥n para el n√∫mero: ${normalizedPhone}`);
            return res.status(404).json({
              error: `No se encontr√≥ ninguna conversaci√≥n asociada al n√∫mero ${conversationId}`,
              conversationId: conversationId,
              isPhoneNumber: true
            });
          }
        } catch (dbError) {
          console.error('‚ùå Error buscando conversaci√≥n:', dbError.message);
          return res.status(500).json({ error: 'Error buscando conversaci√≥n' });
        }
      }
    }
    
    // Ahora tenemos el ID real de la conversaci√≥n, podemos obtener los mensajes
    console.log(`üîç Obteniendo mensajes para ID de conversaci√≥n: ${actualConversationId}`);
    
    // Construir la URL para consultar los mensajes
    const url = `${supabaseUrl}/rest/v1/messages?conversation_id=eq.${actualConversationId}&order=created_at.asc`;
    
    // Realizar la consulta a Supabase
    const response = await axios.get(url, {
        headers: {
        'apikey': supabaseKey,
        'Authorization': `Bearer ${supabaseKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const messages = response.data;
    console.log(`‚úÖ Encontrados ${messages.length} mensajes para la conversaci√≥n ${actualConversationId}`);
    
    // A√±adir informaci√≥n adicional para ayudar en la depuraci√≥n
    return res.status(200).json({
      messages: messages,
      conversationId: conversationId,
      actualConversationId: actualConversationId,
      isPhoneNumber: isPhoneNumber,
      isUUID: isUUID
        });
    } catch (error) {
    console.error('‚ùå Error al obtener mensajes:', error.message);
    if (error.response) {
      console.error('  Status:', error.response.status);
      console.error('  Data:', error.response.data);
    }
    return res.status(500).json({ error: 'Error al obtener mensajes' });
    }
});

// Nueva ruta para buscar conversaci√≥n por n√∫mero de tel√©fono
app.get('/api/conversation/phone/:phoneNumber', async (req, res) => {
    try {
        console.log(`üîç Buscando conversaci√≥n para n√∫mero: ${req.params.phoneNumber}`);
        
        const { data, error } = await supabase
            .from('conversations')
            .select('*')
            .eq('user_id', req.params.phoneNumber)
            .single();
        
        if (error) {
            console.log(`‚ùå Error buscando conversaci√≥n: ${error.message}`);
            return res.status(400).json({
                error: 'Error buscando conversaci√≥n',
                details: error.message
            });
        }
        
        if (!data) {
            return res.status(404).json({
                error: 'Conversaci√≥n no encontrada',
                details: `No se encontr√≥ conversaci√≥n para el n√∫mero ${req.params.phoneNumber}`
            });
        }
        
        console.log(`‚úÖ Conversaci√≥n encontrada: ${data.id}`);
        return res.json({
            success: true,
            conversation: data
        });
    } catch (error) {
        console.log(`‚ùå Error general: ${error.message}`);
        return res.status(500).json({
            error: 'Error del servidor',
            details: error.message
        });
    }
});

// Endpoint para activar/desactivar el bot para una conversaci√≥n espec√≠fica (acepta PUT y POST)
app.put('/api/conversations/:id/toggle-bot', handleToggleBot);
app.post('/api/conversations/:id/toggle-bot', handleToggleBot);

// Funci√≥n de manejo para toggle-bot
async function handleToggleBot(req, res) {
    try {
        logDebug(`ü§ñ TOGGLE BOT - Iniciando cambio de estado para conversaci√≥n ${req.params.id}`);
        
        const { id } = req.params;
        const { active } = req.body;
        
        if (!id) {
            logDebug(`‚ùå TOGGLE BOT - ID de conversaci√≥n faltante`);
            return res.status(400).json({ error: 'Se requiere ID de conversaci√≥n' });
        }
        
        logDebug(`üîÑ TOGGLE BOT - Solicitando cambio a: ${active ? 'ACTIVO' : 'INACTIVO'} para conversaci√≥n ${id}`);
        
        // Obtener datos de la conversaci√≥n para verificar que existe
        const { data: convData, error: convError } = await supabase
            .from('conversations')
            .select('id, user_id, business_id')
            .eq('id', id)
            .single();
            
        if (convError) {
            logDebug(`‚ùå TOGGLE BOT - Error obteniendo datos de conversaci√≥n: ${convError.message}`);
            return res.status(404).json({ error: 'Conversaci√≥n no encontrada', details: convError.message });
        }
        
        if (!convData) {
            logDebug(`‚ùå TOGGLE BOT - Conversaci√≥n ${id} no existe en la base de datos`);
            return res.status(404).json({ error: 'Conversaci√≥n no encontrada' });
        }
        
        // Actualizar estado del bot en la base de datos
        const { data, error } = await supabase
            .from('conversations')
            .update({ is_bot_active: active })
            .eq('id', id)
            .select('id, user_id, is_bot_active')
            .single();
            
        if (error) {
            logDebug(`‚ùå TOGGLE BOT - Error actualizando estado: ${error.message}`);
            return res.status(500).json({ 
                error: 'Error al actualizar estado del bot', 
                details: error.message 
            });
        }
        
        logDebug(`‚úÖ TOGGLE BOT - Estado actualizado en DB: is_bot_active=${active} para conversaci√≥n ${id}`);
        
        // Actualizar cach√©
        if (data && data.user_id) {
            senderBotStatusMap[data.user_id] = active;
            logDebug(`üìù TOGGLE BOT - Cach√© actualizada: senderBotStatusMap[${data.user_id}] = ${active}`);
        }
        
        // En desarrollo, mostrar todos los mapeos actualizados
        if (process.env.NODE_ENV !== 'production') {
            logDebug('üìä TOGGLE BOT - Estado actual de cache:');
            Object.keys(senderBotStatusMap).forEach(key => {
                logDebug(`   - ${key}: ${senderBotStatusMap[key] ? 'ACTIVO' : 'INACTIVO'}`);
            });
        }
        
        return res.status(200).json({ 
            success: true, 
            is_bot_active: active, 
            message: `Bot ${active ? 'activado' : 'desactivado'} exitosamente`,
            conversation_id: id,
            user_id: data.user_id
        });
    } catch (error) {
        logDebug(`‚ùå TOGGLE BOT - Error general: ${error.message}`);
        return res.status(500).json({ 
            error: 'Error al procesar la solicitud', 
            message: error.message 
        });
    }
}

// Endpoint para verificar el estado actual del bot
app.get('/api/bot-status/:id', handleBotStatus);

// Funci√≥n para manejar la verificaci√≥n del estado del bot
async function handleBotStatus(req, res) {
    try {
        const { id } = req.params;
        
        if (!id) {
            return res.status(400).json({ error: 'Se requiere ID de conversaci√≥n o n√∫mero de tel√©fono' });
        }
        
        logDebug(`üîç Verificando estado del bot para: ${id}`);
        
        // Verificar si es un UUID o un n√∫mero de tel√©fono
        const isUUID = id.includes('-');
        
        let query;
        if (isUUID) {
            // Es un ID de conversaci√≥n
            query = supabase
                .from('conversations')
                .select('id, user_id, is_bot_active, last_message_time')
                .eq('id', id);
        } else {
            // Es un n√∫mero de tel√©fono
            query = supabase
                .from('conversations')
                .select('id, user_id, is_bot_active, last_message_time')
                .eq('user_id', id);
        }
        
        const { data, error } = await query;
        
        if (error) {
            logDebug(`‚ùå Error consultando estado del bot: ${error.message}`);
            return res.status(500).json({ 
                error: 'Error al consultar estado', 
                details: error.message 
            });
        }
        
        if (!data || data.length === 0) {
            logDebug(`‚ö†Ô∏è No se encontr√≥ conversaci√≥n para: ${id}`);
            return res.status(404).json({ 
                error: 'Conversaci√≥n no encontrada', 
                id 
            });
        }
        
        // Obtener el estado del cache tambi√©n
        const cacheStatus = isUUID 
            ? (data[0].user_id ? senderBotStatusMap[data[0].user_id] : undefined)
            : senderBotStatusMap[id];
        
        logDebug(`‚úÖ Estado encontrado para ${id}:`);
        logDebug(`   - DB: ${data.map(c => `${c.id}=${c.is_bot_active}`).join(', ')}`);
        logDebug(`   - Cache: ${cacheStatus !== undefined ? cacheStatus : 'no en cach√©'}`);
        
        return res.status(200).json({
            success: true,
            conversations: data.map(conv => ({
                id: conv.id,
                user_id: conv.user_id,
                is_bot_active: conv.is_bot_active,
                last_message_time: conv.last_message_time,
                cache_status: conv.user_id ? senderBotStatusMap[conv.user_id] : undefined
            })),
            cache_status: cacheStatus
        });
  } catch (error) {
        logDebug(`‚ùå Error general en bot-status: ${error.message}`);
        return res.status(500).json({ 
            error: 'Error al procesar la solicitud', 
            message: error.message 
        });
    }
}

// Endpoint para simular el procesamiento con OpenAI sin enviar a WhatsApp
app.post('/api/simulate-openai/:id', handleSimulateOpenAI);

// Funci√≥n para manejar la simulaci√≥n
async function handleSimulateOpenAI(req, res) {
    try {
        const { id } = req.params;
        const { message } = req.body;
        
        if (!id) {
            return res.status(400).json({ error: 'Se requiere ID de conversaci√≥n o n√∫mero de tel√©fono' });
        }
        
        if (!message) {
            return res.status(400).json({ error: 'Se requiere un mensaje para procesar' });
        }
        
        logDebug(`üî¨ SIMULACI√ìN - Procesando mensaje para ${id}: "${message}"`);
        
        // Sobreescribir temporalmente sendWhatsAppResponse para capturar respuesta
        const originalSendWhatsApp = sendWhatsAppResponse;
        let capturedResponse = null;
        
        sendWhatsAppResponse = async (recipient, response) => {
            logDebug(`üìù SIMULACI√ìN - Capturando respuesta: "${response.substring(0, 100)}${response.length > 100 ? '...' : ''}"`);
            capturedResponse = response;
            return true; // Simular √©xito
        };
        
        try {
            // Si es un UUID (ID de conversaci√≥n)
            const isUUID = id.includes('-');
            let userId = id;
            let conversationId = isUUID ? id : null;
            
            // Si es un ID de conversaci√≥n, obtener el user_id
            if (isUUID) {
                const { data, error } = await supabase
                    .from('conversations')
                    .select('user_id')
                    .eq('id', id)
                    .single();
                    
                if (error || !data) {
                    return res.status(404).json({ error: 'Conversaci√≥n no encontrada' });
                }
                
                userId = data.user_id;
            } 
            // Si es un n√∫mero de tel√©fono, buscar la conversaci√≥n correspondiente
            else {
                const { data, error } = await supabase
                    .from('conversations')
                    .select('id')
                    .eq('user_id', id)
                    .order('created_at', { ascending: false })
                    .limit(1);
                    
                if (!error && data && data.length > 0) {
                    conversationId = data[0].id;
                }
            }
            
            // Guardar estado original del bot para este usuario
            const originalBotStatus = senderBotStatusMap[userId];
            
            // Forzar estado activo para la simulaci√≥n
            senderBotStatusMap[userId] = true;
            logDebug(`ü§ñ SIMULACI√ìN - Forzando bot ACTIVO temporalmente para ${userId}`);
            
            // Procesar con OpenAI
            const response = await processMessageWithOpenAI(userId, message, conversationId);
            
            // Restaurar estado original
            senderBotStatusMap[userId] = originalBotStatus;
            logDebug(`üîÑ SIMULACI√ìN - Restaurando estado original del bot: ${originalBotStatus ? 'ACTIVO' : 'INACTIVO'}`);
            
            // Restaurar funci√≥n original
            sendWhatsAppResponse = originalSendWhatsApp;
            
            if (capturedResponse) {
                return res.status(200).json({
                    success: true,
                    message: 'Simulaci√≥n exitosa',
                    response: capturedResponse,
                    user_id: userId,
                    conversation_id: conversationId
                });
    } else {
                return res.status(500).json({
                    success: false,
                    message: 'No se pudo generar una respuesta'
                });
            }
        } finally {
            // Asegurar que la funci√≥n original se restaure incluso si hay error
            sendWhatsAppResponse = originalSendWhatsApp;
    }
  } catch (error) {
        logDebug(`‚ùå SIMULACI√ìN - Error: ${error.message}`);
        return res.status(500).json({
            error: 'Error al procesar la simulaci√≥n',
            message: error.message
        });
    }
}

// Configurar el registro en archivo de depuraci√≥n
const debugLogFile = path.join(__dirname, 'debug.log');
const logDebug = (message) => {
  const timestamp = new Date().toISOString();
  const logMessage = `${timestamp} - ${message}\n`;
  fs.appendFileSync(debugLogFile, logMessage);
  console.log(message); // Tambi√©n mantener los logs en la consola
};

// Tambi√©n reemplazar algunas instancias clave de console.log con logDebug
// ... existing code ...

// Endpoint para pruebas de GupShup API
app.get('/api/test-gupshup', async (req, res) => {
  try {
    console.log('üîç Probando credenciales de GupShup...');
    
    // Mostrar informaci√≥n de configuraci√≥n
    console.log(`üîë API Key: ${GUPSHUP_API_KEY ? 'Configurada (primeros 10 caracteres: ' + GUPSHUP_API_KEY.substring(0, 10) + '...)' : 'No configurada'}`);
    console.log(`üì± N√∫mero: ${GUPSHUP_NUMBER || 'No configurado'}`);
    console.log(`üë§ User ID: ${GUPSHUP_USERID ? 'Configurado (primeros 10 caracteres: ' + GUPSHUP_USERID.substring(0, 10) + '...)' : 'No configurado'}`);
    
    // Probar conexi√≥n a GupShup - Verificar estado de la cuenta
    const apiUrl = 'https://api.gupshup.io/wa/api/v1/users/info';
    
    const headers = {
      'apikey': GUPSHUP_API_KEY,
      'Content-Type': 'application/json'
    };
    
    console.log('üîÑ Realizando solicitud a GupShup...');
    
    try {
      const response = await axios.get(apiUrl, { headers });
      
      console.log(`‚úÖ Conexi√≥n exitosa a GupShup: ${response.status}`);
      console.log(`üìä Datos recibidos: ${JSON.stringify(response.data)}`);
      
      return res.json({
        success: true,
        status: 'Conexi√≥n exitosa',
        message: 'Las credenciales de GupShup son v√°lidas',
        apiResponse: response.data
      });
    } catch (apiError) {
      console.log(`‚ùå Error al conectar con GupShup: ${apiError.message}`);
      
      let errorDetails = {
        message: apiError.message
      };
      
      if (apiError.response) {
        errorDetails.status = apiError.response.status;
        errorDetails.data = apiError.response.data;
        console.log(`‚ùå Respuesta de error: ${apiError.response.status} - ${JSON.stringify(apiError.response.data)}`);
      }
      
      return res.status(500).json({
        success: false,
        status: 'Error de conexi√≥n',
        message: 'Fall√≥ la conexi√≥n con GupShup',
        error: errorDetails
      });
    }
  } catch (error) {
    console.error(`‚ùå Error general: ${error.message}`);
    return res.status(500).json({
      success: false,
      status: 'Error',
      message: error.message
    });
  }
});

// ... existing code ...

// Endpoint para actualizar credenciales de GupShup
app.post('/api/update-gupshup-credentials', async (req, res) => {
  try {
    const { apiKey, number, userId } = req.body;
    
    console.log('üîÑ Actualizando credenciales de GupShup...');
    
    // Comprobar que se proporcionaron los datos necesarios
    if (!apiKey && !number && !userId) {
      return res.status(400).json({
        success: false,
        message: 'Debe proporcionar al menos una credencial para actualizar (apiKey, number o userId)'
      });
    }
    
    // Guardar valores anteriores para poder restaurarlos en caso de error
    const previousApiKey = GUPSHUP_API_KEY;
    const previousNumber = GUPSHUP_NUMBER;
    const previousUserId = GUPSHUP_USERID;
    
    // Actualizar las variables globales con los nuevos valores
    if (apiKey) {
      console.log(`üîë Actualizando API Key: ${apiKey.substring(0, 8)}...`);
      GUPSHUP_API_KEY = apiKey;
    }
    
    if (number) {
      console.log(`üì± Actualizando n√∫mero: ${number}`);
      GUPSHUP_NUMBER = number;
    }
    
    if (userId) {
      console.log(`üë§ Actualizando User ID: ${userId.substring(0, 8)}...`);
      GUPSHUP_USERID = userId;
    }
    
    // Probar conexi√≥n a GupShup con las nuevas credenciales
    const apiUrl = 'https://api.gupshup.io/wa/api/v1/users/info';
    
    const headers = {
      'apikey': GUPSHUP_API_KEY,
      'Content-Type': 'application/json'
    };
    
    console.log('üîÑ Probando conexi√≥n con nuevas credenciales...');
    
    try {
      const response = await axios.get(apiUrl, { headers });
      
      console.log(`‚úÖ Conexi√≥n exitosa con nuevas credenciales: ${response.status}`);
      console.log(`üìä Datos recibidos: ${JSON.stringify(response.data)}`);
      
      return res.json({
        success: true,
        message: 'Credenciales actualizadas correctamente',
        updatedCredentials: {
          apiKey: apiKey ? `${apiKey.substring(0, 8)}...` : 'No actualizada',
          number: number || 'No actualizado',
          userId: userId ? `${userId.substring(0, 8)}...` : 'No actualizado'
        },
        apiResponse: response.data
      });
    } catch (apiError) {
      // Restaurar valores anteriores en caso de error
      console.log(`‚ùå Error al conectar con nuevas credenciales: ${apiError.message}`);
      console.log('üîÑ Restaurando credenciales anteriores...');
      
      GUPSHUP_API_KEY = previousApiKey;
      GUPSHUP_NUMBER = previousNumber;
      GUPSHUP_USERID = previousUserId;
      
      let errorDetails = {
        message: apiError.message
      };
      
      if (apiError.response) {
        errorDetails.status = apiError.response.status;
        errorDetails.data = apiError.response.data;
        console.log(`‚ùå Respuesta de error: ${apiError.response.status} - ${JSON.stringify(apiError.response.data)}`);
      }
      
      return res.status(500).json({
        success: false,
        message: 'Error al conectar con GupShup usando las nuevas credenciales',
        error: errorDetails
      });
    }
  } catch (error) {
    console.error(`‚ùå Error general: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// ... existing code ...

// Endpoint para enviar mensajes manuales desde el dashboard
app.post('/api/send-manual-message', async (req, res) => {
  console.log('üìù Recibida solicitud para enviar mensaje manual:', JSON.stringify(req.body));
  
  try {
    const { phoneNumber, message, mediaUrl, forceManual } = req.body;
    
    // Validar campos requeridos
    if (!phoneNumber || !phoneNumber.trim()) {
      console.error('‚ùå Error: No se proporcion√≥ n√∫mero de tel√©fono');
      return res.status(400).json({ 
        success: false, 
        error: 'Se requiere n√∫mero de tel√©fono' 
      });
    }
    
    if (!message && !mediaUrl) {
      console.error('‚ùå Error: No se proporcion√≥ mensaje ni URL de medio');
      return res.status(400).json({ 
        success: false, 
        error: 'Se requiere mensaje o URL de medio' 
      });
    }
    
    // Formatear n√∫mero de tel√©fono (eliminar espacios, guiones, etc.)
    const formattedPhone = phoneNumber.replace(/\D/g, '');
    
    console.log(`‚öôÔ∏è Procesando mensaje manual para ${formattedPhone}`, {
      tieneMedia: !!mediaUrl,
      longitudMensaje: message?.length || 0,
      forzado: !!forceManual
    });
    
    // Si forceManual es true, ignorar el estado de activaci√≥n del bot
    // Este par√°metro permite enviar mensajes incluso si el bot est√° inactivo para este n√∫mero
    if (forceManual === true) {
      console.log(`‚ö†Ô∏è Modo forzado manual activado: enviando mensaje independientemente del estado de activaci√≥n del bot`);
      
      // Enviar mensaje directamente sin verificar estado del bot
      if (mediaUrl) {
        console.log(`üì± Enviando mensaje forzado a ${formattedPhone} con imagen: ${mediaUrl}`);
        
        try {
          // Si hay imagen, enviar como texto con URL de la imagen o usar GupShup
          const success = await sendTextMessageGupShup(formattedPhone, `${message || ''}\n${mediaUrl}`);
          
          if (success) {
            console.log(`‚úÖ Mensaje con imagen enviado correctamente a ${formattedPhone} (modo forzado)`);
            
            return res.json({
              success: true,
              message: 'Mensaje con imagen enviado correctamente',
              mode: 'forced_manual'
            });
          } else {
            throw new Error('No se pudo enviar el mensaje con imagen');
          }
        } catch (mediaError) {
          console.error(`‚ùå Error al enviar mensaje con imagen: ${mediaError.message}`);
          return res.status(500).json({
            success: false,
            error: `Error al enviar mensaje con imagen: ${mediaError.message}`,
            mode: 'forced_manual'
          });
        }
      }
      
      // Enviar mensaje de texto normal
      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un mensaje de texto',
          mode: 'forced_manual'
        });
      }
      
      console.log(`üì± Enviando mensaje de texto forzado a ${formattedPhone}: ${message}`);
      const success = await sendTextMessageGupShup(formattedPhone, message);
      
      if (success) {
        console.log(`‚úÖ Mensaje de texto enviado correctamente a ${formattedPhone} (modo forzado)`);
        
        return res.json({
          success: true,
          message: 'Mensaje enviado correctamente',
          mode: 'forced_manual'
        });
      } else {
        console.error(`‚ùå Error al enviar mensaje de texto`);
        return res.status(500).json({
          success: false,
          error: 'Error al enviar mensaje de texto',
          mode: 'forced_manual'
        });
      }
    }
    
    // C√≥digo original para cuando no est√° en modo forzado
    if (mediaUrl) {
      console.log(`üì± Enviando mensaje a ${formattedPhone} con imagen: ${mediaUrl}`);
      
      // Si hay imagen, enviar como texto con URL de la imagen para mantenerlo simple
      try {
        const success = await sendWhatsAppResponse(formattedPhone, `${message || 'Imagen'}\n${mediaUrl}`);
        
        if (success) {
          console.log(`‚úÖ Mensaje con URL de imagen enviado correctamente a ${formattedPhone}`);
          
          return res.json({
            success: true,
            message: 'Mensaje con URL de imagen enviado correctamente'
          });
        }
      } catch (mediaError) {
        console.error(`‚ùå Error al enviar mensaje con imagen: ${mediaError.message}`);
        return res.status(500).json({
          success: false,
          error: `Error al enviar mensaje con imagen: ${mediaError.message}`
        });
      }
    }

    // ... existing code (continuaci√≥n del endpoint) ...
  } catch (error) {
    console.error('‚ùå Error general al procesar solicitud:', error);
    
    res.status(500).json({
      success: false,
      error: `Error al procesar solicitud: ${error.message}`
    });
  }
});

// Funci√≥n para enviar mensajes de texto a WhatsApp
async function sendWhatsAppTextMessage(phoneNumber, message) {
  console.log(`üì§ Enviando mensaje de texto a ${phoneNumber}: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
  
  try {
    const response = await axios.post(
      'https://api.gupshup.io/sm/api/v1/msg',
      `channel=whatsapp&source=${GUPSHUP_NUMBER}&destination=${phoneNumber}&message=${encodeURIComponent(message)}&disablePreview=false&source=${GUPSHUP_NUMBER}`,
      {
        headers: {
          'Cache-Control': 'no-cache',
          'Content-Type': 'application/x-www-form-urlencoded',
          'apikey': GUPSHUP_API_KEY,
          'Accept': 'application/json'
        }
      }
    );
    
    console.log('‚úÖ Respuesta de GupShup al enviar texto:', JSON.stringify(response.data));
    return true;
  } catch (error) {
    console.error('‚ùå Error en sendWhatsAppTextMessage:', error.message);
    throw error;
  }
}

async function sendMediaMessage(recipient, mediaUrl, caption = '') {
    try {
        console.log(`üì§ Enviando media a ${recipient} - URL: ${mediaUrl}`);
        
        if (!recipient || !mediaUrl) {
            console.error('‚ùå Error: Destinatario o URL de media faltantes');
            return false;
        }
        
        // Formatear el n√∫mero (eliminar + al principio si existe)
        const formattedNumber = recipient.startsWith('+') 
            ? recipient.substring(1) 
            : recipient;
        
        // Verificar que el n√∫mero contenga solo d√≠gitos
        if (!/^\d+$/.test(formattedNumber)) {
            console.error(`‚ùå N√∫mero inv√°lido: ${formattedNumber}`);
            return false;
        }
        
        // Verificar la URL
        if (!mediaUrl.startsWith('http')) {
            console.error(`‚ùå URL de imagen inv√°lida: ${mediaUrl}`);
            return false;
        }
        
        // Verificar credenciales de GupShup
        if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
            console.error('‚ùå CREDENCIALES FALTANTES:', {
                apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
                number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
                userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA'
            });
            return false;
        }
        
        // API v1 de GupShup
        const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
        const apiKey = GUPSHUP_API_KEY;
        const source = GUPSHUP_NUMBER;
        
        console.log(`üîë Usando API Key para media: ${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 5)}`);
        console.log(`üì± Usando n√∫mero en GupShup: ${source}`);
        console.log(`üì± Hacia n√∫mero: ${formattedNumber}`);
        
        // Crear el mensaje para imagen
        const mediaMessage = {
            type: "image",
            originalUrl: mediaUrl,
            previewUrl: mediaUrl,
            caption: caption || ""
        };
        
        const formData = new URLSearchParams();
        formData.append('channel', 'whatsapp');
        formData.append('source', source);
        formData.append('destination', formattedNumber);
        formData.append('src.name', source);
        formData.append('message', JSON.stringify(mediaMessage));
        
        const headers = {
            'Cache-Control': 'no-cache',
            'Content-Type': 'application/x-www-form-urlencoded',
            'apikey': apiKey,
            'userid': GUPSHUP_USERID
        };
        
        console.log('üîÑ Enviando imagen a WhatsApp...');
        console.log('üì¶ Payload:', JSON.stringify({
            message: mediaMessage,
            destination: formattedNumber
        }, null, 2));
        
        try {
            const response = await axios.post(apiUrl, formData, { headers });
            
            console.log('üì° Respuesta de GupShup Media:', JSON.stringify(response.data));
            
            if (response.status >= 200 && response.status < 300) {
                console.log('‚úÖ Imagen enviada exitosamente a WhatsApp');
                
                // Guardar mensaje en la base de datos
                try {
                    await global.registerBotResponse(
                        recipient,
                        caption || 'Imagen enviada',
                        BUSINESS_ID, 
                        'bot',
                        mediaUrl
                    );
                    console.log('‚úÖ Mensaje media guardado en Supabase');
                } catch (dbError) {
                    console.error(`‚ö†Ô∏è Error guardando mensaje media en Supabase: ${dbError.message}`);
                }
                
                return true;
            } else {
                console.error(`‚ùå Error: C√≥digo de respuesta ${response.status}`);
                return false;
            }
        } catch (apiError) {
            console.error(`‚ùå Error en solicitud de media a GupShup:`, apiError.message);
            
            if (apiError.response) {
                console.error(`- Status: ${apiError.response.status}`);
                console.error(`- Datos: `, JSON.stringify(apiError.response.data, null, 2));
                console.error(`- Headers: `, JSON.stringify(apiError.response.headers, null, 2));
            } else if (apiError.request) {
                console.error(`- No hubo respuesta del servidor`);
            } else {
                console.error(`- Error al configurar la solicitud:`, apiError.message);
            }
            
            // Intentar enviando como texto con el link
            console.log('‚ö†Ô∏è Fallback: Intentando enviar el enlace de la imagen como texto');
            await sendWhatsAppResponse(recipient, `No se pudo enviar la imagen directamente. Aqu√≠ est√° el enlace: ${mediaUrl}\n\n${caption || ''}`);
            
            return false;
        }
    } catch (error) {
        console.error(`‚ùå Error general en sendMediaMessage:`, error.message);
        console.error(error.stack);
        
        // Intentar enviando como texto con el link
        console.log('‚ö†Ô∏è Fallback: Enviando enlace como texto despu√©s de error general');
        await sendWhatsAppResponse(recipient, `No se pudo enviar la imagen. Aqu√≠ est√° el enlace: ${mediaUrl}\n\n${caption || ''}`);
        
        return false;
    }
}

// Funci√≥n para manejar mensajes con im√°genes
async function handleMediaMessage(req, res) {
    try {
        console.log('‚öôÔ∏è Procesando webhook de imagen en WhatsApp');
        
        // Extraer datos del cuerpo del mensaje
        const webhookData = req.body;
        console.log('üì¶ Datos del webhook:', JSON.stringify(webhookData, null, 2));
        
        if (!webhookData || !webhookData.payload) {
            console.error('‚ùå Estructura de webhook no v√°lida');
            return res.status(400).json({ error: 'Estructura de webhook no v√°lida' });
        }
        
        // Extraer informaci√≥n del payload
        const { payload } = webhookData;
        const { sender, type } = payload;
        
        if (!sender || !sender.phone) {
            console.error('‚ùå No se encontr√≥ informaci√≥n del remitente');
            return res.status(400).json({ error: 'No se encontr√≥ informaci√≥n del remitente' });
        }
        
        // Obtener el n√∫mero de tel√©fono del remitente
        const senderPhone = sender.phone;
        console.log(`üì± N√∫mero del remitente: ${senderPhone}`);
        
        // Guardar mensaje en la base de datos si es un mensaje de tipo imagen
        if (type === 'image' && payload.payload && payload.payload.url) {
            try {
                const imageUrl = payload.payload.url;
                const caption = payload.payload.caption || '';
                
                console.log(`üñºÔ∏è URL de la imagen recibida: ${imageUrl}`);
                console.log(`üìù Caption: ${caption}`);
                
                // Registramos el mensaje en la base de datos
                await global.registerMessage(
                    senderPhone,
                    caption || 'Imagen recibida',
                    BUSINESS_ID,
                    'customer',
                    imageUrl  // Incluimos la URL de la imagen
                );
                
                console.log('‚úÖ Mensaje con imagen guardado en Supabase');
                
                // Respondemos al webhook
                res.status(200).json({ success: true });
                
                // Enviar a la API de procesamiento
                await processImage(senderPhone, imageUrl, caption);
                
                return;
            } catch (error) {
                console.error('‚ùå Error procesando imagen:', error.message);
                return res.status(500).json({ error: 'Error procesando imagen' });
            }
        } else {
            console.log('‚ö†Ô∏è No es un mensaje de tipo imagen o falta URL');
            return res.status(400).json({ error: 'No es un mensaje de imagen o falta URL' });
        }
    } catch (error) {
        console.error('‚ùå Error general en handleMediaMessage:', error.message);
        console.error(error.stack);
        return res.status(500).json({ error: 'Error interno del servidor' });
    }
}

// Funci√≥n para procesar im√°genes recibidas
async function processImage(senderPhone, imageUrl, caption = '') {
    try {
        console.log(`üîÑ Procesando imagen de ${senderPhone}: ${imageUrl}`);
        
        // Aqu√≠ puedes implementar l√≥gica para procesar la imagen
        // Por ejemplo, enviarla a un servicio de IA para an√°lisis
        
        // Por ahora, simplemente enviamos un mensaje de confirmaci√≥n
        await sendWhatsAppResponse(
            senderPhone,
            `‚úÖ Hemos recibido tu imagen. La estamos procesando...`
        );
        
        // Simular respuesta despu√©s de "procesar" la imagen
        setTimeout(async () => {
            await sendWhatsAppResponse(
                senderPhone,
                `üì∏ Imagen procesada correctamente.\n${caption ? `Tu mensaje: "${caption}"` : ''}`
            );
        }, 2000);
        
        return true;
    } catch (error) {
        console.error('‚ùå Error en processImage:', error.message);
        
        // Intentar enviar mensaje de error al usuario
        try {
            await sendWhatsAppResponse(
                senderPhone,
                "‚ùå Lo sentimos, hubo un problema al procesar tu imagen. Por favor, intenta nuevamente m√°s tarde."
            );
        } catch (sendError) {
            console.error('‚ùå Error enviando mensaje de error:', sendError.message);
        }
        
        return false;
    }
}

// Extraer datos de mensajes multimedia de WebHook
function extractMediaData(webhookBody) {
    try {
        console.log(`üì§ Extrayendo datos de mensaje multimedia`);
        
        if (!webhookBody || !webhookBody.payload) {
            return { error: 'Formato de webhook inv√°lido' };
        }
        
        // Extraer informaci√≥n general
        const { payload } = webhookBody;
        
        // Verificar si es una actualizaci√≥n de estado
        const isStatusUpdate = payload.type === 'status' || 
            payload.type === 'message-event' || 
            (webhookBody.type && webhookBody.type === 'message-event');
        
        if (isStatusUpdate) {
            return { isStatusUpdate: true };
        }
        
        // Extraer datos seg√∫n el tipo de mensaje
        if (payload.type === 'image') {
            // Extraer datos de la imagen
            const sender = payload.sender && payload.sender.phone;
            const imageUrl = payload.payload && payload.payload.url;
            const caption = payload.payload && payload.payload.caption || '';
            const messageId = payload.messageId || payload.id;
            
            return {
                sender,
                messageId,
                isImage: true,
                imageUrl,
                caption,
                message: caption || 'Imagen recibida'
            };
        } else {
            // Para otros tipos, usar el extractor normal
            return extractMessageData(webhookBody);
        }
    } catch (error) {
        console.error(`‚ùå Error extrayendo datos multimedia: ${error.message}`);
        return { error: error.message };
    }
}

// Funci√≥n para manejar mensajes entrantes de texto
async function handleIncomingMessage(req, res) {
    try {
        const body = req.body;
        console.log(`üì© Mensaje recibido en webhook: ${JSON.stringify(body).substring(0, 500)}...`);
        
        // Extraer datos del mensaje
        const messageData = extractMessageData(body);
        
        // Si es una actualizaci√≥n de estado, solo registrarla
        if (messageData.isStatusUpdate) {
            console.log(`üìä Notificaci√≥n de estado recibida, no requiere respuesta`);
            console.log(`üìä Procesada notificaci√≥n de estado`);
            return res.sendStatus(200);
        }
        
        const { sender, message, messageId } = messageData;
        
        if (!sender || !message) {
            console.log(`‚ö†Ô∏è Mensaje incompleto recibido, ignorando: ${JSON.stringify(messageData)}`);
            return res.sendStatus(200);
        }
        
        console.log(`üë§ Mensaje recibido de ${sender}: ${message}`);
        
        // Verificar si este mensaje ya fue procesado recientemente
        const messageKey = `${messageId || sender}_${message}`;
        if (recentlyProcessedMessages.has(messageKey)) {
            console.log(`‚ö†Ô∏è Mensaje duplicado detectado, ignorando: ${messageKey}`);
            return res.sendStatus(200);
        }
        
        // Marcar este mensaje como procesado
        recentlyProcessedMessages.add(messageKey);
        setTimeout(() => recentlyProcessedMessages.delete(messageKey), 60000); // Eliminar despu√©s de 1 minuto
        
        // Guardar mensaje en Supabase
        console.log(`üíæ Guardando mensaje entrante para ${sender}`);
        let conversationId = null;
        
        try {
            // Verificar si tenemos un ID de conversaci√≥n mapeado para este n√∫mero
            if (phoneToConversationMap[sender]) {
                conversationId = phoneToConversationMap[sender];
                console.log(`‚úÖ ID de conversaci√≥n encontrado en cach√©: ${conversationId}`);
            }
            
            // Guardar mensaje del usuario en la base de datos
            console.log(`üíæ Guardando mensaje de tipo 'user' para: ${sender}`);
            const userMessageResult = await global.registerBotResponse(sender, message, BUSINESS_ID, 'user');
    
            if (userMessageResult && userMessageResult.success) {
                console.log('‚úÖ Mensaje guardado en Supabase correctamente');
                conversationId = userMessageResult.conversationId;
                
                // Actualizar mapeo de conversaci√≥n
                if (conversationId && sender) {
                    phoneToConversationMap[sender] = conversationId;
                    conversationIdToPhoneMap[conversationId] = sender;
                }
            } else {
                console.error(`‚ùå Error al guardar mensaje en Supabase: ${userMessageResult?.error || 'Error desconocido'}`);
            }
        } catch (supabaseError) {
            console.error(`‚ùå Error al guardar mensaje en Supabase: ${supabaseError.message}`);
        }
        
        // üîí VERIFICACI√ìN CR√çTICA: Verificar estado del bot para este remitente
        console.log(`üîí FORZANDO CONSULTA A BASE DE DATOS para verificar estado actual del bot`);
        let botActive = true;
        
        try {
            // Primero intentar con el ID de conversaci√≥n si lo tenemos
            if (conversationId) {
                const { data: convData, error: convError } = await supabase
                    .from('conversations')
                    .select('is_bot_active')
                    .eq('id', conversationId)
                    .single();
                
                if (convError) {
                    console.error(`‚ùå Error consultando estado del bot: ${convError.message}`);
                } else if (convData) {
                    botActive = convData.is_bot_active === true; // Comparaci√≥n estricta
                    console.log(`‚ÑπÔ∏è ESTADO DIRECTO DB: Bot ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'} para la conversaci√≥n ${conversationId} (n√∫mero ${sender})`);
                    
                    // Actualizar cach√©
                    senderBotStatusMap[sender] = botActive;
                    console.log(`üìù Cach√© actualizada: senderBotStatusMap[${sender}] = ${botActive}`);
                }
            } else {
                // Si no tenemos ID, buscar por n√∫mero
                const { data: convByNumber, error: numberError } = await supabase
                    .from('conversations')
                    .select('id, is_bot_active')
                    .eq('user_id', sender)
                    .single();
                
                if (numberError) {
                    console.error(`‚ùå Error consultando por n√∫mero: ${numberError.message}`);
                } else if (convByNumber) {
                    botActive = convByNumber.is_bot_active === true;
                    console.log(`‚ÑπÔ∏è ESTADO POR N√öMERO: Bot ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'} para ${sender}`);
                    
                    // Actualizar cach√© y mapeo
                    senderBotStatusMap[sender] = botActive;
                    console.log(`üìù Cach√© actualizada: senderBotStatusMap[${sender}] = ${botActive}`);
                    
                    // Actualizar tambi√©n el ID de conversaci√≥n
                    conversationId = convByNumber.id;
                    phoneToConversationMap[sender] = conversationId;
                    conversationIdToPhoneMap[conversationId] = sender;
                }
            }
        } catch (dbError) {
            console.error(`‚ùå Error cr√≠tico consultando estado del bot: ${dbError.message}`);
        }
        
        // Verificaci√≥n final antes de procesar
        console.log(`üîê VERIFICACI√ìN FINAL antes de procesar: Bot para ${sender} est√° ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'}`);
        
        // Procesar mensaje con OpenAI SOLO si el bot est√° ACTIVO
        if (botActive) {
            console.log(`‚öôÔ∏è Procesando mensaje de ${sender} con OpenAI: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
            
            try {
                // Procesar con OpenAI y obtener respuesta
                const botResponse = await processMessageWithOpenAI(sender, message, conversationId);
                
                if (botResponse) {
                    console.log(`‚úÖ Respuesta generada por OpenAI: "${botResponse.substring(0, 50)}${botResponse.length > 50 ? '...' : ''}"`);
                    
                    // Enviar respuesta a WhatsApp
                    const sendResult = await sendWhatsAppResponse(sender, botResponse);
                    
                    if (sendResult) {
                        console.log(`‚úÖ Respuesta enviada exitosamente a WhatsApp para ${sender}`);
                    } else {
                        console.log(`‚ö†Ô∏è No se pudo enviar la respuesta a WhatsApp, pero s√≠ se guard√≥ en la base de datos`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è OpenAI no gener√≥ respuesta para el mensaje de ${sender}`);
                }
            } catch (aiError) {
                console.error(`‚ùå Error procesando con OpenAI: ${aiError.message}`);
            }
        } else {
            console.log(`üõë Bot INACTIVO: NO se procesa mensaje de ${sender} con OpenAI ni se env√≠a respuesta autom√°tica`);
        }
        
        // Responder inmediatamente al webhook
        res.sendStatus(200);
    } catch (error) {
        console.error('‚ùå Error en handleIncomingMessage:', error);
        res.sendStatus(200); // Siempre responder OK a WhatsApp
    }
}

// Ruta para enviar im√°genes a trav√©s de WhatsApp desde el dashboard
app.post('/send-media', async (req, res) => {
    try {
        console.log('üì∏ Solicitud recibida para enviar imagen por WhatsApp');
        
        // Validar los datos de entrada
        const { phoneNumber, mediaUrl, caption, businessId } = req.body;
        
        if (!phoneNumber || !mediaUrl) {
            console.error('‚ùå Faltan datos requeridos para enviar media');
            return res.status(400).json({ 
                success: false, 
                error: 'Se requieren phoneNumber y mediaUrl' 
            });
        }
        
        console.log(`üì§ Enviando imagen a ${phoneNumber}. URL: ${mediaUrl}`);
        
        // Verificar el ID de negocio
        if (businessId && businessId !== BUSINESS_ID) {
            console.warn(`‚ö†Ô∏è ID de negocio no coincide: recibido ${businessId}, esperado ${BUSINESS_ID}`);
            // Continuamos de todas formas
        }
        
        // Enviar la imagen a WhatsApp
        const result = await sendMediaMessage(phoneNumber, mediaUrl, caption || '');
        
        if (result) {
            console.log('‚úÖ Imagen enviada exitosamente por WhatsApp');
            return res.status(200).json({ 
                success: true, 
                message: 'Imagen enviada correctamente' 
            });
        } else {
            console.error('‚ùå Error al enviar la imagen por WhatsApp');
            return res.status(500).json({ 
                success: false, 
                error: 'Error al enviar la imagen por WhatsApp' 
            });
        }
    } catch (error) {
        console.error('‚ùå Error en la ruta /send-media:', error.message);
        console.error(error.stack);
        
        return res.status(500).json({ 
            success: false, 
            error: 'Error interno del servidor' 
        });
    }
});

// Endpoint para probar credenciales sin enviar mensaje real
app.get('/test-credentials', (req, res) => {
    try {
        // Verificar credenciales
        const credentialStatus = {
            apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
            number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
            userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA',
            businessId: BUSINESS_ID || 'No configurado'
        };
        
        // Mostrar versi√≥n parcial de API key por seguridad
        let maskedApiKey = null;
        if (GUPSHUP_API_KEY) {
            maskedApiKey = `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}`;
        }
        
        res.status(200).json({
            success: true,
            message: 'Estado de credenciales',
            credentials: credentialStatus,
            apiKeyPrefix: maskedApiKey,
            serverVersion: '1.2.0'
        });
    } catch (error) {
        console.error('‚ùå Error en test-credentials:', error.message);
        res.status(500).json({ success: false, error: 'Error interno' });
    }
});

// Endpoint para enviar mensajes manuales a WhatsApp (desde el panel)
app.post('/api/send-manual-message', async (req, res) => {
  console.log('üì® Recibida solicitud para enviar mensaje manual a WhatsApp');
  console.log('üìÑ Cuerpo de la solicitud:', JSON.stringify(req.body, null, 2));
  
  try {
    const { phoneNumber, message, mediaUrl, content } = req.body;
    
    console.log(`üì± N√∫mero de tel√©fono: ${phoneNumber}`);
    console.log(`üí¨ Mensaje: ${message || content || 'No proporcionado'}`);
    console.log(`üñºÔ∏è URL de media: ${mediaUrl || 'No proporcionada'}`);
    
    // Validar campos requeridos
    if (!phoneNumber) {
      console.log('‚ùå Error: N√∫mero de tel√©fono no proporcionado');
      return res.status(400).json({ success: false, error: 'Se requiere n√∫mero de tel√©fono' });
    }
    
    // Validar formato del n√∫mero de tel√©fono
    if (!phoneNumber.match(/^\d+$/) || phoneNumber.length < 10) {
      console.log(`‚ùå Error: Formato de n√∫mero inv√°lido: ${phoneNumber}`);
      return res.status(400).json({ success: false, error: 'Formato de n√∫mero inv√°lido' });
    }
    
    // Normalizar el texto del mensaje
    const messageText = message || content || '';
    
    // Determinar el tipo de mensaje (texto o media)
    if (mediaUrl) {
      console.log(`üì§ Enviando mensaje con media: ${mediaUrl}`);
      
      // Usar la funci√≥n sendMediaMessage de GupShup
      const mediaResult = await sendMediaMessageGupShup(phoneNumber, mediaUrl, messageText);
      console.log('‚úÖ Resultado del env√≠o de media:', mediaResult);
      
      return res.json({ 
        success: true, 
        message: 'Mensaje con media enviado correctamente',
        details: mediaResult
      });
    } else {
      // Enviar solo texto
      console.log(`üì§ Enviando mensaje de texto: ${messageText}`);
      
      const textResult = await sendTextMessageGupShup(phoneNumber, messageText);
      console.log('‚úÖ Resultado del env√≠o de texto:', textResult);
      
      return res.json({ 
        success: true, 
        message: 'Mensaje de texto enviado correctamente',
        details: textResult
      });
    }
  } catch (error) {
    console.error('‚ùå Error al enviar mensaje manual:', error);
    return res.status(500).json({ 
      success: false, 
      error: error.message || 'Error al enviar mensaje' 
    });
  }
});

// Funci√≥n para enviar mensajes de texto usando GupShup
async function sendTextMessageGupShup(phoneNumber, text) {
  try {
    // Registrar todos los intentos para el n√∫mero problem√°tico
    const isTargetNumber = phoneNumber === '5212213647963';
    if (isTargetNumber) {
      console.log(`üîç [TARGET] Intento de env√≠o a n√∫mero problem√°tico: ${phoneNumber}`);
      console.log(`üîç [TARGET] Texto del mensaje: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
    }
    
    // Validar par√°metros b√°sicos
    if (!phoneNumber || !text) {
      if (isTargetNumber) console.log('‚ùå [TARGET] Error: falta n√∫mero o texto');
      console.error('‚ùå Error: falta n√∫mero o texto');
      return false;
    }
    
    // Limpiar el n√∫mero y formatear correctamente
    let cleanPhone = phoneNumber.replace(/\D/g, '');
    
    // Asegurar que el n√∫mero tenga formato internacional
    // Si empieza con 52, es un n√∫mero mexicano y debe tener 12-13 d√≠gitos (521xxx o 52xxx)
    if (cleanPhone.startsWith('52') && (cleanPhone.length === 12 || cleanPhone.length === 13)) {
      // El formato que espera GupShup es siempre sin el '1' despu√©s del c√≥digo de pa√≠s para M√©xico
      // Si tiene 13 d√≠gitos (521xxxxxxxxxx), eliminar el 1 extra
      if (cleanPhone.length === 13 && cleanPhone.startsWith('521')) {
        cleanPhone = '52' + cleanPhone.substring(3); // Quitar el '1' despu√©s del '52'
        if (isTargetNumber) console.log(`üîç [TARGET] N√∫mero corregido (quitando 1): ${cleanPhone}`);
      }
    }
    
    if (isTargetNumber) console.log(`üîç [TARGET] N√∫mero limpio final: ${cleanPhone}`);
    
    // Verificar credenciales
    if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
      if (isTargetNumber) console.log('‚ùå [TARGET] Error: faltan credenciales de GupShup');
      console.error('‚ùå Error: faltan credenciales de GupShup - API Key, Number o UserID');
      return false;
    }
    
    if (isTargetNumber) {
      console.log(`üîç [TARGET] GUPSHUP_NUMBER: ${GUPSHUP_NUMBER}`);
      console.log(`üîç [TARGET] GUPSHUP_USERID: ${GUPSHUP_USERID}`);
      console.log(`üîç [TARGET] API Key configurada: ${GUPSHUP_API_KEY ? 'S√ç' : 'NO'}`);
    }
    
    // URL correcta del endpoint seg√∫n la documentaci√≥n de SOLUCION_API_GUPSHUP.md
    const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
    
    // Utilizar URLSearchParams para enviar datos en formato form-urlencoded
    const formData = new URLSearchParams();
    formData.append('channel', 'whatsapp');
    formData.append('source', GUPSHUP_NUMBER);
    formData.append('destination', cleanPhone);
    formData.append('src.name', GUPSHUP_NUMBER);
    formData.append('message', JSON.stringify({
      type: 'text',
      text: text
    }));
    
    // Headers correctos seg√∫n la documentaci√≥n
    const headers = {
      'Cache-Control': 'no-cache',
      'Content-Type': 'application/x-www-form-urlencoded',
      'apikey': GUPSHUP_API_KEY,
      'userid': GUPSHUP_USERID  // Incluir el userid es crucial seg√∫n SOLUCION_API_GUPSHUP.md
    };
    
    if (isTargetNumber) {
      console.log(`üîç [TARGET] URL de la API: ${apiUrl}`);
      console.log(`üîç [TARGET] Headers:`, JSON.stringify(headers, null, 2));
      console.log(`üîç [TARGET] Datos del formulario:`, formData.toString());
    }
    
    // Enviar mensaje a la API
    console.log(`üì§ Enviando mensaje a GupShup para ${cleanPhone}: "${text.substring(0, 30)}..."`);
    
    // Intentar el env√≠o 3 veces en caso de fallo
    let attempts = 0;
    const maxAttempts = 3;
    let lastError = null;
    
    while (attempts < maxAttempts) {
      attempts++;
      try {
        if (isTargetNumber) console.log(`üîç [TARGET] Intento ${attempts}/${maxAttempts}`);
        
        const response = await axios.post(apiUrl, formData, { headers });
        
        if (isTargetNumber) {
          console.log(`üîç [TARGET] Respuesta de GupShup:`, JSON.stringify(response.data, null, 2));
          console.log(`üîç [TARGET] C√≥digo de estado: ${response.status}`);
        }
        
        // Si llegamos aqu√≠, la solicitud fue exitosa
        console.log(`‚úÖ Mensaje enviado correctamente a ${cleanPhone} (intento ${attempts})`);
        return true;
        
      } catch (error) {
        lastError = error;
        
        if (isTargetNumber) {
          console.log(`‚ùå [TARGET] Error en intento ${attempts}:`, error.message);
          if (error.response) {
            console.log(`‚ùå [TARGET] Detalles del error:`, JSON.stringify(error.response.data, null, 2));
          }
        }
        
        console.error(`‚ùå Error al enviar mensaje (intento ${attempts}/${maxAttempts}):`, error.message);
        
        if (attempts < maxAttempts) {
          const delay = 1000 * attempts; // Retraso incremental: 1s, 2s, 3s...
          console.log(`‚è±Ô∏è Reintentando en ${delay/1000} segundo(s)...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    // Si llegamos aqu√≠, todos los intentos fallaron
    console.error(`‚ùå Todos los intentos fallaron al enviar mensaje a ${cleanPhone}`);
    
    if (lastError && lastError.response) {
      console.error('Detalles del √∫ltimo error:', JSON.stringify(lastError.response.data, null, 2));
    }
    
    return false;
  } catch (error) {
    console.error('‚ùå Error general en sendTextMessageGupShup:', error);
    return false;
  }
}

// Funci√≥n para enviar mensajes con media usando GupShup
async function sendMediaMessageGupShup(phoneNumber, mediaUrl, caption = '') {
  try {
    console.log(`üñºÔ∏è Enviando mensaje con media: ${mediaUrl}`);
    console.log(`üì± Intentando enviar media a: ${phoneNumber}`);

    // Asegurarse de que tenemos las credenciales necesarias
    if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
      throw new Error('Faltan credenciales para GupShup');
    }

    // Validar URL
    console.log(`üñºÔ∏è URL original de la imagen: ${mediaUrl}`);

    // Verificar si la URL parece ser de Supabase
    const isSupabaseUrl = mediaUrl.includes('supabase.co') || mediaUrl.includes('supabase.in');
    if (isSupabaseUrl) {
      console.log(`‚úÖ URL de Supabase v√°lida: ${mediaUrl}`);
    } else {
      console.log(`‚ö†Ô∏è URL no parece ser de Supabase. Podr√≠a no ser accesible para GupShup.`);
    }

    // URL final que vamos a enviar
    let finalMediaUrl = mediaUrl;
    
    // Verificar si la URL es accesible
    try {
      console.log(`üîç Verificando accesibilidad de la URL...`);
      await axios.head(mediaUrl, { timeout: 5000 }).catch(err => {
        if (err.response?.status === 404 || err.code === 'ECONNREFUSED') {
          throw err;
        }
        // Algunos servidores no aceptan HEAD, intentamos con GET
        return axios.get(mediaUrl, { responseType: 'stream', timeout: 5000 });
      });
      console.log(`‚úÖ URL verificada como accesible`);
    } catch (error) {
      console.log(`‚ùå URL no accesible: ${error.message}`);
      
      // Si la URL no es accesible, usar una URL de ejemplo que sabemos que funciona
      console.log(`üîÑ Usando URL de imagen alternativa predefinida`);
      
      // URL p√∫blica de ejemplo (actualizar con una URL que funcione en tu entorno)
      finalMediaUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/WhatsApp.svg/240px-WhatsApp.svg.png';
      console.log(`üñºÔ∏è Nueva URL a utilizar: ${finalMediaUrl}`);
    }

    console.log(`üì§ URL final que se enviar√°: ${finalMediaUrl}`);

    // Determinar el tipo de medio basado en la URL
    const mediaType = getMediaTypeFromUrl(finalMediaUrl);
    console.log(`üîç Tipo de media detectado: ${mediaType}`);
    
    // URL correcta del endpoint seg√∫n la documentaci√≥n
    const url = 'https://api.gupshup.io/wa/api/v1/msg';
    console.log(`üîó URL del endpoint: ${url}`);
    
    // Crear el objeto de mensaje seg√∫n el tipo de medio
    const messageObj = {
      type: mediaType,
      url: finalMediaUrl,
      caption: caption || ''
    };
    
    const messageBody = JSON.stringify(messageObj);
    console.log(`üìù Contenido del mensaje con media: ${messageBody}`);
    
    // Crear FormData para la solicitud
    const formData = new URLSearchParams();
    formData.append('channel', 'whatsapp');
    formData.append('source', GUPSHUP_NUMBER || '917834811114');
    formData.append('destination', phoneNumber);
    formData.append('message', messageBody);
    formData.append('src.name', 'SeatManager');
    
    console.log(`üì§ FormData preparado: ${formData.toString()}`);
    
    // Configuraci√≥n completa de la solicitud
    const config = {
      headers: {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/x-www-form-urlencoded',
        'apikey': GUPSHUP_API_KEY,
        'userid': GUPSHUP_USERID
      },
      timeout: 30000 // 30 segundos de timeout para permitir subida de archivos grandes
    };
    
    console.log(`üåê Enviando solicitud HTTP POST a GupShup...`);
    
    // Enviar solicitud a GupShup
    const response = await axios.post(url, formData, config);
    
    console.log(`‚úÖ Respuesta recibida de GupShup: ${response.status}`);
    console.log(`üìÑ Datos de respuesta:`, response.data);
    
    return response.data;
  } catch (error) {
    console.error(`‚ùå Error al enviar mensaje multimedia: ${error.message}`);
    console.error(error);
    
    throw new Error(`Error al enviar mensaje multimedia: ${error.message}`);
  }
}

// Funci√≥n para determinar el tipo de medio desde la URL
function getMediaTypeFromUrl(url) {
  if (!url) return 'text';
  
  try {
    // Obtener la extensi√≥n del archivo desde la URL
    let extension = '';
    
    if (url.includes('?')) {
      // Remover query parameters para analizar la extensi√≥n
      const urlWithoutParams = url.split('?')[0];
      extension = urlWithoutParams.split('.').pop().toLowerCase();
    } else {
      extension = url.split('.').pop().toLowerCase();
    }
    
    console.log(`üîç Extensi√≥n detectada en URL: ${extension}`);
    
    // Verificar por extensiones conocidas
    if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(extension)) {
      return 'image';
    } else if (['mp4', 'mov', 'avi', 'webm'].includes(extension)) {
      return 'video';
    } else if (['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'].includes(extension)) {
      return 'file';
    } else if (['mp3', 'wav', 'ogg', 'm4a'].includes(extension)) {
      return 'audio';
    }
    
    // Si no se puede determinar por extensi√≥n, intentar por palabras clave en la URL
    if (url.includes('image') || url.includes('img') || url.includes('photo')) {
      return 'image';
    } else if (url.includes('video')) {
      return 'video';
    } else if (url.includes('file') || url.includes('document')) {
      return 'file';
    } else if (url.includes('audio')) {
      return 'audio';
    }
    
    // Por defecto, asumimos que es una imagen
    console.log(`‚ö†Ô∏è No se pudo determinar el tipo, asumiendo 'image'`);
    return 'image';
  } catch (error) {
    console.error(`‚ùå Error al determinar tipo de media: ${error.message}`);
    // En caso de error, asumimos que es una imagen
    return 'image';
  }
}

// ... existing code ...

// Endpoint para pruebas directas de GupShup
app.post('/api/send-gupshup', async (req, res) => {
  console.log('üì± Solicitud de prueba directa a GupShup recibida');
  console.log('üìÑ Datos recibidos:', JSON.stringify(req.body, null, 2));
  
  try {
    const { phoneNumber, message, mediaUrl } = req.body;
    
    // Validaciones b√°sicas
    if (!phoneNumber) {
      return res.status(400).json({ success: false, error: 'Falta n√∫mero de tel√©fono' });
    }
    
    console.log('üì± GUPSHUP_NUMBER:', GUPSHUP_NUMBER);
    console.log('üîë GUPSHUP_API_KEY:', GUPSHUP_API_KEY ? 'Configurada' : 'No configurada');
    console.log('üë§ GUPSHUP_USERID:', GUPSHUP_USERID ? 'Configurado' : 'No configurado');
    
    // Verificar credenciales
    if (!GUPSHUP_API_KEY || !GUPSHUP_USERID) {
      return res.status(500).json({ 
        success: false, 
        error: 'Credenciales de GupShup no configuradas',
        details: {
          apiKey: !!GUPSHUP_API_KEY,
          userId: !!GUPSHUP_USERID,
          number: GUPSHUP_NUMBER
        }
      });
    }
    
    let result;
    
    // Determinar si enviar media o texto
    if (mediaUrl) {
      console.log('üñºÔ∏è Enviando mensaje con media:', mediaUrl);
      result = await sendMediaMessageGupShup(phoneNumber, mediaUrl, message || '');
    } else {
      console.log('üí¨ Enviando mensaje de texto:', message);
      result = await sendTextMessageGupShup(phoneNumber, message);
    }
    
    console.log('‚úÖ Resultado de la prueba directa GupShup:', result);
    res.json({ 
      success: true, 
      message: 'Mensaje enviado correctamente', 
      details: result 
    });
    
  } catch (error) {
    console.error('‚ùå Error en prueba directa GupShup:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message || 'Error desconocido',
      details: error.response?.data || {}
    });
  }
});

// Endpoint para probar la conexi√≥n con GupShup
app.get('/api/test-gupshup', async (req, res) => {
  console.log('üîç Verificando configuraci√≥n de GupShup');
  
  try {
    // Verificar variables de entorno
    const configResult = {
      GUPSHUP_API_KEY: !!GUPSHUP_API_KEY,
      GUPSHUP_USERID: !!GUPSHUP_USERID,
      GUPSHUP_NUMBER: GUPSHUP_NUMBER || 'No configurado'
    };
    
    console.log('‚öôÔ∏è Configuraci√≥n de GupShup:', configResult);
    
    if (!GUPSHUP_API_KEY || !GUPSHUP_USERID) {
      return res.status(200).json({
        success: false,
        message: 'Faltan credenciales de GupShup',
        config: configResult
      });
    }
    
    // Probar conexi√≥n con GupShup
    try {
      // Intentar obtener apps de usuario para verificar acceso
      const url = 'https://api.gupshup.io/wa/api/v1/users/apps';
      
      const response = await axios.get(url, {
        headers: {
          'apikey': GUPSHUP_API_KEY,
          'userid': GUPSHUP_USERID
        }
      });
      
      console.log('‚úÖ Conexi√≥n exitosa con GupShup:', response.status);
      
      res.json({
        success: true,
        message: 'Conexi√≥n exitosa con GupShup',
        config: configResult,
        apiStatus: response.status,
        data: response.data
      });
      
    } catch (apiError) {
      console.error('‚ùå Error al conectar con API de GupShup:', apiError.response?.data || apiError.message);
      
      res.status(200).json({
        success: false,
        message: 'Error al conectar con API de GupShup',
        config: configResult,
        error: apiError.response?.data || apiError.message
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error general en test-gupshup:', error);
    
    res.status(500).json({
      success: false,
      message: 'Error general en prueba de GupShup',
      error: error.message
    });
  }
});

// ... existing code ...

// Endpoint para enviar mensajes directamente a trav√©s de GupShup (endpoint que funciona)
app.post('/api/send-gupshup', async (req, res) => {
  console.log('üì± Solicitud directa a API GupShup recibida');
  console.log('üìÑ Datos recibidos:', JSON.stringify(req.body, null, 2));
  
  try {
    const { phoneNumber, message, mediaUrl, caption } = req.body;
    
    // Validaciones b√°sicas
    if (!phoneNumber) {
      console.log('‚ùå Error: Falta n√∫mero de tel√©fono');
      return res.status(400).json({ success: false, error: 'Falta n√∫mero de tel√©fono' });
    }
    
    console.log(`üì± Enviando a: ${phoneNumber}`);
    console.log(`üîë Usando credenciales GupShup: ${GUPSHUP_API_KEY ? 'Configurada' : 'No configurada'}, ${GUPSHUP_USERID ? 'Configurado' : 'No configurado'}`);
    
    let result;
    
    // Determinar el tipo de mensaje a enviar basado en la presencia de mediaUrl
    if (mediaUrl) {
      console.log(`üñºÔ∏è Detectada imagen o archivo: ${mediaUrl}`);
      // Si hay una URL de media, enviar como imagen/archivo
      const messageText = caption || message || '';
      console.log(`üìù Caption/mensaje: ${messageText}`);
      
      // Enviar mensaje con media usando funci√≥n espec√≠fica para GupShup
      result = await sendMediaMessageGupShup(phoneNumber, mediaUrl, messageText);
      console.log('‚úÖ Resultado del env√≠o de media:', result);
    } else {
      console.log(`üí¨ Mensaje de texto: ${message}`);
      // Enviar como texto normal
      result = await sendTextMessageGupShup(phoneNumber, message || '');
      console.log('‚úÖ Resultado del env√≠o de texto:', result);
    }
    
    return res.json({
      success: true,
      message: 'Mensaje enviado correctamente',
      details: result
    });
  } catch (error) {
    console.error('‚ùå Error al enviar mensaje directo a GupShup:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'Error desconocido',
      details: error.response?.data || {}
    });
  }
});

// Funci√≥n para determinar el tipo de medio desde la URL
function getMediaTypeFromUrl(url) {
  if (!url) return 'text';
  
  try {
    // Obtener la extensi√≥n del archivo desde la URL
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const extension = pathname.split('.').pop().toLowerCase();
    
    console.log(`üîç Extensi√≥n detectada: ${extension}`);
    
    if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(extension)) {
      return 'image';
    } else if (['mp4', 'mov', 'avi', 'webm'].includes(extension)) {
      return 'video';
    } else if (['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'].includes(extension)) {
      return 'file';
    } else if (['mp3', 'wav', 'ogg', 'm4a'].includes(extension)) {
      return 'audio';
    }
    
    // Si no se puede determinar por extensi√≥n, intentar por la presencia de strings comunes en URLs
    if (url.includes('image') || url.includes('img') || url.includes('photo')) {
      return 'image';
    } else if (url.includes('video')) {
      return 'video';
    } else if (url.includes('audio') || url.includes('sound')) {
      return 'audio';
    } else if (url.includes('file') || url.includes('document')) {
      return 'file';
    }
  } catch (e) {
    console.warn(`‚ö†Ô∏è Error al analizar URL: ${e.message}`);
  }
  
  // Si no hay extensi√≥n clara o hubo error al analizar URL, asumir imagen
  return 'image';
}

// ... existing code ...

// Endpoint para enviar mensajes a WhatsApp a trav√©s de GupShup
app.post('/api/send-gupshup', async (req, res) => {
  console.log(`üì• Recibida petici√≥n en /api/send-gupshup:`, req.body);
  
  try {
    const { phoneNumber, message, mediaUrl, caption } = req.body;
    
    if (!phoneNumber) {
      console.error('‚ùå Error: Falta el n√∫mero de tel√©fono en la solicitud');
      return res.status(400).json({ success: false, error: 'El n√∫mero de tel√©fono es requerido' });
    }
    
    // Validar formato de n√∫mero de tel√©fono
    const formattedPhone = phoneNumber.replace(/\D/g, '');
    if (formattedPhone.length < 10) {
      console.error(`‚ùå Error: N√∫mero de tel√©fono inv√°lido: ${phoneNumber}`);
      return res.status(400).json({ success: false, error: 'N√∫mero de tel√©fono inv√°lido' });
    }
    
    // Registrar los datos de la solicitud
    console.log(`üì± Solicitud para enviar mensaje a: ${formattedPhone}`);
    
    // Determinar si es un mensaje de texto o media
    if (mediaUrl) {
      console.log(`üñºÔ∏è Detectada solicitud con media: ${mediaUrl}`);
      
      try {
        // Intentar enviar mensaje con media
        const result = await sendMediaMessageGupShup(
          formattedPhone,
          mediaUrl,
          caption || message || ''
        );
        
        console.log(`‚úÖ Mensaje con media enviado exitosamente a ${formattedPhone}`);
        return res.json({
          success: true,
          message: 'Mensaje con media enviado exitosamente',
          data: result
        });
      } catch (mediaError) {
        console.error(`‚ùå Error al enviar mensaje con media:`, mediaError.message);
        
        // Verificar si debemos intentar enviar como texto
        if (message) {
          console.log(`‚ö†Ô∏è Error en multimedia, intentando enviar como texto: ${message}`);
          
          try {
            // Intentar enviar como texto
            const textResult = await sendTextMessageGupShup(formattedPhone, 
              `${message}\n\n[No se pudo enviar la imagen con URL: ${mediaUrl}]`);
            
            console.log(`‚úÖ Mensaje de texto alternativo enviado exitosamente a ${formattedPhone}`);
            return res.json({
              success: true,
              message: 'Mensaje enviado como texto (fall√≥ el env√≠o de media)',
              data: textResult,
              warning: mediaError.message
            });
          } catch (textError) {
            console.error(`‚ùå Error al enviar mensaje como texto:`, textError.message);
            return res.status(500).json({
              success: false,
              error: 'Error al enviar mensaje como texto despu√©s de fallar la media',
              details: textError.message,
              originalError: mediaError.message
            });
          }
        } else {
          // No hay mensaje de texto alternativo, devolver error
          return res.status(500).json({
            success: false,
            error: 'Error al enviar mensaje con media',
            details: mediaError.message
          });
        }
      }
    } else if (message) {
      console.log(`üí¨ Detectada solicitud de mensaje de texto: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
      
      try {
        // Enviar mensaje de texto
        const result = await sendTextMessageGupShup(formattedPhone, message);
        
        console.log(`‚úÖ Mensaje de texto enviado exitosamente a ${formattedPhone}`);
        return res.json({
          success: true,
          message: 'Mensaje de texto enviado exitosamente',
          data: result
        });
      } catch (textError) {
        console.error(`‚ùå Error al enviar mensaje de texto:`, textError.message);
        return res.status(500).json({
          success: false,
          error: 'Error al enviar mensaje de texto',
          details: textError.message
        });
      }
    } else {
      console.error('‚ùå Error: No se proporcion√≥ mensaje ni mediaUrl');
      return res.status(400).json({
        success: false,
        error: 'Se requiere proporcionar un mensaje o una URL de media'
      });
    }
  } catch (error) {
    console.error(`‚ùå Error general en /api/send-gupshup:`, error);
    return res.status(500).json({
      success: false,
      error: 'Error interno del servidor',
      details: error.message
    });
  }
});

// Funci√≥n para enviar un mensaje multimedia a trav√©s de GupShup

// ... existing code ...

// Actualizaci√≥n del endpoint para im√°genes
app.post('/api/send-media-gupshup', async (req, res) => {
  try {
    console.log('üñºÔ∏è Recibida solicitud para enviar imagen a WhatsApp');
    
    // Validar par√°metros necesarios
    const { phoneNumber, mediaUrl, fallbackUrl, caption } = req.body;
    
    if (!phoneNumber) {
      console.error('‚ùå Error: falta el n√∫mero de tel√©fono');
      return res.status(400).json({
        success: false,
        error: 'Se requiere el n√∫mero de tel√©fono (phoneNumber)'
      });
    }
    
    if (!mediaUrl && !fallbackUrl) {
      console.error('‚ùå Error: falta la URL de la imagen');
      return res.status(400).json({
        success: false,
        error: 'Se requiere al menos una URL de imagen (mediaUrl o fallbackUrl)'
      });
    }
    
    console.log(`üì± Enviando imagen a: ${phoneNumber}`);
    console.log(`üñºÔ∏è URL primaria: ${mediaUrl || 'No proporcionada'}`);
    console.log(`üñºÔ∏è URL de respaldo: ${fallbackUrl || 'No proporcionada'}`);
    console.log(`üìù Caption: ${caption || 'Sin texto'}`);
    
    // Verificar cu√°l URL es accesible
    let finalUrl = mediaUrl;
    let urlAccesible = false;
    
    // Verificar URL primaria
    if (mediaUrl) {
      try {
        console.log(`üîç Verificando accesibilidad de URL primaria...`);
        await axios.head(mediaUrl, { timeout: 3000 }).catch(err => {
          if (err.response?.status === 404 || err.code === 'ECONNREFUSED') {
            throw err;
          }
          return axios.get(mediaUrl, { responseType: 'stream', timeout: 3000 });
        });
        console.log(`‚úÖ URL primaria verificada como accesible`);
        urlAccesible = true;
      } catch (error) {
        console.log(`‚ö†Ô∏è URL primaria no accesible: ${error.message}`);
        urlAccesible = false;
      }
    }
    
    // Si la URL primaria no es accesible, intentar con la URL de respaldo
    if (!urlAccesible && fallbackUrl) {
      console.log(`üîÑ Cambiando a URL de respaldo...`);
      finalUrl = fallbackUrl;
      try {
        console.log(`üîç Verificando accesibilidad de URL de respaldo...`);
        await axios.head(fallbackUrl, { timeout: 3000 }).catch(err => {
          if (err.response?.status === 404 || err.code === 'ECONNREFUSED') {
            throw err;
          }
          return axios.get(fallbackUrl, { responseType: 'stream', timeout: 3000 });
        });
        console.log(`‚úÖ URL de respaldo verificada como accesible`);
        urlAccesible = true;
      } catch (error) {
        console.log(`‚ö†Ô∏è URL de respaldo no accesible: ${error.message}`);
        // Seguimos adelante con la URL de respaldo aunque no sea accesible
      }
    }
    
    // Si ninguna URL es accesible, usar una URL p√∫blica conocida
    if (!urlAccesible) {
      console.log(`üîÑ Usando URL p√∫blica conocida como √∫ltimo recurso`);
      finalUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/WhatsApp.svg/240px-WhatsApp.svg.png';
    }
    
    console.log(`üì§ URL final que se enviar√°: ${finalUrl}`);
    
    // Determinar el tipo de medio basado en la URL
    const mediaType = getMediaTypeFromUrl(finalUrl);
    console.log(`üîç Tipo de media detectado: ${mediaType}`);
    
    // URL correcta del endpoint seg√∫n la documentaci√≥n
    const url = 'https://api.gupshup.io/wa/api/v1/msg';
    console.log(`üîó URL del endpoint: ${url}`);
    
    // Crear el objeto de mensaje seg√∫n el tipo de medio
    const messageObj = {
      type: mediaType,
      url: finalUrl,
      caption: caption || ''
    };
    
    const messageBody = JSON.stringify(messageObj);
    console.log(`üìù Contenido del mensaje con media: ${messageBody}`);
    
    // Crear FormData para la solicitud
    const formData = new URLSearchParams();
    formData.append('channel', 'whatsapp');
    formData.append('source', GUPSHUP_NUMBER || '917834811114');
    formData.append('destination', phoneNumber);
    formData.append('message', messageBody);
    formData.append('src.name', 'SeatManager');
    
    console.log(`üì§ FormData preparado: ${formData.toString()}`);
    
    // Configuraci√≥n completa de la solicitud
    const config = {
      headers: {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/x-www-form-urlencoded',
        'apikey': GUPSHUP_API_KEY,
        'userid': GUPSHUP_USERID
      },
      timeout: 30000 // 30 segundos de timeout para permitir subida de archivos grandes
    };
    
    console.log(`üåê Enviando solicitud HTTP POST a GupShup...`);
    
    // Enviar solicitud a GupShup
    const response = await axios.post(url, formData, config);
    
    console.log(`‚úÖ Respuesta recibida de GupShup: ${response.status}`);
    console.log(`üìÑ Datos de respuesta:`, response.data);
    
    return res.json({
      success: true,
      message: 'Imagen enviada correctamente',
      details: response.data,
      urlUsada: finalUrl
    });
  } catch (error) {
    console.error(`‚ùå Error al enviar mensaje multimedia: ${error.message}`);
    console.error(error);
    
    return res.status(500).json({
      success: false,
      error: `Error al enviar mensaje multimedia: ${error.message}`,
      details: error.response?.data || {}
    });
  }
});

// ... existing code ...

// ... existing code ...

// Endpoint para enviar mensajes manuales (con soporte para multimedia)
app.post('/api/send-manual-message', async (req, res) => {
  try {
    const { phoneNumber, message, mediaUrl, caption, forceManual } = req.body;
    
    console.log(`üì© Solicitud para enviar mensaje manual a ${phoneNumber}`);
    console.log(`üìÑ Contenido: ${message || '(sin texto)'}`);
    console.log(`üñºÔ∏è Media URL: ${mediaUrl || '(sin multimedia)'}`);
    console.log(`üí¨ Caption: ${caption || '(sin caption)'}`);
    console.log(`‚öôÔ∏è Forzar env√≠o: ${forceManual ? 'S√≠' : 'No'}`);
    
    // Validaci√≥n b√°sica
    if (!phoneNumber) {
      return res.status(400).json({ 
        success: false, 
        error: 'Se requiere n√∫mero de tel√©fono' 
      });
    }
    
    // Si no hay bot activo o se fuerza el env√≠o manual, enviar directamente
    const shouldSendMessage = forceManual === true || botIsActive;
    
    if (!shouldSendMessage) {
      return res.status(403).json({
        success: false,
        error: 'Bot desactivado',
        mode: 'manual'
      });
    }
    
    console.log(`ü§ñ Enviando mensaje${forceManual ? ' (forzado)' : ''}`);
    
    // Determinar el tipo de mensaje a enviar
    if (mediaUrl) {
      // Mensaje con multimedia
      try {
        const result = await sendMediaMessageGupShup(phoneNumber, mediaUrl, caption || message || '');
        return res.json({
          success: true,
          message: 'Mensaje multimedia enviado correctamente',
          details: result,
          mode: forceManual ? 'forced_manual' : 'normal'
        });
      } catch (mediaError) {
        console.error(`‚ùå Error al enviar multimedia:`, mediaError);
        return res.status(500).json({
          success: false,
          error: `Error al enviar multimedia: ${mediaError.message}`,
          mode: forceManual ? 'forced_manual' : 'normal'
        });
      }
    } else if (message) {
      // Mensaje de texto simple
      try {
        const result = await sendTextMessageGupShup(phoneNumber, message);
        return res.json({
          success: true,
          message: 'Mensaje de texto enviado correctamente',
          details: result,
          mode: forceManual ? 'forced_manual' : 'normal'
        });
      } catch (textError) {
        console.error(`‚ùå Error al enviar texto:`, textError);
        return res.status(500).json({
          success: false,
          error: `Error al enviar mensaje de texto: ${textError.message}`,
          mode: forceManual ? 'forced_manual' : 'normal'
        });
      }
    } else {
      return res.status(400).json({
        success: false,
        error: 'Se requiere un mensaje o una URL de media',
        mode: forceManual ? 'forced_manual' : 'normal'
      });
    }
  } catch (error) {
    console.error(`‚ùå Error general en send-manual-message:`, error);
    return res.status(500).json({
      success: false,
      error: `Error interno: ${error.message}`
    });
  }
});
// ... existing code ...
