// Importar librerÃ­as
require('dotenv').config();
const express = require('express');
const { createClient } = require('@supabase/supabase-js');
const cors = require('cors');
const OpenAI = require('openai');
const fs = require('fs');
const multer = require('multer');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const bodyParser = require('body-parser');
const session = require('express-session');
const nodemailer = require('nodemailer');
const MessageMedia = require('whatsapp-web.js').MessageMedia;
const { sendTextMessageGupShup } = require('./sendTextMessageGupShup');
const crypto = require('crypto');

// Cargar variables de entorno en variables globales para facilitar su uso en toda la aplicaciÃ³n
let GUPSHUP_API_KEY = process.env.GUPSHUP_API_KEY;
let GUPSHUP_NUMBER = process.env.GUPSHUP_NUMBER;
let GUPSHUP_USERID = process.env.GUPSHUP_USERID;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_KEY = process.env.SUPABASE_KEY;
const BUSINESS_ID = process.env.BUSINESS_ID;
let CONTROL_PANEL_URL = process.env.CONTROL_PANEL_URL || 'http://localhost:7777/api/register-bot-response';
const ASSISTANT_ID = process.env.ASSISTANT_ID;
const PORT = process.env.PORT || 3095;
const VERIFY_TOKEN = process.env.VERIFY_TOKEN || 'verify_token_whatsapp_webhook';
const WHATSAPP_API_TOKEN = process.env.WHATSAPP_API_TOKEN || '';

// InicializaciÃ³n temprana para verificar variables crÃ­ticas
console.log('ğŸ”‘ Inicializando servidor de WhatsApp con las siguientes credenciales:');
console.log(`ğŸ“± GUPSHUP_NUMBER: ${GUPSHUP_NUMBER ? GUPSHUP_NUMBER : 'NO CONFIGURADO âŒ'}`);
console.log(`ğŸ”‘ GUPSHUP_API_KEY: ${GUPSHUP_API_KEY ? `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}` : 'NO CONFIGURADO âŒ'}`);
console.log(`ğŸ‘¤ GUPSHUP_USERID: ${GUPSHUP_USERID ? `${GUPSHUP_USERID.substring(0, 8)}...` : 'NO CONFIGURADO âŒ'}`);
console.log(`ğŸ”— SUPABASE_URL: ${SUPABASE_URL ? SUPABASE_URL : 'NO CONFIGURADO âŒ'}`);
console.log(`ğŸ–¥ï¸ CONTROL_PANEL_URL: ${CONTROL_PANEL_URL}`);

// SOLUCIÃ“N DEFINITIVA: Forzar URL en Render
// Detectar ambiente Render
const RENDER_ENV = process.env.RENDER === 'true' || process.env.RENDER_EXTERNAL_URL !== undefined;
const PROD_ENV = process.env.NODE_ENV === 'production';

// En Render, siempre usar la URL correcta (antes de cualquier otro cÃ³digo)
if (RENDER_ENV || PROD_ENV) {
  const correctUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
  process.env.CONTROL_PANEL_URL = correctUrl;
  CONTROL_PANEL_URL = correctUrl;
  console.log(`ğŸ› ï¸ CONFIGURACIÃ“N TEMPRANA: URL forzada a ${correctUrl}`);
  
  // Guardar tambiÃ©n variables para Supabase para asegurar que estÃ©n disponibles
  if (!process.env.SUPABASE_KEY && process.env.SUPABASE_ANON_KEY) {
    process.env.SUPABASE_KEY = process.env.SUPABASE_ANON_KEY;
    console.log('ğŸ”‘ CONFIGURACIÃ“N TEMPRANA: Copiando SUPABASE_ANON_KEY a SUPABASE_KEY');
  }
}

// Cargar el parche global que define registerBotResponse
require('./global-patch');

// Inicializar OpenAI
const openai = new OpenAI({
    apiKey: OPENAI_API_KEY,
});

// Verificar el formato de la API Key
if (OPENAI_API_KEY && !OPENAI_API_KEY.startsWith('sk-')) {
    console.warn('âš ï¸ ADVERTENCIA: El formato de la API Key de OpenAI parece incorrecto. DeberÃ­a comenzar con "sk-"');
    console.warn('âš ï¸ Por favor, verifica tu API Key en https://platform.openai.com/account/api-keys');
}

const SYSTEM_PROMPT = `Eres un asistente de ventas amigable y profesional para concesionarios SEAT y CUPRA. Tu objetivo es ayudar a los clientes a encontrar el vehÃ­culo que mejor se adapte a sus necesidades, responder preguntas sobre modelos especÃ­ficos, caracterÃ­sticas, financiamiento y promociones.

Reglas importantes:
1. SÃ© respetuoso y profesional en todo momento.
2. Proporciona informaciÃ³n precisa sobre vehÃ­culos SEAT y CUPRA.
3. Si no conoces la respuesta, sugiÃ©rele al cliente que visite el concesionario o hable con un asesor humano.
4. No inventes informaciÃ³n sobre precios exactos, promociones o disponibilidad.
5. MantÃ©n tus respuestas concisas y directas.
6. No uses emojis.
7. Cuando sugieras un modelo, menciona brevemente sus caracterÃ­sticas principales.`;

// Mapeo bidireccional para mantener relaciÃ³n entre nÃºmeros telefÃ³nicos e IDs de conversaciÃ³n
const phoneToConversationMap = {};
// Mapeo de IDs de conversaciÃ³n a nÃºmeros telefÃ³nicos
const conversationIdToPhoneMap = {};

// CachÃ© del estado del bot por remitente
const senderBotStatusMap = {};

// Cache para evitar procesar mensajes duplicados (por ID + contenido)
const processedMessages = {};

// Set para almacenar mensajes procesados recientemente (evitar duplicados)
const recentlyProcessedMessages = new Set();

// Set para almacenar hashes de mensajes recientes para evitar duplicaciÃ³n en registerBotResponse
const recentMessageHashes = new Set();

// ğŸ—‚ Almacena el historial de threads de usuarios
const userThreads = {};

// FunciÃ³n para actualizar/mantener los mapeos entre conversaciones y nÃºmeros telefÃ³nicos
// Debe llamarse cada vez que se crea o accede a una conversaciÃ³n
async function updateConversationMappings() {
  console.log('ğŸ”„ Actualizando mapeos de conversaciones y nÃºmeros...');
  
  try {
    // Obtener todas las conversaciones activas para el negocio
    const { data, error } = await supabase
      .from('conversations')
      .select('id, user_id')
      .eq('business_id', BUSINESS_ID);
    
    if (error) {
      console.error('âŒ Error al cargar mapeos:', error.message);
      return;
    }
    
    if (!data || data.length === 0) {
      console.log('â„¹ï¸ No hay conversaciones para mapear');
      return;
    }
    
    console.log(`ğŸ” Encontradas ${data.length} conversaciones para mapeo`);
    
    // Actualizar mapeos en memoria
    data.forEach(conv => {
      if (conv.id && conv.user_id) {
        // Solo actualizar si ambos valores existen
        phoneToConversationMap[conv.user_id] = conv.id;
        conversationIdToPhoneMap[conv.id] = conv.user_id;
      }
    });
    
    console.log(`âœ… Mapeos actualizados: ${Object.keys(phoneToConversationMap).length} nÃºmeros mapeados`);
  } catch (e) {
    console.error('âŒ Error crÃ­tico en actualizaciÃ³n de mapeos:', e.message);
  }
}

// ğŸ”§ Parche de URL: Corregir CONTROL_PANEL_URL si es necesario
console.log("ğŸ”§ APLICANDO PARCHE PARA CORREGIR URLs DEL BOT WHATSAPP");

// Usar constantes definidas al inicio
console.log("Ambiente:", PROD_ENV ? "ProducciÃ³n" : "Desarrollo");
console.log("Render detectado:", RENDER_ENV ? "SÃ" : "NO");

// En Render, siempre usar la URL correcta
if (RENDER_ENV && PROD_ENV) {
  const renderUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
  console.log(`ğŸ—ï¸ Ambiente Render detectado, forzando URL correcta: ${renderUrl}`);
  process.env.CONTROL_PANEL_URL = renderUrl;
  CONTROL_PANEL_URL = renderUrl;
  console.log(`âœ… URL configurada para Render: ${CONTROL_PANEL_URL}`);
} else {
  // Procesar la URL para otros entornos
  let originalUrl = process.env.CONTROL_PANEL_URL || (PROD_ENV ? 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response' : 'http://localhost:3000');
console.log("CONTROL_PANEL_URL actual:", originalUrl);

  // Si estamos en producciÃ³n y la URL contiene localhost, corregirla
  if (PROD_ENV && originalUrl.includes('localhost')) {
    console.log("âš ï¸ Detectada URL de localhost en ambiente de producciÃ³n. Corrigiendo...");
    originalUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
    console.log("âœ… URL corregida para producciÃ³n:", originalUrl);
  }

// Corregir URL duplicada
if (originalUrl.includes('/register-bot-response/register-bot-response')) {
    originalUrl = originalUrl.replace('/register-bot-response/register-bot-response', '/register-bot-response');
}

// Verificar dominios antiguos y corregirlos
  if (PROD_ENV && originalUrl.includes('panel-control-whatsapp.onrender.com')) {
    originalUrl = originalUrl.replace('panel-control-whatsapp.onrender.com', 'whatsapp-bot-if6z.onrender.com');
}

// Si la URL contiene el dominio antiguo, actualizarlo
if (originalUrl.includes('render-wa.onrender.com')) {
    originalUrl = originalUrl.replace('render-wa.onrender.com', 'whatsapp-bot-if6z.onrender.com');
    console.log("URL actualizada a dominio correcto:", originalUrl);
}

// Corregir estructura
if (originalUrl.endsWith('/register-bot-response')) {
    // URL ya tiene el endpoint, no necesita cambios
    process.env.CONTROL_PANEL_URL = originalUrl.trim();
    CONTROL_PANEL_URL = originalUrl.trim();
} else if (originalUrl.includes('/register-bot-response/')) {
    // URL tiene endpoint duplicado
    process.env.CONTROL_PANEL_URL = originalUrl.split('/register-bot-response/')[0] + '/register-bot-response';
    CONTROL_PANEL_URL = process.env.CONTROL_PANEL_URL;
} else {
    // URL no tiene endpoint, agregar si no termina en /
    const formattedUrl = originalUrl.endsWith('/') 
        ? originalUrl.slice(0, -1) + '/register-bot-response'
        : originalUrl + '/register-bot-response';
    process.env.CONTROL_PANEL_URL = formattedUrl;
    CONTROL_PANEL_URL = formattedUrl;
  }
}

console.log("URL final que se usarÃ¡:", CONTROL_PANEL_URL);
console.log("âœ… Parche aplicado correctamente");
console.log("ğŸ“ De ahora en adelante, las URLs duplicadas serÃ¡n corregidas automÃ¡ticamente");
console.log("ğŸŒ En ambiente de producciÃ³n, se usarÃ¡:", PROD_ENV ? CONTROL_PANEL_URL : "URL de desarrollo");
console.log("ğŸ” TambiÃ©n puedes usar la funciÃ³n global registerBotResponse() para enviar mensajes");

const LOG_LEVEL = process.env.LOG_LEVEL || 'info';

// ConfiguraciÃ³n express
const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Configurar CORS
const corsOptions = {
  origin: ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002', 'https://whatsapp-mern-front.vercel.app'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  preflightContinue: false,
  optionsSuccessStatus: 204,
  exposedHeaders: ['Access-Control-Allow-Origin', 'Access-Control-Allow-Credentials']
};
app.use(cors(corsOptions));

// Variable global para activar modo debug
const DEBUG_MODE = process.env.DEBUG_MODE === 'true' || process.env.NODE_ENV === 'development';

// Middleware para registro de solicitudes CORS
app.use((req, res, next) => {
  if (DEBUG_MODE) {
    console.log(`ğŸ”„ ${req.method} ${req.url} - Origin: ${req.headers.origin || 'Unknown'}`);
  }
  // Establecer headers CORS adicionales para todas las respuestas
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
});

// Middleware para opciones preflight
app.options('*', cors(corsOptions));

// Middleware para logs detallados
app.use((req, res, next) => {
  console.log(`ğŸ“¥ ${req.method} ${req.url}`);
  next();
});

// ğŸ”ƒ Control de mensajes procesados para evitar duplicados
const MESSAGE_EXPIRE_TIME = 60000; // 60 segundos para expirar mensajes procesados

// FunciÃ³n para verificar si un mensaje ya fue procesado
function isMessageProcessed(messageId, sender, text) {
  // Si tenemos un ID especÃ­fico del mensaje
  if (messageId) {
    return processedMessages.has(messageId);
  }
  
  // Si no tenemos ID, usamos una combinaciÃ³n de remitente + texto + timestamp aproximado
  const messageKey = `${sender}:${text}`;
  const now = Date.now();
  
  // Verificar si ya existe una entrada reciente con esta combinaciÃ³n
  for (const [key, timestamp] of processedMessages.entries()) {
    if (key.startsWith(messageKey) && (now - timestamp) < MESSAGE_EXPIRE_TIME) {
      return true;
    }
  }
  
  return false;
}

// FunciÃ³n para marcar un mensaje como procesado
function markMessageAsProcessed(messageId, sender, text) {
  const key = messageId || `${sender}:${text}:${Date.now()}`;
  processedMessages.set(key, Date.now());
  
  // Limpieza de mensajes expirados (cada 100 mensajes)
  if (processedMessages.size > 100) {
    const now = Date.now();
    for (const [key, timestamp] of processedMessages.entries()) {
      if (now - timestamp > MESSAGE_EXPIRE_TIME) {
        processedMessages.delete(key);
      }
    }
  }
}

// ğŸš€ Verificar API Keys
console.log("ğŸ”‘ API Keys cargadas:");
console.log("OPENAI_API_KEY:", OPENAI_API_KEY ? "âœ… OK" : "âŒ FALTA");
console.log("GUPSHUP_API_KEY:", GUPSHUP_API_KEY ? "âœ… OK" : "âŒ FALTA");
console.log("GUPSHUP_NUMBER:", GUPSHUP_NUMBER ? "âœ… OK" : "âŒ FALTA");
console.log("GUPSHUP_USERID:", GUPSHUP_USERID ? "âœ… OK" : "âŒ FALTA");
console.log("CONTROL_PANEL_URL:", CONTROL_PANEL_URL);

// Verificar si CONTROL_PANEL_URL es vÃ¡lido
if (CONTROL_PANEL_URL.includes('api.openai.com')) {
    console.error("ğŸš¨ ERROR GRAVE: CONTROL_PANEL_URL estÃ¡ configurado incorrectamente a api.openai.com");
    console.error("ğŸ›‘ Esta configuraciÃ³n causarÃ¡ problemas con la API. Por favor corrige el valor.");
} else if (CONTROL_PANEL_URL.includes('localhost') && PROD_ENV) {
    console.warn("âš ï¸ Advertencia: CONTROL_PANEL_URL estÃ¡ configurado a localhost en entorno de producciÃ³n");
    // Actualizar una Ãºltima vez para asegurar que estÃ¡ correcto
    if (PROD_ENV) {
        const correctProdUrl = 'https://whatsapp-bot-if6z.onrender.com/api/register-bot-response';
        console.log(`âš™ï¸ Actualizando automÃ¡ticamente CONTROL_PANEL_URL a: ${correctProdUrl}`);
        process.env.CONTROL_PANEL_URL = correctProdUrl;
        CONTROL_PANEL_URL = correctProdUrl;
    }
    console.warn("âš ï¸ Esto podrÃ­a causar problemas al registrar respuestas");
}

// âŒ Si faltan claves, detener el servidor
if (!OPENAI_API_KEY || !GUPSHUP_API_KEY || !GUPSHUP_NUMBER) {
    console.error("âš ï¸ ERROR: Faltan claves de API. Verifica las variables de entorno.");
    process.exit(1);
}

// ConfiguraciÃ³n de Supabase
const supabaseUrl = process.env.SUPABASE_URL || 'https://wscijkxwevgxbgwhbqtm.supabase.co';
// Intentar obtener la clave de Supabase de diferentes variables de entorno posibles
// Verificamos todas las posibles variables donde podrÃ­a estar la clave de Supabase
const supabaseKey = process.env.SUPABASE_ANON_KEY || 
                   process.env.SUPABASE_KEY || 
                   process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 
                   'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndzY2lqa3h3ZXZneGJnd2hicXRtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4MjI3NjgsImV4cCI6MjA1NzM5ODc2OH0._HSnvof7NUk6J__qqq3gJvbJRZnItCAmlI5HYAL8WVI';

console.log('ğŸ”‘ DEBUG - Variables de entorno para Supabase:');
console.log('- SUPABASE_URL:', process.env.SUPABASE_URL || 'no definido');
console.log('- SUPABASE_ANON_KEY:', process.env.SUPABASE_ANON_KEY ? process.env.SUPABASE_ANON_KEY.substring(0, 10) + '...' : 'no definido');
console.log('- SUPABASE_KEY:', process.env.SUPABASE_KEY ? process.env.SUPABASE_KEY.substring(0, 10) + '...' : 'no definido');
console.log('- NEXT_PUBLIC_SUPABASE_ANON_KEY:', process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY.substring(0, 10) + '...' : 'no definido');

if (!supabaseUrl) {
    console.error('âŒ ERROR: Falta la URL de Supabase');
    process.exit(1);
}

if (!supabaseKey) {
    console.error('âŒ ERROR: Faltan credenciales de Supabase (ninguna variable de clave estÃ¡ definida)');
    process.exit(1);
}

console.log('âœ… Credenciales de Supabase encontradas correctamente');
console.log(`ğŸ”‘ Usando clave de Supabase (primeros 10 caracteres): ${supabaseKey.substring(0, 10)}...`);

const supabase = createClient(supabaseUrl, supabaseKey);

// FunciÃ³n auxiliar para verificar la estructura de la tabla messages
async function getMessagesTableStructure() {
    try {
        // Intentamos usar el procedimiento RPC, pero puede no existir
        const { data: tableInfo, error: tableError } = await supabase
            .rpc('get_table_metadata', { table_name: 'messages' });
        
        if (tableError) {
            console.warn('âš ï¸ No se pudo obtener metadata de la tabla mediante RPC:', tableError.message);
            
            // Alternativa: obtener una fila para ver estructura
            const { data: sampleRow, error: sampleError } = await supabase
                .from('messages')
                .select('*')
                .limit(1);
            
            if (sampleError) {
                console.warn('âš ï¸ No se pudo obtener muestra de la tabla:', sampleError.message);
                return null;
            }
            
            // Si tenemos una fila, podemos ver sus propiedades
            if (sampleRow && sampleRow.length > 0) {
                return Object.keys(sampleRow[0]);
            }
            
            // Si no hay datos, asumimos estructura bÃ¡sica
            return ['conversation_id', 'content', 'sender_type', 'created_at'];
        }
        
        // Si obtuvimos datos del RPC, extraer nombres de columnas
        if (tableInfo && Array.isArray(tableInfo)) {
            return tableInfo.map(col => col.column_name);
        }
        
        return null;
    } catch (error) {
        console.error('âŒ Error verificando estructura de tabla:', error);
        return null;
    }
}

// Formato de fecha seguro para cualquier tipo de entrada
function safeISODate(timestamp) {
  if (!timestamp) {
    return new Date().toISOString();
  }
  
  try {
    // Si es nÃºmero directo (segundos desde epoch)
    if (typeof timestamp === 'number') {
      return new Date(timestamp * 1000).toISOString();
    }
    
    // Si es string que parece nÃºmero
    if (typeof timestamp === 'string' && /^\d+$/.test(timestamp)) {
      return new Date(parseInt(timestamp) * 1000).toISOString();
    }
    
    // Si ya es un objeto Date
    if (timestamp instanceof Date) {
      return timestamp.toISOString();
    }
    
    // Si es un string de fecha ISO
    if (typeof timestamp === 'string' && /^\d{4}-\d{2}-\d{2}/.test(timestamp)) {
      return new Date(timestamp).toISOString();
    }
    
    // Caso por defecto
    return new Date().toISOString();
    } catch (error) {
    console.warn(`âš ï¸ Error al formatear fecha ${timestamp}:`, error);
    return new Date().toISOString();
  }
}

// FunciÃ³n para guardar mensaje en Supabase
async function saveMessageToSupabase({ sender, message, messageId, timestamp, conversationId, isBotActive }) {
    try {
        if (!sender || !message) {
            console.warn('âŒ Datos incompletos para guardar mensaje en Supabase');
            return null;
        }

        console.log(`ğŸ’¾ Guardando mensaje de tipo 'user' para: ${sender}`);
        
        // Si no tenemos conversation_id, intentar encontrarlo
        let existingConversationId = conversationId;
        
        if (!existingConversationId) {
            // Verificar si ya existe una conversaciÃ³n para este remitente
            console.log(`ğŸ” Buscando conversaciÃ³n para: ${sender}`);
            
            const { data: existingConv, error: convError } = await supabase
                .from('conversations')
                .select('id, is_bot_active')
                .eq('user_id', sender)
                .eq('business_id', BUSINESS_ID);
            
            if (convError) {
                console.error('âŒ Error buscando conversaciÃ³n:', convError);
            } else if (existingConv && existingConv.length > 0) {
                existingConversationId = existingConv[0].id;
                // Actualizar el estado del bot si lo recibimos
                if (typeof isBotActive !== 'undefined') {
                    // Forzar la actualizaciÃ³n del estado en cachÃ©
                    senderBotStatusMap[sender] = isBotActive === true;
                } else {
                    // Usar el estado de la DB
                    isBotActive = existingConv[0].is_bot_active === true;
                    senderBotStatusMap[sender] = isBotActive;
                }
                
                console.log(`â„¹ï¸ Usando conversaciÃ³n existente con ID: ${existingConversationId} (bot activo: ${isBotActive ? 'SÃ' : 'NO'})`);
            } else {
                // Crear nueva conversaciÃ³n
                console.log(`ğŸ“ Creando nueva conversaciÃ³n para ${sender}`);
                const { data: newConv, error: createError } = await supabase
                    .from('conversations')
                    .insert([
                        { 
                            user_id: sender,
                            business_id: BUSINESS_ID,
                            is_bot_active: false, // Por defecto inactivo
                            sender_name: sender
                        }
                    ])
                    .select();
                
                if (createError) {
                    console.error('âŒ Error creando conversaciÃ³n:', createError);
                    return null;
                }
                
                if (newConv && newConv.length > 0) {
                    existingConversationId = newConv[0].id;
                    isBotActive = false; // Nueva conversaciÃ³n, bot inactivo por defecto
                    
                    // Actualizar mapeos
                    phoneToConversationMap[sender] = existingConversationId;
                    conversationIdToPhoneMap[existingConversationId] = sender;
                    
                    // Actualizar estado en cachÃ©
                    senderBotStatusMap[sender] = false;
                    
                    console.log(`âœ… Nueva conversaciÃ³n creada: ${existingConversationId} para ${sender} (bot inactivo por defecto)`);
                }
            }
        }
        
        if (!existingConversationId) {
            console.error('âŒ No se pudo crear o encontrar conversaciÃ³n');
            return null;
        }

        // Guardar el mensaje en la tabla messages
        const tableColumns = await getMessagesTableStructure();
        
        // Usar la funciÃ³n segura para formatear la fecha
        const safeTimestamp = safeISODate(timestamp);
        console.log(`ğŸ“… Timestamp formateado: ${safeTimestamp}`);
        
        let messageData = {
            conversation_id: existingConversationId,
            content: message,
            sender_type: 'user',
            created_at: safeTimestamp
        };
        
        // Solo aÃ±adir business_id si existe en la tabla
        if (tableColumns && tableColumns.includes('business_id')) {
            messageData.business_id = BUSINESS_ID;
        }
        
        const { error: saveError } = await supabase
            .from('messages')
            .insert([messageData]);
        
        if (saveError) {
            console.error('âŒ Error guardando mensaje:', saveError);
            
            // Si el error es sobre business_id, intentar sin Ã©l
            if (saveError.message && saveError.message.includes('business_id')) {
                console.log('â„¹ï¸ Intentando guardar mensaje sin business_id...');
                
                delete messageData.business_id;
                
                const { error: retryError } = await supabase
                    .from('messages')
                    .insert([messageData]);
                
                if (retryError) {
                    console.error('âŒ Error en segundo intento para guardar mensaje:', retryError);
                    return null;
                }
            } else {
                return null;
            }
        }
        
        // Actualizar la conversaciÃ³n con el Ãºltimo mensaje
        await updateConversationLastActivity(existingConversationId, message);
        
        console.log('âœ… Mensaje guardado en Supabase correctamente');
        return existingConversationId;
        
    } catch (error) {
        console.error('âŒ Error general guardando mensaje en Supabase:', error);
        return null;
    }
}

// FunciÃ³n para actualizar Ãºltima actividad de conversaciÃ³n
async function updateConversationLastActivity(conversationId, lastMessage) {
    try {
        console.log('ğŸ”„ Actualizando Ãºltima actividad de conversaciÃ³n:', conversationId);
        
        const { data, error } = await supabase
            .from('conversations')
            .update({
                last_message: lastMessage,
                last_message_time: new Date().toISOString()
            })
            .eq('id', conversationId)
            .select();
            
        if (error) {
            console.error('âŒ Error al actualizar conversaciÃ³n:', error);
            throw error;
        }
        
        console.log('âœ… ConversaciÃ³n actualizada:', data);
        return data;
    } catch (error) {
        console.error('âŒ Error en updateConversationLastActivity:', error);
        throw error;
    }
}

/**
 * Registra una respuesta del bot (o agente) en Supabase y actualiza la actividad de la conversaciÃ³n
 * @param {string} conversationId - ID de la conversaciÃ³n (puede ser un nÃºmero telefÃ³nico o un UUID)
 * @param {string} message - Contenido del mensaje
 * @param {string} business_id - ID del negocio
 * @param {string} sender_type - Tipo de remitente ('bot', 'user', 'agent')
 * @returns {Promise<object>} - Resultado de la operaciÃ³n
 */
async function registerBotResponse(conversationId, botMessage) {
  console.log(`\nğŸ¤– ===== INICIO DE REGISTER_BOT_RESPONSE =====`);
  console.log(`ğŸ¤– Registrando respuesta del bot para conversaciÃ³n: ${conversationId}`);
  console.log(`ğŸ¤– Mensaje completo del bot: "${botMessage}"`);
  
  try {
    // Verificar si el mensaje contiene frases que requieren notificaciÃ³n
    console.log(`\nğŸ” VERIFICANDO FRASES DE NOTIFICACIÃ“N EN REGISTER_BOT_RESPONSE`);
    
    // DepuraciÃ³n: Verificar cuÃ¡les son las implementaciones de detecciÃ³n activas
    console.log(`ğŸ”§ DIAGNÃ“STICO: checkForNotificationPhrases es de tipo: ${typeof checkForNotificationPhrases}`);
    console.log(`ğŸ”§ DIAGNÃ“STICO: Â¿Existe funciÃ³n en helpers? ${typeof require('./helpers/notificationHelpers').checkForNotificationPhrases === 'function' ? 'SÃ' : 'NO'}`);
    
    // DetecciÃ³n bÃ¡sica de texto crÃ­tico para depuraciÃ³n
    console.log(`ğŸ”§ VERIFICACIÃ“N MANUAL: Â¿Contiene "Perfecto"? ${botMessage.includes("Perfecto") ? 'SÃ' : 'NO'}`);
    console.log(`ğŸ”§ VERIFICACIÃ“N MANUAL: Â¿Contiene "cita"? ${botMessage.includes("cita") ? 'SÃ' : 'NO'}`);
    console.log(`ğŸ”§ VERIFICACIÃ“N MANUAL: Â¿Contiene "confirmada"? ${botMessage.includes("confirmada") ? 'SÃ' : 'NO'}`);
    
    // VerificaciÃ³n exacta conocida
    if (botMessage.includes("Perfecto") && botMessage.includes("cita") && botMessage.includes("confirmada")) {
      console.log(`âš ï¸ ALERTA MANUAL: Mensaje contiene combinaciÃ³n crÃ­tica de palabras que deberÃ­a activar notificaciÃ³n`);
    }
    
    // VerificaciÃ³n completa con la funciÃ³n 
    const requiresNotification = checkForNotificationPhrases(botMessage);
    console.log(`ğŸ” Â¿Requiere notificaciÃ³n segÃºn checkForNotificationPhrases?: ${requiresNotification ? 'SÃ âœ…' : 'NO âŒ'}`);
    
    if (requiresNotification) {
      console.log(`\nğŸ”” ğŸ”” ğŸ”” CONFIRMADO: MENSAJE REQUIERE NOTIFICACIÃ“N ğŸ”” ğŸ”” ğŸ””`);
      
      // Obtener nÃºmero de telÃ©fono del cliente
      let clientPhoneNumber = conversationIdToPhoneMap[conversationId];
      console.log(`ğŸ“± Buscando nÃºmero telefÃ³nico para conversaciÃ³n ${conversationId}...`);
      
      // Si no estÃ¡ en el mapa, intentar obtenerlo de la base de datos
      if (!clientPhoneNumber) {
        console.log(`ğŸ“± No se encontrÃ³ en mapa, buscando en base de datos...`);
        try {
          console.log(`ğŸ” Consultando tabla 'conversations', buscando 'user_id' para conversaciÃ³n ID: ${conversationId}`);
          const { data: conversation, error } = await supabase
            .from('conversations')
            .select('user_id')
            .eq('id', conversationId)
            .single();
            
          if (error) {
            console.error(`âŒ Error en consulta a Supabase: ${error.message}`);
            console.error(`âŒ Detalles: ${JSON.stringify(error)}`);
          }
            
          if (conversation && conversation.user_id) {
            clientPhoneNumber = conversation.user_id;
            // Guardar para futuras consultas
            conversationIdToPhoneMap[conversationId] = clientPhoneNumber;
            console.log(`ğŸ“± Â¡NÃºmero encontrado!: ${clientPhoneNumber}`);
          } else {
            console.error(`âŒ No se encontrÃ³ conversaciÃ³n o no tiene user_id para ${conversationId}`);
            console.log(`ğŸ’¾ Datos retornados: ${JSON.stringify(conversation)}`);
          }
        } catch (dbError) {
          console.error(`âŒ Error al consultar base de datos: ${dbError.message}`);
          console.error(`âŒ Stack: ${dbError.stack}`);
        }
      } else {
        console.log(`ğŸ“± NÃºmero encontrado en mapa: ${clientPhoneNumber}`);
      }
      
      if (clientPhoneNumber) {
        console.log(`\nğŸ“§ === ENVIANDO NOTIFICACIÃ“N DESDE REGISTER_BOT_RESPONSE ===`);
        
        // PRUEBA DIRECTA DE ENVÃO DE CORREO DESDE REGISTER_BOT_RESPONSE
        try {
          console.log(`ğŸ“§ ENVIANDO CORREO DE PRUEBA DIRECTAMENTE DESDE REGISTER_BOT_RESPONSE`);
          
          // Crear un transporter especÃ­fico para esta prueba
          const testTransporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
              user: process.env.EMAIL_USER || 'bexorai@gmail.com',
              pass: process.env.EMAIL_PASSWORD || 'gqwi aker jgrn kylf'
            },
            debug: true
          });
          
          // Enviar un correo de prueba bÃ¡sico
          const testResult = await testTransporter.sendMail({
            from: '"Bot WhatsApp - REGISTER_BOT_RESPONSE" <bexorai@gmail.com>',
            to: 'bexorai@gmail.com',
            subject: `REGISTER TEST - Message: ${botMessage.substring(0, 30)}...`,
            html: `<p>Este es un correo de prueba directo desde registerBotResponse.</p>
                   <p><strong>Mensaje:</strong> ${botMessage}</p>
                   <p><strong>ConversaciÃ³n ID:</strong> ${conversationId}</p>
                   <p><strong>TelÃ©fono:</strong> ${clientPhoneNumber}</p>
                   <p><strong>Fecha:</strong> ${new Date().toISOString()}</p>`
          });
          
          console.log(`ğŸ“§ RESULTADO DE CORREO DE PRUEBA: ${testResult.messageId}`);
          
          // Llamar a la funciÃ³n de notificaciÃ³n completa
          console.log(`ğŸ“§ Ejecutando sendBusinessNotification...`);
          const result = await sendBusinessNotification(conversationId, botMessage, clientPhoneNumber);
          console.log(`ğŸ“§ RESULTADO de envÃ­o de notificaciÃ³n: ${result ? 'Ã‰XITO âœ…' : 'FALLIDO âŒ'}`);
        } catch (emailError) {
          console.error(`âŒ Error en envÃ­o de prueba de correo: ${emailError.message}`);
          console.error(`âŒ Stack: ${emailError.stack}`);
        }
      } else {
        console.error(`âŒ No se pudo obtener nÃºmero de telÃ©fono para enviar notificaciÃ³n`);
      }
    } else {
      // FORZAR VERIFICACIÃ“N ADICIONAL
      console.log(`ğŸ” FORZANDO VERIFICACIÃ“N ADICIONAL con patrones explÃ­citos...`);
      
      // VerificaciÃ³n manual con patrones especÃ­ficos de confirmaciÃ³n de cita
      if (botMessage.match(/cita.*confirmada/i) || 
          botMessage.match(/Â¡Perfecto.*cita/i) || 
          botMessage.match(/tu cita ha sido/i)) {
        console.log(`âš ï¸ ALERTA: PatrÃ³n de confirmaciÃ³n de cita detectado manualmente`);
        console.log(`âš ï¸ El mensaje DEBERÃA haber activado una notificaciÃ³n pero no lo hizo.`);
      
        // Obtener nÃºmero de telÃ©fono del cliente para prueba
        let clientPhoneNumber = conversationIdToPhoneMap[conversationId];
        console.log(`ğŸ“± Buscando nÃºmero telefÃ³nico para verificaciÃ³n adicional: ${clientPhoneNumber || 'No disponible'}`);
      }
      
      console.log(`â„¹ï¸ El mensaje no contiene frases que requieran notificaciÃ³n segÃºn la funciÃ³n principal.`);
    }
    
    // Registrar el mensaje en la base de datos
    console.log(`ğŸ“Š Registrando mensaje en la base de datos (tabla messages)...`);
    const { data: messageData, error: messageError } = await supabase
      .from('messages')
      .insert([
        {
          conversation_id: conversationId,
          content: botMessage,
          sender_type: 'bot'
        }
      ])
      .select();
      
    if (messageError) {
      console.error(`âŒ Error al registrar mensaje en DB: ${messageError.message}`);
    } else {
      console.log(`âœ… Mensaje registrado correctamente con ID: ${messageData[0]?.id || 'N/A'}`);
    }
    
    // Insertar el mensaje en el mapa
    if (!conversationMessagesMap[conversationId]) {
      conversationMessagesMap[conversationId] = [];
    }
    
    conversationMessagesMap[conversationId].push({
      id: messageData?.[0]?.id || `temp-${Date.now()}`,
      conversation_id: conversationId,
      content: botMessage,
      sender_type: 'bot',
      created_at: new Date().toISOString()
    });
    
    console.log(`ğŸ¤– ===== FIN DE REGISTER_BOT_RESPONSE =====\n`);
    return messageData?.[0]?.id;
  } catch (error) {
    console.error(`âŒ ERROR EN REGISTER_BOT_RESPONSE: ${error.message}`);
    console.error(`âŒ Stack: ${error.stack}`);
    throw error;
  }
}

// Procesar mensaje con OpenAI y generar respuesta
async function processMessageWithOpenAI(sender, message, conversationId) {
    try {
        if (!sender || !message) {
            logDebug('âŒ Datos incompletos para procesar mensaje con OpenAI');
            return null;
        }

        logDebug(`ğŸ” VERIFICACIÃ“N CRÃTICA: Comprobando si el bot debe estar ACTIVO para ${sender}`);
        
        // âš ï¸ VERIFICACIÃ“N INICIAL - Comprobar que NO estÃ© desactivado en cachÃ©
        if (sender in senderBotStatusMap && senderBotStatusMap[sender] === false) {
            logDebug(`ğŸš« PROTECCIÃ“N INICIAL: Bot marcado como INACTIVO en cachÃ© para ${sender}, CANCELANDO procesamiento`);
            return null;
        }

        // âš ï¸ VERIFICACIÃ“N EN BASE DE DATOS - Forzar consulta a DB
        let isBotActive = false;
        let actualConversationId = conversationId;
        
        // Si no tenemos ID, intentar buscarlo por nÃºmero
        if (!actualConversationId) {
            logDebug(`ğŸ” Buscando conversaciÃ³n para ${sender}...`);
            const { data: convById, error: errorById } = await supabase
                .from('conversations')
                .select('id, is_bot_active')
                .eq('user_id', sender)
                .eq('business_id', BUSINESS_ID);
                
            if (errorById) {
                logDebug('âŒ ERROR CRÃTICO buscando conversaciÃ³n: ' + JSON.stringify(errorById));
                return null; // Salir por seguridad
            }
            
            if (convById && convById.length > 0) {
                actualConversationId = convById[0].id;
                isBotActive = convById[0].is_bot_active === true; // ComparaciÃ³n estricta
                logDebug(`ğŸ” Encontrada conversaciÃ³n: ${actualConversationId}, bot_active=${isBotActive}`);
            } else {
                logDebug(`âš ï¸ No se encontrÃ³ conversaciÃ³n para ${sender}`);
                return null; // No hay conversaciÃ³n, no procesar
            }
        } else {
            // Tenemos ID, verificamos directamente
            logDebug(`ğŸ” Verificando estado para conversaciÃ³n ${actualConversationId}...`);
            const { data: convData, error: convError } = await supabase
                .from('conversations')
                .select('is_bot_active')
                .eq('id', actualConversationId)
                .single();
                
            if (convError) {
                logDebug(`âŒ Error consultando estado del bot: ${convError.message}`);
                return null; // Salir por seguridad
            }
            
            if (!convData) {
                logDebug(`âŒ No se encontrÃ³ datos para la conversaciÃ³n ${actualConversationId}`);
                return null; // No hay datos, no procesar
            }
            
            isBotActive = convData.is_bot_active === true; // Estricto
            logDebug(`ğŸ” Estado de conversaciÃ³n ${actualConversationId}: bot_active=${isBotActive}`);
            
            // VerificaciÃ³n final - consultar de nuevo como Ãºltimo recurso
            try {
                const { data: finalCheck, error: finalError } = await supabase
                    .from('conversations')
                    .select('is_bot_active')
                    .eq('id', actualConversationId)
                    .single();
                    
                if (!finalError && finalCheck) {
                    logDebug(`ğŸ” VERIFICACIÃ“N FINAL: Consultando nuevamente estado para ${actualConversationId}...`);
                    logDebug(`ğŸ” ESTADO FINAL: is_bot_active=${finalCheck.is_bot_active}`);
                    isBotActive = finalCheck.is_bot_active === true;
                    
                    // Actualizar cachÃ©
                    const userId = conversationIdToPhoneMap[actualConversationId] || sender;
                    if (userId) {
                        senderBotStatusMap[userId] = isBotActive;
                        logDebug(`ğŸ“ CachÃ© FINAL actualizada: senderBotStatusMap[${userId}] = ${isBotActive}`);
                    }
                }
            } catch (finalCheckError) {
                logDebug(`âš ï¸ Error en verificaciÃ³n final: ${finalCheckError.message}`);
                // Continuar con el valor que ya tenÃ­amos
            }
        }
        
        // VerificaciÃ³n final: Si el bot estÃ¡ desactivado, no procesar
        if (!isBotActive) {
            logDebug(`ğŸš« Bot DESACTIVADO para ${sender}, cancelando procesamiento`);
            return null;
        }
        
        logDebug(`âœ… VERIFICACIONES COMPLETAS: Bot confirmado como ACTIVO para ${sender}, procediendo con OpenAI`);
        
        // ğŸ¤– Procesamiento con OpenAI Assistants API
        logDebug(`ğŸ”‘ Usando OpenAI API Key: ${OPENAI_API_KEY.substring(0, 10)}...`);
        logDebug(`ğŸ¤– Usando Assistant ID: ${ASSISTANT_ID}`);
        
        // Verificar si el usuario tiene un thread existente o crear uno nuevo
        if (!userThreads[sender]) {
            try {
                logDebug(`ğŸ§µ Creando nuevo thread para usuario ${sender}`);
                const thread = await openai.beta.threads.create();
                userThreads[sender] = thread.id;
                logDebug(`âœ… Thread creado con ID: ${thread.id} para usuario ${sender}`);
            } catch (threadError) {
                logDebug(`âŒ Error creando thread: ${JSON.stringify(threadError)}`);
                return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo mÃ¡s tarde.";
            }
        }
        
        const threadId = userThreads[sender];
        logDebug(`ğŸ§µ Usando thread ${threadId} para usuario ${sender}`);
        
        // AÃ±adir el mensaje al thread
        try {
            logDebug(`ğŸ“ AÃ±adiendo mensaje al thread: "${message}"`);
            await openai.beta.threads.messages.create(threadId, {
                role: "user",
                content: message
            });
            logDebug(`âœ… Mensaje aÃ±adido al thread ${threadId}`);
        } catch (messageError) {
            logDebug(`âŒ Error aÃ±adiendo mensaje al thread: ${JSON.stringify(messageError)}`);
            return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo mÃ¡s tarde.";
        }
        
        // Ejecutar el assistant con el thread
        try {
            logDebug(`ğŸ¤– Procesando con asistente especÃ­fico: ${ASSISTANT_ID}`);
            const run = await openai.beta.threads.runs.create(threadId, {
                assistant_id: ASSISTANT_ID
            });
            
            const runId = run.id;
            logDebug(`ğŸƒ Run iniciado con ID: ${runId}`);
            
            // Esperar a que termine el procesamiento
            let runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
            let attempts = 1;
            
            while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && attempts <= 10) {
                logDebug(`ğŸ”„ Estado del run: ${runStatus.status} (intento ${attempts})`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo
                runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
                attempts++;
            }
            
            if (runStatus.status !== 'completed') {
                logDebug(`âŒ El run no se completÃ³ correctamente: ${runStatus.status}`);
                return "Lo siento, no pude procesar tu mensaje en este momento. Por favor, intenta de nuevo mÃ¡s tarde.";
            }
            
            // Obtener respuesta del asistente
            const messages = await openai.beta.threads.messages.list(threadId);
            const assistantMessages = messages.data.filter(msg => 
                msg.role === "assistant" && msg.run_id === runId
            );
            
            if (assistantMessages.length === 0) {
                logDebug('âŒ No se encontraron respuestas del asistente');
                return "Lo siento, no pude generar una respuesta adecuada. Por favor, intenta de nuevo.";
            }
            
            // Obtener la respuesta mÃ¡s reciente del asistente
            const response = assistantMessages[0].content[0].text.value;
            logDebug(`âœ… Respuesta del asistente: "${response.substring(0, 100)}${response.length > 100 ? '...' : ''}"`);
            
            return response;
            
        } catch (runError) {
            logDebug(`âŒ Error en la ejecuciÃ³n del asistente: ${JSON.stringify(runError)}`);
            return "Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, intenta de nuevo mÃ¡s tarde.";
        }
        
    } catch (error) {
        logDebug(`âŒ Error general en processMessageWithOpenAI: ${JSON.stringify(error)}`);
        return "Lo siento, ha ocurrido un error inesperado. Por favor, intenta de nuevo mÃ¡s tarde.";
    }
}

// FunciÃ³n para enviar respuesta a WhatsApp
async function sendWhatsAppResponse(recipient, message) {
    try {
    console.log(`ğŸ“¤ Enviando respuesta a ${recipient}: "${message.substring(0, 150)}${message.length > 150 ? '...' : ''}"`);

    // VERIFICACIÃ“N DE NOTIFICACIÃ“N PARA MENSAJES BOT
    try {
      console.log(`ğŸ” === VERIFICACIÃ“N DE NOTIFICACIÃ“N EN SENDWHATSAPPRESPONSE ===`);
      console.log(`ğŸ” Mensaje completo a verificar: "${message}"`);

      // VerificaciÃ³n principal utilizando la funciÃ³n mejorada
      console.log(`ğŸ” Ejecutando verificaciÃ³n con funciÃ³n actualizada checkForNotificationPhrases`);
      const requiresNotification = checkForNotificationPhrases(message);
      console.log(`ğŸ” Resultado: ${requiresNotification ? 'âœ… REQUIERE NOTIFICACIÃ“N' : 'âŒ NO REQUIERE NOTIFICACIÃ“N'}`);
      
      if (requiresNotification) {
        console.log(`ğŸ“§ NOTIFICACIÃ“N REQUERIDA - Procesando envÃ­o de correo`);
        
        // Buscar la conversaciÃ³n para este nÃºmero
        let conversationId = phoneToConversationMap[recipient];

        if (!conversationId) {
          try {
            console.log(`ğŸ” Buscando conversaciÃ³n para nÃºmero: ${recipient}`);
            const { data: convData, error: convError } = await supabase
              .from('conversations')
              .select('id')
              .eq('user_id', recipient)
              .single();

            if (convError) {
              console.error(`âŒ Error al buscar conversaciÃ³n: ${convError.message}`);
            } else if (convData) {
              conversationId = convData.id;
              console.log(`âœ… ConversaciÃ³n encontrada: ${conversationId}`);

              // Actualizar mapeo en memoria
              phoneToConversationMap[recipient] = conversationId;
              conversationIdToPhoneMap[conversationId] = recipient;
            }
          } catch (dbError) {
            console.error(`âŒ Error en consulta: ${dbError.message}`);
          }
        }

        // Enviar notificaciÃ³n si corresponde
        if (conversationId) {
          console.log(`ğŸ“§ ENVIANDO NOTIFICACIÃ“N DESDE SENDWHATSAPPRESPONSE`);
          console.log(`ğŸ“§ ConversaciÃ³n: ${conversationId}`);
          console.log(`ğŸ“§ TelÃ©fono: ${recipient}`);
          console.log(`ğŸ“§ Mensaje que activÃ³ la notificaciÃ³n: "${message}"`);

          try {
            console.log(`ğŸ“§ PRIMER INTENTO de envÃ­o de notificaciÃ³n`);
            const result = await sendBusinessNotification(conversationId, message, recipient);
            console.log(`ğŸ“§ RESULTADO de notificaciÃ³n: ${result ? 'Ã‰XITO âœ…' : 'FALLIDO âŒ'}`);
            
            if (!result) {
              console.log(`ğŸ“§ Primer intento fallido, reintentando...`);
              const result2 = await sendBusinessNotification(conversationId, message, recipient);
              console.log(`ğŸ“§ RESULTADO de segundo intento: ${result2 ? 'Ã‰XITO âœ…' : 'FALLIDO âŒ'}`);
            }
          } catch (emailError) {
            console.error(`âŒ Error al enviar notificaciÃ³n: ${emailError.message}`);
            console.error(emailError.stack);
          }
        } else {
          console.error(`âŒ No se pudo obtener ID de conversaciÃ³n para ${recipient}, notificaciÃ³n no enviada`);
        }
      } else {
        console.log(`â„¹ï¸ Mensaje no requiere notificaciÃ³n segÃºn las reglas configuradas`);
      }
    } catch (notifError) {
      console.error(`âŒ Error en verificaciÃ³n de notificaciÃ³n: ${notifError.message}`);
      console.error(notifError.stack);
    }
    
    // CONTINUAR CON EL ENVÃO DEL MENSAJE A WHATSAPP
        if (!recipient || !message) {
            console.log('âŒ Error: destinatario o mensaje faltantes');
            return false;
        }

        // Formatear el nÃºmero (eliminar + al principio si existe)
        const formattedNumber = recipient.startsWith('+') 
            ? recipient.substring(1) 
            : recipient;
        
        // Verificar que el nÃºmero contenga solo dÃ­gitos
        if (!/^\d+$/.test(formattedNumber)) {
            console.log(`âŒ NÃºmero invÃ¡lido: ${formattedNumber}`);
            return false;
        }
        
        // Acceder a las variables de entorno directamente
        // Verificar que las variables estÃ©n correctamente definidas
        const GUPSHUP_API_KEY = process.env.GUPSHUP_API_KEY;
        const GUPSHUP_NUMBER = process.env.GUPSHUP_NUMBER;
        const GUPSHUP_USERID = process.env.GUPSHUP_USERID;
        
        console.log('ğŸ” Variables de entorno para GupShup:');
        console.log(`- GUPSHUP_API_KEY: ${GUPSHUP_API_KEY ? 'DEFINIDA' : 'NO DEFINIDA'}`);
        console.log(`- GUPSHUP_NUMBER: ${GUPSHUP_NUMBER ? GUPSHUP_NUMBER : 'NO DEFINIDA'}`);
        console.log(`- GUPSHUP_USERID: ${GUPSHUP_USERID ? 'DEFINIDA' : 'NO DEFINIDA'}`);
        
        if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER) {
            console.error('âŒ Error: credenciales de GupShup faltantes');
            return false;
        }
        
        // API v1 de GupShup - MÃ©todo simple que funcionaba antes
        // Nota: Cambiar a 'sm/api/v1/msg' en lugar de 'wa/api/v1/msg'
        const apiUrl = 'https://api.gupshup.io/sm/api/v1/msg';
        
        console.log(`ğŸ”‘ URL de API: ${apiUrl}`);
        console.log(`ğŸ“± NÃºmero de origen: ${GUPSHUP_NUMBER}`);
        console.log(`ğŸ“± NÃºmero de destino: ${formattedNumber}`);
        
        const formData = new URLSearchParams();
        formData.append('channel', 'whatsapp');
        formData.append('source', GUPSHUP_NUMBER);
        formData.append('destination', formattedNumber);
        formData.append('message', message);
        formData.append('src.name', GUPSHUP_NUMBER);
        
        // Formato simple de headers, como funcionaba antes
        const headers = {
            'Cache-Control': 'no-cache',
            'Content-Type': 'application/x-www-form-urlencoded',
            'apikey': GUPSHUP_API_KEY
        };
        
        // AÃ±adir userid si estÃ¡ disponible
        if (GUPSHUP_USERID) {
            headers['userid'] = GUPSHUP_USERID;
            console.log(`ğŸ‘¤ AÃ±adiendo userid: ${GUPSHUP_USERID}`);
        }
        
        console.log('ğŸ”„ Enviando mensaje a WhatsApp...');
        console.log('ğŸ“‹ Formulario:', Object.fromEntries(formData));
        console.log('ğŸ“‹ Headers:', headers);
        
        try {
            const response = await axios.post(apiUrl, formData, { headers });
            
            console.log('ğŸ“¡ Respuesta de GupShup:', JSON.stringify(response.data));
            
            if (response.status >= 200 && response.status < 300) {
                console.log('âœ… Mensaje enviado exitosamente a WhatsApp');
                
                // Guardar mensaje en la base de datos
                try {
                    await global.registerBotResponse(
                        recipient,
                        message,
                        BUSINESS_ID, 
                        'bot'
                    );
                    console.log('âœ… Mensaje del bot guardado en Supabase');
                } catch (dbError) {
                    console.log(`âš ï¸ Error guardando mensaje en Supabase: ${dbError.message}`);
                }
                
                return true;
            } else {
                console.error(`âŒ Error: CÃ³digo de respuesta ${response.status}`);
                return false;
            }
        } catch (apiError) {
            console.error(`âŒ Error en solicitud a GupShup:`, apiError.message);
            
            if (apiError.response) {
                console.error(`- Status: ${apiError.response.status}`);
                console.error(`- Datos: `, JSON.stringify(apiError.response.data, null, 2));
                console.error(`- Headers: `, JSON.stringify(apiError.response.headers, null, 2));
            } else if (apiError.request) {
                console.error(`- No hubo respuesta del servidor`);
            } else {
                console.error(`- Error al configurar la solicitud:`, apiError.message);
            }
            
            return false;
        }
    } catch (error) {
        console.error(`âŒ Error general en sendWhatsAppResponse:`, error.message);
        console.error(error.stack);
        return false;
    }
}

// FunciÃ³n para extraer datos del mensaje de la solicitud de webhook
function extractMessageData(body) {
  try {
    console.log(`ğŸ” Extrayendo datos de mensaje de webhook: ${JSON.stringify(body).substring(0, 200)}...`);
    logDebug(`ğŸ” Extrayendo datos de mensaje de webhook: ${JSON.stringify(body).substring(0, 200)}...`);
    
    // Valores por defecto
    const result = {
      isStatusUpdate: false,
      sender: null,
      message: null,
      messageId: null,
      timestamp: null
    };
    
    // Imprimir la estructura completa para depuraciÃ³n
    console.log('ğŸ“ Estructura completa del webhook:');
    console.log(JSON.stringify(body, null, 2));
    
    // Verificar si es un mensaje o una actualizaciÃ³n de estado
    if (body && body.entry && body.entry.length > 0) {
      const entry = body.entry[0];
      
      if (entry.changes && entry.changes.length > 0) {
        const change = entry.changes[0];
        
        // Para mensajes entrantes normales
        if (change.value && change.value.messages && change.value.messages.length > 0) {
          const messageData = change.value.messages[0];
          const contact = change.value.contacts && change.value.contacts.length > 0 
            ? change.value.contacts[0] 
            : null;
          
          result.sender = contact && contact.wa_id ? contact.wa_id : null;
          result.messageId = messageData.id || null;
          
          console.log(`ğŸ“¨ Datos del mensaje: ${JSON.stringify(messageData)}`);
          
          // Extraer contenido segÃºn el tipo de mensaje
          if (messageData.text && messageData.text.body) {
            result.message = messageData.text.body;
            console.log(`ğŸ’¬ Mensaje de texto encontrado: "${result.message}"`);
          } else if (messageData.type === 'text' && messageData.text) {
            result.message = messageData.text.body;
            console.log(`ğŸ’¬ Mensaje de texto (tipo): "${result.message}"`);
          } else if (messageData.type === 'button' && messageData.button) {
            result.message = messageData.button.text;
            console.log(`ğŸ”˜ Mensaje de botÃ³n: "${result.message}"`);
          } else if (messageData.type === 'interactive' && messageData.interactive) {
            // Manejar mensajes interactivos (botones, listas, etc.)
            if (messageData.interactive.button_reply) {
              result.message = messageData.interactive.button_reply.title;
              console.log(`ğŸ”˜ Respuesta interactiva (botÃ³n): "${result.message}"`);
            } else if (messageData.interactive.list_reply) {
              result.message = messageData.interactive.list_reply.title;
              console.log(`ğŸ“‹ Respuesta interactiva (lista): "${result.message}"`);
            }
          }
          
          // Si no pudimos extraer el mensaje, intentar con la estructura completa
          if (!result.message && messageData) {
            console.log('âš ï¸ No se pudo extraer mensaje con mÃ©todos conocidos, intentando alternativas...');
            // Intentar extraer de cualquier propiedad que tenga "body" o "text"
            if (messageData.body) {
              result.message = messageData.body;
              console.log(`ğŸ”„ Mensaje alternativo (body): "${result.message}"`);
            } else {
              // Buscar en todas las propiedades de primer nivel
              for (const key in messageData) {
                if (typeof messageData[key] === 'object' && messageData[key] !== null) {
                  if (messageData[key].body) {
                    result.message = messageData[key].body;
                    console.log(`ğŸ”„ Mensaje alternativo (${key}.body): "${result.message}"`);
                    break;
                  } else if (messageData[key].text) {
                    result.message = messageData[key].text;
                    console.log(`ğŸ”„ Mensaje alternativo (${key}.text): "${result.message}"`);
                    break;
                  }
                } else if (key === 'text' || key === 'body') {
                  result.message = messageData[key];
                  console.log(`ğŸ”„ Mensaje alternativo (${key}): "${result.message}"`);
                  break;
                }
              }
            }
          }
          
          // Capturar timestamp si estÃ¡ disponible
          result.timestamp = messageData.timestamp
            ? new Date(parseInt(messageData.timestamp) * 1000) 
            : new Date();
          
          console.log(`â° Timestamp: ${result.timestamp}`);
        } 
        // Para actualizaciones de estado de mensajes
        else if (change.value && change.value.statuses && change.value.statuses.length > 0) {
          result.isStatusUpdate = true;
          const status = change.value.statuses[0];
          result.messageId = status.id;
          result.status = status.status;
          result.timestamp = status.timestamp 
            ? new Date(parseInt(status.timestamp) * 1000) 
            : new Date();
          result.recipient = status.recipient_id;
          console.log(`ğŸ“Š ActualizaciÃ³n de estado: ${result.status} para mensaje ${result.messageId}`);
        }
      }
    }
    
    // Verificar si pudimos extraer los datos necesarios
    if (!result.isStatusUpdate && (!result.sender || !result.message)) {
      console.log(`âš ï¸ No se pudieron extraer datos completos del mensaje: sender=${result.sender}, message=${result.message}`);
      logDebug(`âš ï¸ No se pudieron extraer datos completos del mensaje: sender=${result.sender}, message=${result.message}`);
    } else {
      console.log(`âœ… Datos extraÃ­dos correctamente: ${result.isStatusUpdate ? 'actualizaciÃ³n de estado' : `mensaje de ${result.sender}: "${result.message}"`}`);
      logDebug(`âœ… Datos extraÃ­dos correctamente: ${result.isStatusUpdate ? 'actualizaciÃ³n de estado' : `mensaje de ${result.sender}`}`);
    }
    
    return result;
  } catch (error) {
    console.log(`âŒ Error extrayendo datos del mensaje: ${error.message}`);
    console.log(`âŒ Stack: ${error.stack}`);
    logDebug(`âŒ Error extrayendo datos del mensaje: ${error.message}`);
    return {
      isStatusUpdate: false,
      sender: null,
      message: null,
      messageId: null,
      timestamp: new Date()
    };
  }
}

// Exportar funciones para testing
module.exports = {
  app,
  extractMessageData,
  processMessageWithOpenAI,
  sendWhatsAppResponse
};

// Iniciar el servidor en el puerto especificado
app.listen(PORT, async () => {
  console.log(`ğŸš€ Servidor iniciado en puerto ${PORT}`);
  console.log(`ğŸ¤– Bot conectado al panel: ${CONTROL_PANEL_URL}`);
  
  // Verificar credenciales de GupShup
  console.log('ğŸ” Verificando credenciales de integraciÃ³n...');
  if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
    console.warn('âš ï¸ ADVERTENCIA: Falta alguna credencial de GupShup:');
    console.warn(`  - API Key: ${GUPSHUP_API_KEY ? 'âœ… Configurada' : 'âŒ Falta'}`);
    console.warn(`  - NÃºmero: ${GUPSHUP_NUMBER ? 'âœ… Configurado' : 'âŒ Falta'}`);
    console.warn(`  - User ID: ${GUPSHUP_USERID ? 'âœ… Configurado' : 'âŒ Falta'}`);
    console.warn('âš ï¸ La integraciÃ³n con WhatsApp no funcionarÃ¡ sin estas credenciales.');
  } else {
    console.log('âœ… Credenciales de GupShup presentes:');
    console.log(`  - API Key: ${GUPSHUP_API_KEY.substring(0, 8)}...`);
    console.log(`  - NÃºmero de origen: ${GUPSHUP_NUMBER}`);
    console.log(`  - User ID: ${GUPSHUP_USERID.substring(0, 8)}...`);
  }
  
  // Verificar credenciales de OpenAI
  if (!OPENAI_API_KEY) {
    console.warn('âš ï¸ ADVERTENCIA: Falta la clave API de OpenAI. El bot no podrÃ¡ responder.');
  } else {
    console.log(`âœ… Clave API de OpenAI configurada: ${OPENAI_API_KEY.substring(0, 8)}...`);
    if (OPENAI_API_KEY.startsWith('sk-proj-') && process.env.NODE_ENV === 'production') {
      console.warn('âš ï¸ ADVERTENCIA: Parece que estÃ¡s usando una clave de API de prueba en producciÃ³n.');
    }
  }
  
  // Cargar mapeos iniciales
  console.log('ğŸ”„ Inicializando mapeos y estados...');
  try {
    // Cargar todos los mapeos de nÃºmeros telefÃ³nicos a conversaciones
    await updateConversationMappings();
    
    // Actualizar estado de bots activos para tener una cachÃ© inicial
    console.log('ğŸ”„ Cargando estados de bot activo...');
    const { data, error } = await supabase
      .from('conversations')
      .select('id, user_id, is_bot_active')
      .eq('business_id', BUSINESS_ID);
    
    if (!error && data && data.length > 0) {
      data.forEach(conv => {
        if (conv.user_id) {
          senderBotStatusMap[conv.user_id] = conv.is_bot_active;
          console.log(`â„¹ï¸ Bot para ${conv.user_id}: ${conv.is_bot_active ? 'ACTIVO' : 'INACTIVO'}`);
        }
      });
      console.log(`âœ… Estados de bot cargados para ${Object.keys(senderBotStatusMap).length} conversaciones`);
    } else if (error) {
      console.warn('âš ï¸ Error al cargar estados iniciales de bots:', error.message);
    }
  } catch (e) {
    console.error('âŒ Error en inicializaciÃ³n de mapeos:', e.message);
  }
});

// Webhook para recibir mensajes de WhatsApp
app.post('/webhook', async (req, res) => {
    console.log('ğŸ“² Webhook recibido:', req.body.type);
    
    // Verificar el tipo de webhook
    if (req.body.type === 'message' && req.body.payload) {
        // Detectar si es un mensaje de imagen
        if (req.body.payload.type === 'image') {
            await handleMediaMessage(req, res);
            return;
        }
        
        // Proceso normal para mensajes de texto
        await handleIncomingMessage(req, res);
        return;
    }
    
    // Para otros tipos de webhooks
    res.status(200).json({ success: true, message: 'Webhook recibido' });
});

// Endpoint para enviar un mensaje a WhatsApp
app.post('/api/messages', async (req, res) => {
  console.log('ğŸ“© Mensaje manual recibido del dashboard:', JSON.stringify(req.body));
  
  try {
    const { conversationId, message, senderType = 'agent', businessId } = req.body;
    
    // Validar parÃ¡metros requeridos
    if (!conversationId) {
      return res.status(400).json({ error: 'Se requiere conversationId' });
    }
    
    if (!message) {
      return res.status(400).json({ error: 'Se requiere message (contenido del mensaje)' });
    }
    
    if (!businessId) {
      return res.status(400).json({ error: 'Se requiere businessId' });
    }
    
    // Normalizar el ID de conversaciÃ³n para manejar nÃºmeros de telÃ©fono
    const normalizedId = /^\d+$/.test(conversationId.trim()) 
      ? conversationId.trim().replace(/^\+/, '') // Quitar el + si existe
      : conversationId;
    
    console.log(`ğŸ“¤ Enviando mensaje a conversaciÃ³n ${normalizedId}: ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`);
    
    // IMPORTANTE: Primero desactivar el bot ANTES de enviar el mensaje
    // para evitar que responda automÃ¡ticamente - GARANTIZAR QUE ESTO FUNCIONE
    console.log('ğŸ”„ PASO 1: Desactivando el bot antes de enviar mensaje desde panel...');
    let botWasDeactivated = false;
    
    try {
      // IMPORTANTE: Intentar MÃšLTIPLES estrategias para desactivar el bot
      // Estrategia 1: Actualizar directamente en la base de datos
      const { data: botData, error: botError } = await supabase
        .from('conversations')
        .update({ is_bot_active: false })
        .eq('id', normalizedId)
        .select();
      
      if (botError) {
        console.warn('âš ï¸ Estrategia 1 fallÃ³: No se pudo desactivar bot por ID directo:', botError.message);
        
        // Estrategia 2: Buscar por user_id si el ID parece ser un nÃºmero de telÃ©fono
        if (/^\d+$/.test(normalizedId)) {
          console.log('ğŸ”„ Intentando Estrategia 2: Desactivar por user_id (nÃºmero telefÃ³nico)');
          const { data: phoneUpdate, error: phoneError } = await supabase
            .from('conversations')
            .update({ is_bot_active: false })
            .eq('user_id', normalizedId)
            .eq('business_id', businessId)
            .select();
          
          if (phoneError) {
            console.warn('âš ï¸ Estrategia 2 fallÃ³:', phoneError.message);
          } else if (phoneUpdate && phoneUpdate.length > 0) {
            console.log('âœ… Bot desactivado exitosamente con Estrategia 2 (actualizaciÃ³n por user_id)');
            botWasDeactivated = true;
          }
        }
      } else if (botData && botData.length > 0) {
        console.log('âœ… Bot desactivado exitosamente con Estrategia 1 (actualizaciÃ³n directa por ID)');
        botWasDeactivated = true;
      }
      
      // Estrategia 3: Usar SQL directo si las anteriores fallan
      if (!botWasDeactivated) {
        console.log('ğŸ”„ Intentando Estrategia 3: Desactivar con SQL directo');
        // Crear consulta SQL que maneje ambos casos (por ID o por user_id)
        let sqlQuery = '';
        let params = {};
        
        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(normalizedId)) {
          // Es un UUID
          sqlQuery = 'UPDATE conversations SET is_bot_active = false WHERE id = $1 RETURNING *';
          params = [normalizedId];
      } else {
          // Es un nÃºmero telefÃ³nico
          sqlQuery = 'UPDATE conversations SET is_bot_active = false WHERE user_id = $1 AND business_id = $2 RETURNING *';
          params = [normalizedId, businessId];
        }
        
        const { data: sqlUpdate, error: sqlError } = await supabase.rpc('execute_sql', { 
          query_text: sqlQuery, 
          params_array: params 
        });
        
        if (sqlError) {
          console.warn('âš ï¸ Estrategia 3 fallÃ³:', sqlError.message);
        } else if (sqlUpdate && sqlUpdate.length > 0) {
          console.log('âœ… Bot desactivado exitosamente con Estrategia 3 (SQL directo)');
          botWasDeactivated = true;
        }
      }
    } catch (botToggleError) {
      console.error('âŒ Error al intentar desactivar el bot:', botToggleError.message);
      // No interrumpir el flujo si falla la desactivaciÃ³n
    }
    
    // PASO 2: Enviar el mensaje (asegurÃ¡ndonos que sender_type es 'bot' para cumplir con restricciones de DB)
    console.log('ğŸ”„ PASO 2: Enviando mensaje...');
    const validSenderType = senderType === 'agent' ? 'bot' : senderType;
    
    let messageResult;
    try {
      // Usar registerBotResponse que ya tiene toda la lÃ³gica para manejo de mensajes
      messageResult = await global.registerBotResponse(
        normalizedId,
        message,
        businessId,
        validSenderType
      );
      
      if (!messageResult || !messageResult.success) {
        throw new Error(messageResult?.error || 'Error desconocido al registrar mensaje');
      }
      
      console.log('âœ… Mensaje registrado exitosamente:', messageResult.id);
    } catch (registerError) {
      console.error('âŒ Error al registrar mensaje:', registerError.message);
      return res.status(500).json({ 
        error: 'Error al registrar mensaje', 
        details: registerError.message 
      });
    }
    
    // PASO 3: VERIFICAR nuevamente que el bot sigue desactivado
    console.log('ğŸ”„ PASO 3: Verificando que el bot permanece desactivado...');
    try {
      const { data: verifyData, error: verifyError } = await supabase
        .from('conversations')
        .select('id, is_bot_active')
        .or(`id.eq.${normalizedId},user_id.eq.${normalizedId}`)
        .eq('business_id', businessId)
        .single();
      
      if (verifyError) {
        console.warn('âš ï¸ No se pudo verificar estado del bot:', verifyError.message);
      } else if (verifyData && verifyData.is_bot_active === true) {
        console.warn('âš ï¸ Bot sigue activo despuÃ©s del mensaje, intentando desactivar nuevamente...');
        
        // Forzar desactivaciÃ³n una vez mÃ¡s
        const { error: updateError } = await supabase
          .from('conversations')
          .update({ is_bot_active: false })
          .eq('id', verifyData.id);
        
        if (updateError) {
          console.error('âŒ No se pudo desactivar el bot despuÃ©s de verificaciÃ³n:', updateError.message);
        } else {
          console.log('âœ… Bot desactivado nuevamente con Ã©xito');
        }
      } else {
        console.log('âœ… Verificado: El bot estÃ¡ correctamente desactivado');
      }
    } catch (verifyError) {
      console.warn('âš ï¸ Error al verificar estado final del bot:', verifyError.message);
    }
    
    // PASO 4: Enviar mensaje a WhatsApp si es necesario
    let whatsappSuccess = false;
    let whatsappError = null;
    
    try {
      console.log('ğŸ“² PASO 4: Enviando mensaje a WhatsApp...');
      
      // Obtener nÃºmero telefÃ³nico si es un conversationId
      let phoneNumber = normalizedId;
      
      if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(normalizedId)) {
        // Es un UUID, buscar el nÃºmero de telÃ©fono asociado
        console.log(`ğŸ” Buscando nÃºmero de telÃ©fono para conversaciÃ³n ${normalizedId}`);
        
        // Verificar primero en cachÃ©
        if (conversationIdToPhoneMap[normalizedId]) {
          phoneNumber = conversationIdToPhoneMap[normalizedId];
          console.log(`âœ… NÃºmero encontrado en cachÃ© para conversaciÃ³n: ${phoneNumber}`);
        } else {
          // Buscar en base de datos
          try {
            const { data, error } = await supabase
              .from('conversations')
              .select('user_id')
              .eq('id', normalizedId)
              .single();
            
            if (error) {
              console.error(`âŒ Error buscando nÃºmero para conversaciÃ³n: ${error.message}`);
              throw new Error(`No se pudo obtener el nÃºmero de telÃ©fono: ${error.message}`);
            }
            
            if (data && data.user_id) {
              phoneNumber = data.user_id;
              console.log(`âœ… NÃºmero encontrado en DB para conversaciÃ³n: ${phoneNumber}`);
              
              // Actualizar cachÃ©
              conversationIdToPhoneMap[normalizedId] = phoneNumber;
              phoneToConversationMap[phoneNumber] = normalizedId;
            } else {
              console.error(`âŒ No se encontrÃ³ un nÃºmero de telÃ©fono para la conversaciÃ³n ${normalizedId}`);
              throw new Error('No se encontrÃ³ un nÃºmero de telÃ©fono asociado a esta conversaciÃ³n');
            }
          } catch (dbError) {
            console.error(`âŒ Error al buscar nÃºmero en DB: ${dbError.message}`);
            throw dbError;
          }
        }
      }
      
      // Verificar que tenemos un nÃºmero vÃ¡lido
      if (!phoneNumber || !/^\d+$/.test(phoneNumber.toString().replace(/^\+/, ''))) {
        console.error(`âŒ NÃºmero de telÃ©fono invÃ¡lido: ${phoneNumber}`);
        throw new Error(`Formato de nÃºmero invÃ¡lido: ${phoneNumber}`);
      }
      
      // Asegurar formato correcto del nÃºmero
      const formattedNumber = phoneNumber.toString().replace(/^\+/, '');
      console.log(`ğŸ“± NÃºmero final para envÃ­o: ${formattedNumber}`);
      
      // Enviar mensaje a WhatsApp directamente
      const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
      
      const formData = new URLSearchParams();
      formData.append('channel', 'whatsapp');
      formData.append('source', GUPSHUP_NUMBER);
      formData.append('destination', formattedNumber);
      formData.append('src.name', GUPSHUP_NUMBER);
      formData.append('message', JSON.stringify({
          type: 'text',
          text: message
      }));
      
      const headers = {
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/x-www-form-urlencoded',
        'apikey': GUPSHUP_API_KEY,
        'userid': GUPSHUP_USERID  // AÃ±adimos el userid para mejorar la autenticaciÃ³n
      };
      
      console.log('ğŸ”„ Enviando mensaje directamente a la API de GupShup...');
      console.log(`ğŸ“Š ParÃ¡metros de envÃ­o: destination=${formattedNumber}, text="${message.substring(0, 30)}${message.length > 30 ? '...' : ''}"`);
      
      try {
        const response = await axios.post(apiUrl, formData, { headers });
        
        if (response.status >= 200 && response.status < 300) {
          console.log('âœ… Mensaje enviado exitosamente a WhatsApp');
          console.log('ğŸ“Š Respuesta de GupShup:', JSON.stringify(response.data));
          whatsappSuccess = true;
        } else {
          console.error(`âŒ Error en la respuesta de GupShup: ${response.status}`);
          whatsappError = `Error HTTP: ${response.status}`;
        }
      } catch (apiError) {
        console.error('âŒ Error en la llamada a la API de GupShup:', apiError.message);
        
        if (apiError.response) {
          console.error('ğŸ“Š Detalles del error:', apiError.response.status, JSON.stringify(apiError.response.data || {}));
          whatsappError = `Error HTTP ${apiError.response.status}: ${JSON.stringify(apiError.response.data || {})}`;
        } else if (apiError.request) {
          console.error('ğŸ“Š No se recibiÃ³ respuesta:', apiError.request);
          whatsappError = 'No se recibiÃ³ respuesta del servidor de GupShup';
        } else {
          console.error('ğŸ“Š Error en la configuraciÃ³n:', apiError.message);
          whatsappError = apiError.message;
        }
      }
  } catch (error) {
      console.error('âŒ Error general al enviar mensaje a WhatsApp:', error.message);
      whatsappError = error.message;
      // No fallamos la peticiÃ³n principal por un error en el envÃ­o a WhatsApp
    }
    
    return res.status(200).json({
      success: true,
      id: messageResult.id,
      message: 'Mensaje enviado y bot desactivado correctamente',
      bot_status: 'deactivated',
      sent_to_whatsapp: whatsappSuccess,
      whatsapp_error: whatsappError
    });
  } catch (error) {
    console.error('âŒ Error general al procesar mensaje:', error);
    return res.status(500).json({ error: error.message });
  }
});

// Endpoint para verificar que el servidor estÃ¡ activo y configurado
app.get('/api/status', (req, res) => {
  res.status(200).json({
    status: 'online',
    version: '1.0',
    gupshupConfigured: !!GUPSHUP_API_KEY && !!GUPSHUP_NUMBER,
    openaiConfigured: !!OPENAI_API_KEY && !!ASSISTANT_ID
  });
});

// Endpoint para verificar que el servidor estÃ¡ funcionando
app.get('/', (req, res) => {
    res.status(200).json({
        status: "ok", 
        message: "WhatsApp API server is running",
        config: {
            control_panel: CONTROL_PANEL_URL
        }
    });
});

// Endpoint de prueba para simular un mensaje
app.post('/test-message', async (req, res) => {
  try {
    console.log('ğŸ“© Mensaje de prueba recibido:', JSON.stringify(req.body));
    
    const { message, sender } = req.body;
    
    if (!message || !sender) {
      return res.status(400).json({ error: 'Mensaje o remitente faltante' });
    }
    
    // Normalizar el ID del remitente
    const normalizedSender = String(sender).trim().replace(/_TEST.*$/i, '');
    console.log(`ğŸ‘¤ Mensaje de prueba recibido de ${normalizedSender}: ${message}`);
    
    // Guardar el mensaje del usuario en Supabase
    try {
      console.log(`ğŸ’¾ Guardando mensaje del usuario en Supabase: ${message}`);
      const userMessageResult = await global.registerBotResponse(normalizedSender, message, BUSINESS_ID, 'user');
      
      if (userMessageResult && userMessageResult.success) {
        console.log('âœ… Mensaje del usuario guardado correctamente en Supabase');
      } else {
        console.error('âŒ Error al guardar mensaje del usuario en Supabase');
      }
    } catch (supabaseUserError) {
      console.error('âŒ Error al guardar mensaje del usuario:', supabaseUserError.message);
      // No interrumpimos el flujo principal por un error en el registro
    }
    
    // Enviar mensaje a OpenAI
    const response = await processMessageWithOpenAI(normalizedSender, message);
    
    // Guardar la respuesta del bot en Supabase
    try {
      console.log(`ğŸ”„ Intentando registrar respuesta del bot con business_id: ${BUSINESS_ID}`);
      
      // Usar la funciÃ³n global registerBotResponse para guardar en Supabase
      const result = await global.registerBotResponse(normalizedSender, response, BUSINESS_ID, 'bot');
      
      // Verificar resultado
      if (result && result.success === true) {
        console.log(`âœ… Respuesta del bot guardada correctamente en Supabase`);
      } else {
        console.error(`âŒ Error al guardar respuesta del bot en Supabase: ${result?.error || 'Error desconocido'}`);
      }
    } catch (controlPanelError) {
      console.error(`âŒ Error al registrar respuesta del bot en Supabase:`, controlPanelError.message);
    }
    
    // Solo devolver la respuesta, no enviar a WhatsApp
    return res.status(200).json({ 
      success: true,
      message: response,
      sender: sender
    });
  } catch (error) {
    console.error('âŒ Error procesando mensaje de prueba:', error.message);
    return res.status(500).json({ error: error.message });
  }
});

// Endpoint para obtener conversaciones por ID de negocio
app.get('/api/conversations/business/:businessId', async (req, res) => {
  try {
    const { businessId } = req.params;
    console.log(`ğŸ” Buscando conversaciones para el negocio: ${businessId}`);
    
    // Cargar directamente la configuraciÃ³n de Supabase para asegurar que siempre use valores correctos
    const supabaseConfig = require('./supabase-config');
    const supabaseUrl = process.env.SUPABASE_URL || supabaseConfig.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_KEY || supabaseConfig.SUPABASE_KEY;
    
    // Construir la URL para consultar las conversaciones
    const url = `${supabaseUrl}/rest/v1/conversations?business_id=eq.${businessId}&order=last_message_time.desc`;
    
    // Realizar la consulta a Supabase
    const response = await axios.get(url, {
      headers: {
        'apikey': supabaseKey,
        'Authorization': `Bearer ${supabaseKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const conversations = response.data;
    console.log(`âœ… Se encontraron ${conversations.length} conversaciones para el negocio ${businessId}`);
    
    return res.status(200).json(conversations);
  } catch (error) {
    console.error('âŒ Error al obtener conversaciones:', error.message);
    if (error.response) {
      console.error('  Status:', error.response.status);
      console.error('  Data:', error.response.data);
    }
    return res.status(500).json({ error: 'Error al obtener conversaciones' });
  }
});

// Endpoint para obtener mensajes de una conversaciÃ³n especÃ­fica
app.get('/api/messages/:conversationId', async (req, res) => {
    try {
    const conversationId = req.params.conversationId;
    console.log(`ğŸ” Solicitando mensajes para conversaciÃ³n/nÃºmero: ${conversationId}`);
    
    if (!conversationId) {
      return res.status(400).json({ error: 'Se requiere ID de conversaciÃ³n o nÃºmero de telÃ©fono' });
    }
    
    // Determinar si es un UUID (ID de conversaciÃ³n) o un nÃºmero de telÃ©fono
    const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(conversationId);
    const isPhoneNumber = /^\+?\d+$/.test(conversationId);
    
    console.log(`ğŸ” Tipo de ID proporcionado: ${isUUID ? 'UUID' : isPhoneNumber ? 'NÃºmero de telÃ©fono' : 'Desconocido'}`);
    
    // Cargar directamente la configuraciÃ³n de Supabase para asegurar que siempre use valores correctos
    const supabaseConfig = require('./supabase-config');
    const supabaseUrl = process.env.SUPABASE_URL || supabaseConfig.SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_KEY || supabaseConfig.SUPABASE_KEY;
    
    // Variable para almacenar el ID real de la conversaciÃ³n
    let actualConversationId = conversationId;
    
    // Si es un nÃºmero de telÃ©fono, necesitamos encontrar el ID de conversaciÃ³n
    if (isPhoneNumber) {
      console.log(`ğŸ” Buscando ID de conversaciÃ³n para el nÃºmero de telÃ©fono: ${conversationId}`);
      
      // Normalizar el nÃºmero (eliminar el sÃ­mbolo + si existe)
      const normalizedPhone = conversationId.replace(/^\+/, '');
      
      // Primero verificar en la cachÃ©
      if (phoneToConversationMap[normalizedPhone]) {
        actualConversationId = phoneToConversationMap[normalizedPhone];
        console.log(`âœ… ID de conversaciÃ³n encontrado en cachÃ©: ${actualConversationId}`);
      } else {
        // Buscar en la base de datos
        try {
          // Consultar Supabase para encontrar la conversaciÃ³n asociada al nÃºmero
          const conversationUrl = `${supabaseUrl}/rest/v1/conversations?user_id=eq.${normalizedPhone}&business_id=eq.${BUSINESS_ID}&order=created_at.desc&limit=1`;
          
          const conversationResponse = await axios.get(conversationUrl, {
          headers: {
              'apikey': supabaseKey,
              'Authorization': `Bearer ${supabaseKey}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (conversationResponse.data && conversationResponse.data.length > 0) {
            actualConversationId = conversationResponse.data[0].id;
            console.log(`âœ… ID de conversaciÃ³n encontrado en DB: ${actualConversationId}`);
            
            // Actualizar cachÃ© para futuras referencias
            phoneToConversationMap[normalizedPhone] = actualConversationId;
            conversationIdToPhoneMap[actualConversationId] = normalizedPhone;
            console.log(`ğŸ“ CachÃ© actualizada para futuras referencias`);
          } else {
            console.log(`âš ï¸ No se encontrÃ³ ninguna conversaciÃ³n para el nÃºmero: ${normalizedPhone}`);
            return res.status(404).json({
              error: `No se encontrÃ³ ninguna conversaciÃ³n asociada al nÃºmero ${conversationId}`,
              conversationId: conversationId,
              isPhoneNumber: true
            });
          }
        } catch (dbError) {
          console.error('âŒ Error buscando conversaciÃ³n:', dbError.message);
          return res.status(500).json({ error: 'Error buscando conversaciÃ³n' });
        }
      }
    }
    
    // Ahora tenemos el ID real de la conversaciÃ³n, podemos obtener los mensajes
    console.log(`ğŸ” Obteniendo mensajes para ID de conversaciÃ³n: ${actualConversationId}`);
    
    // Construir la URL para consultar los mensajes
    const url = `${supabaseUrl}/rest/v1/messages?conversation_id=eq.${actualConversationId}&order=created_at.asc`;
    
    // Realizar la consulta a Supabase
    const response = await axios.get(url, {
        headers: {
        'apikey': supabaseKey,
        'Authorization': `Bearer ${supabaseKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const messages = response.data;
    console.log(`âœ… Encontrados ${messages.length} mensajes para la conversaciÃ³n ${actualConversationId}`);
    
    // AÃ±adir informaciÃ³n adicional para ayudar en la depuraciÃ³n
    return res.status(200).json({
      messages: messages,
      conversationId: conversationId,
      actualConversationId: actualConversationId,
      isPhoneNumber: isPhoneNumber,
      isUUID: isUUID
        });
    } catch (error) {
    console.error('âŒ Error al obtener mensajes:', error.message);
    if (error.response) {
      console.error('  Status:', error.response.status);
      console.error('  Data:', error.response.data);
    }
    return res.status(500).json({ error: 'Error al obtener mensajes' });
    }
});

// Nueva ruta para buscar conversaciÃ³n por nÃºmero de telÃ©fono
app.get('/api/conversation/phone/:phoneNumber', async (req, res) => {
    try {
        console.log(`ğŸ” Buscando conversaciÃ³n para nÃºmero: ${req.params.phoneNumber}`);
        
        const { data, error } = await supabase
            .from('conversations')
            .select('*')
            .eq('user_id', req.params.phoneNumber)
            .single();
        
        if (error) {
            console.log(`âŒ Error buscando conversaciÃ³n: ${error.message}`);
            return res.status(400).json({
                error: 'Error buscando conversaciÃ³n',
                details: error.message
            });
        }
        
        if (!data) {
            return res.status(404).json({
                error: 'ConversaciÃ³n no encontrada',
                details: `No se encontrÃ³ conversaciÃ³n para el nÃºmero ${req.params.phoneNumber}`
            });
        }
        
        console.log(`âœ… ConversaciÃ³n encontrada: ${data.id}`);
        return res.json({
            success: true,
            conversation: data
        });
    } catch (error) {
        console.log(`âŒ Error general: ${error.message}`);
        return res.status(500).json({
            error: 'Error del servidor',
            details: error.message
        });
    }
});

// Endpoint para activar/desactivar el bot para una conversaciÃ³n especÃ­fica (acepta PUT y POST)
app.put('/api/conversations/:id/toggle-bot', handleToggleBot);
app.post('/api/conversations/:id/toggle-bot', handleToggleBot);

// FunciÃ³n de manejo para toggle-bot
async function handleToggleBot(req, res) {
    try {
        logDebug(`ğŸ¤– TOGGLE BOT - Iniciando cambio de estado para conversaciÃ³n ${req.params.id}`);
        
        const { id } = req.params;
        const { active } = req.body;
        
        if (!id) {
            logDebug(`âŒ TOGGLE BOT - ID de conversaciÃ³n faltante`);
            return res.status(400).json({ error: 'Se requiere ID de conversaciÃ³n' });
        }
        
        logDebug(`ğŸ”„ TOGGLE BOT - Solicitando cambio a: ${active ? 'ACTIVO' : 'INACTIVO'} para conversaciÃ³n ${id}`);
        
        // Obtener datos de la conversaciÃ³n para verificar que existe
        const { data: convData, error: convError } = await supabase
            .from('conversations')
            .select('id, user_id, business_id')
            .eq('id', id)
            .single();
            
        if (convError) {
            logDebug(`âŒ TOGGLE BOT - Error obteniendo datos de conversaciÃ³n: ${convError.message}`);
            return res.status(404).json({ error: 'ConversaciÃ³n no encontrada', details: convError.message });
        }
        
        if (!convData) {
            logDebug(`âŒ TOGGLE BOT - ConversaciÃ³n ${id} no existe en la base de datos`);
            return res.status(404).json({ error: 'ConversaciÃ³n no encontrada' });
        }
        
        // Actualizar estado del bot en la base de datos
        const { data, error } = await supabase
            .from('conversations')
            .update({ is_bot_active: active })
            .eq('id', id)
            .select('id, user_id, is_bot_active')
            .single();
            
        if (error) {
            logDebug(`âŒ TOGGLE BOT - Error actualizando estado: ${error.message}`);
            return res.status(500).json({ 
                error: 'Error al actualizar estado del bot', 
                details: error.message 
            });
        }
        
        logDebug(`âœ… TOGGLE BOT - Estado actualizado en DB: is_bot_active=${active} para conversaciÃ³n ${id}`);
        
        // Actualizar cachÃ©
        if (data && data.user_id) {
            senderBotStatusMap[data.user_id] = active;
            logDebug(`ğŸ“ TOGGLE BOT - CachÃ© actualizada: senderBotStatusMap[${data.user_id}] = ${active}`);
        }
        
        // En desarrollo, mostrar todos los mapeos actualizados
        if (process.env.NODE_ENV !== 'production') {
            logDebug('ğŸ“Š TOGGLE BOT - Estado actual de cache:');
            Object.keys(senderBotStatusMap).forEach(key => {
                logDebug(`   - ${key}: ${senderBotStatusMap[key] ? 'ACTIVO' : 'INACTIVO'}`);
            });
        }
        
        return res.status(200).json({ 
            success: true, 
            is_bot_active: active, 
            message: `Bot ${active ? 'activado' : 'desactivado'} exitosamente`,
            conversation_id: id,
            user_id: data.user_id
        });
    } catch (error) {
        logDebug(`âŒ TOGGLE BOT - Error general: ${error.message}`);
        return res.status(500).json({ 
            error: 'Error al procesar la solicitud', 
            message: error.message 
        });
    }
}

// Endpoint para verificar el estado actual del bot
app.get('/api/bot-status/:id', handleBotStatus);

// FunciÃ³n para manejar la verificaciÃ³n del estado del bot
async function handleBotStatus(req, res) {
    try {
        const { id } = req.params;
        
        if (!id) {
            return res.status(400).json({ error: 'Se requiere ID de conversaciÃ³n o nÃºmero de telÃ©fono' });
        }
        
        logDebug(`ğŸ” Verificando estado del bot para: ${id}`);
        
        // Verificar si es un UUID o un nÃºmero de telÃ©fono
        const isUUID = id.includes('-');
        
        let query;
        if (isUUID) {
            // Es un ID de conversaciÃ³n
            query = supabase
                .from('conversations')
                .select('id, user_id, is_bot_active, last_message_time')
                .eq('id', id);
        } else {
            // Es un nÃºmero de telÃ©fono
            query = supabase
                .from('conversations')
                .select('id, user_id, is_bot_active, last_message_time')
                .eq('user_id', id);
        }
        
        const { data, error } = await query;
        
        if (error) {
            logDebug(`âŒ Error consultando estado del bot: ${error.message}`);
            return res.status(500).json({ 
                error: 'Error al consultar estado', 
                details: error.message 
            });
        }
        
        if (!data || data.length === 0) {
            logDebug(`âš ï¸ No se encontrÃ³ conversaciÃ³n para: ${id}`);
            return res.status(404).json({ 
                error: 'ConversaciÃ³n no encontrada', 
                id 
            });
        }
        
        // Obtener el estado del cache tambiÃ©n
        const cacheStatus = isUUID 
            ? (data[0].user_id ? senderBotStatusMap[data[0].user_id] : undefined)
            : senderBotStatusMap[id];
        
        logDebug(`âœ… Estado encontrado para ${id}:`);
        logDebug(`   - DB: ${data.map(c => `${c.id}=${c.is_bot_active}`).join(', ')}`);
        logDebug(`   - Cache: ${cacheStatus !== undefined ? cacheStatus : 'no en cachÃ©'}`);
        
        return res.status(200).json({
            success: true,
            conversations: data.map(conv => ({
                id: conv.id,
                user_id: conv.user_id,
                is_bot_active: conv.is_bot_active,
                last_message_time: conv.last_message_time,
                cache_status: conv.user_id ? senderBotStatusMap[conv.user_id] : undefined
            })),
            cache_status: cacheStatus
        });
  } catch (error) {
        logDebug(`âŒ Error general en bot-status: ${error.message}`);
        return res.status(500).json({ 
            error: 'Error al procesar la solicitud', 
            message: error.message 
        });
    }
}

// Endpoint para simular el procesamiento con OpenAI sin enviar a WhatsApp
app.post('/api/simulate-openai/:id', handleSimulateOpenAI);

// FunciÃ³n para manejar la simulaciÃ³n
async function handleSimulateOpenAI(req, res) {
    try {
        const { id } = req.params;
        const { message } = req.body;
        
        if (!id) {
            return res.status(400).json({ error: 'Se requiere ID de conversaciÃ³n o nÃºmero de telÃ©fono' });
        }
        
        if (!message) {
            return res.status(400).json({ error: 'Se requiere un mensaje para procesar' });
        }
        
        logDebug(`ğŸ”¬ SIMULACIÃ“N - Procesando mensaje para ${id}: "${message}"`);
        
        // Sobreescribir temporalmente sendWhatsAppResponse para capturar respuesta
        const originalSendWhatsApp = sendWhatsAppResponse;
        let capturedResponse = null;
        
        sendWhatsAppResponse = async (recipient, response) => {
            logDebug(`ğŸ“ SIMULACIÃ“N - Capturando respuesta: "${response.substring(0, 100)}${response.length > 100 ? '...' : ''}"`);
            capturedResponse = response;
            return true; // Simular Ã©xito
        };
        
        try {
            // Si es un UUID (ID de conversaciÃ³n)
            const isUUID = id.includes('-');
            let userId = id;
            let conversationId = isUUID ? id : null;
            
            // Si es un ID de conversaciÃ³n, obtener el user_id
            if (isUUID) {
                const { data, error } = await supabase
                    .from('conversations')
                    .select('user_id')
                    .eq('id', id)
                    .single();
                    
                if (error || !data) {
                    return res.status(404).json({ error: 'ConversaciÃ³n no encontrada' });
                }
                
                userId = data.user_id;
            } 
            // Si es un nÃºmero de telÃ©fono, buscar la conversaciÃ³n correspondiente
            else {
                const { data, error } = await supabase
                    .from('conversations')
                    .select('id')
                    .eq('user_id', id)
                    .order('created_at', { ascending: false })
                    .limit(1);
                    
                if (!error && data && data.length > 0) {
                    conversationId = data[0].id;
                }
            }
            
            // Guardar estado original del bot para este usuario
            const originalBotStatus = senderBotStatusMap[userId];
            
            // Forzar estado activo para la simulaciÃ³n
            senderBotStatusMap[userId] = true;
            logDebug(`ğŸ¤– SIMULACIÃ“N - Forzando bot ACTIVO temporalmente para ${userId}`);
            
            // Procesar con OpenAI
            const response = await processMessageWithOpenAI(userId, message, conversationId);
            
            // Restaurar estado original
            senderBotStatusMap[userId] = originalBotStatus;
            logDebug(`ğŸ”„ SIMULACIÃ“N - Restaurando estado original del bot: ${originalBotStatus ? 'ACTIVO' : 'INACTIVO'}`);
            
            // Restaurar funciÃ³n original
            sendWhatsAppResponse = originalSendWhatsApp;
            
            if (capturedResponse) {
                return res.status(200).json({
                    success: true,
                    message: 'SimulaciÃ³n exitosa',
                    response: capturedResponse,
                    user_id: userId,
                    conversation_id: conversationId
                });
    } else {
                return res.status(500).json({
                    success: false,
                    message: 'No se pudo generar una respuesta'
                });
            }
        } finally {
            // Asegurar que la funciÃ³n original se restaure incluso si hay error
            sendWhatsAppResponse = originalSendWhatsApp;
    }
  } catch (error) {
        logDebug(`âŒ SIMULACIÃ“N - Error: ${error.message}`);
        return res.status(500).json({
            error: 'Error al procesar la simulaciÃ³n',
            message: error.message
        });
    }
}

// Configurar el registro en archivo de depuraciÃ³n
const debugLogFile = path.join(__dirname, 'debug.log');
const logDebug = (message) => {
  const timestamp = new Date().toISOString();
  const logMessage = `${timestamp} - ${message}\n`;
  fs.appendFileSync(debugLogFile, logMessage);
  console.log(message); // TambiÃ©n mantener los logs en la consola
};

// TambiÃ©n reemplazar algunas instancias clave de console.log con logDebug
// ... existing code ...

// Endpoint para pruebas de GupShup API
app.get('/api/test-gupshup', async (req, res) => {
  try {
    console.log('ğŸ” Probando credenciales de GupShup...');
    
    // Mostrar informaciÃ³n de configuraciÃ³n
    console.log(`ğŸ”‘ API Key: ${GUPSHUP_API_KEY ? 'Configurada (primeros 10 caracteres: ' + GUPSHUP_API_KEY.substring(0, 10) + '...)' : 'No configurada'}`);
    console.log(`ğŸ“± NÃºmero: ${GUPSHUP_NUMBER || 'No configurado'}`);
    console.log(`ğŸ‘¤ User ID: ${GUPSHUP_USERID ? 'Configurado (primeros 10 caracteres: ' + GUPSHUP_USERID.substring(0, 10) + '...)' : 'No configurado'}`);
    
    // Probar conexiÃ³n a GupShup - Verificar estado de la cuenta
    const apiUrl = 'https://api.gupshup.io/wa/api/v1/users/info';
    
    const headers = {
      'apikey': GUPSHUP_API_KEY,
      'Content-Type': 'application/json'
    };
    
    console.log('ğŸ”„ Realizando solicitud a GupShup...');
    
    try {
      const response = await axios.get(apiUrl, { headers });
      
      console.log(`âœ… ConexiÃ³n exitosa a GupShup: ${response.status}`);
      console.log(`ğŸ“Š Datos recibidos: ${JSON.stringify(response.data)}`);
      
      return res.json({
        success: true,
        status: 'ConexiÃ³n exitosa',
        message: 'Las credenciales de GupShup son vÃ¡lidas',
        apiResponse: response.data
      });
    } catch (apiError) {
      console.log(`âŒ Error al conectar con GupShup: ${apiError.message}`);
      
      let errorDetails = {
        message: apiError.message
      };
      
      if (apiError.response) {
        errorDetails.status = apiError.response.status;
        errorDetails.data = apiError.response.data;
        console.log(`âŒ Respuesta de error: ${apiError.response.status} - ${JSON.stringify(apiError.response.data)}`);
      }
      
      return res.status(500).json({
        success: false,
        status: 'Error de conexiÃ³n',
        message: 'FallÃ³ la conexiÃ³n con GupShup',
        error: errorDetails
      });
    }
  } catch (error) {
    console.error(`âŒ Error general: ${error.message}`);
    return res.status(500).json({
      success: false,
      status: 'Error',
      message: error.message
    });
  }
});

// ... existing code ...

// Endpoint para actualizar credenciales de GupShup
app.post('/api/update-gupshup-credentials', async (req, res) => {
  try {
    const { apiKey, number, userId } = req.body;
    
    console.log('ğŸ”„ Actualizando credenciales de GupShup...');
    
    // Comprobar que se proporcionaron los datos necesarios
    if (!apiKey && !number && !userId) {
      return res.status(400).json({
        success: false,
        message: 'Debe proporcionar al menos una credencial para actualizar (apiKey, number o userId)'
      });
    }
    
    // Guardar valores anteriores para poder restaurarlos en caso de error
    const previousApiKey = GUPSHUP_API_KEY;
    const previousNumber = GUPSHUP_NUMBER;
    const previousUserId = GUPSHUP_USERID;
    
    // Actualizar las variables globales con los nuevos valores
    if (apiKey) {
      console.log(`ğŸ”‘ Actualizando API Key: ${apiKey.substring(0, 8)}...`);
      GUPSHUP_API_KEY = apiKey;
    }
    
    if (number) {
      console.log(`ğŸ“± Actualizando nÃºmero: ${number}`);
      GUPSHUP_NUMBER = number;
    }
    
    if (userId) {
      console.log(`ğŸ‘¤ Actualizando User ID: ${userId.substring(0, 8)}...`);
      GUPSHUP_USERID = userId;
    }
    
    // Probar conexiÃ³n a GupShup con las nuevas credenciales
    const apiUrl = 'https://api.gupshup.io/wa/api/v1/users/info';
    
    const headers = {
      'apikey': GUPSHUP_API_KEY,
      'Content-Type': 'application/json'
    };
    
    console.log('ğŸ”„ Probando conexiÃ³n con nuevas credenciales...');
    
    try {
      const response = await axios.get(apiUrl, { headers });
      
      console.log(`âœ… ConexiÃ³n exitosa con nuevas credenciales: ${response.status}`);
      console.log(`ğŸ“Š Datos recibidos: ${JSON.stringify(response.data)}`);
      
      return res.json({
        success: true,
        message: 'Credenciales actualizadas correctamente',
        updatedCredentials: {
          apiKey: apiKey ? `${apiKey.substring(0, 8)}...` : 'No actualizada',
          number: number || 'No actualizado',
          userId: userId ? `${userId.substring(0, 8)}...` : 'No actualizado'
        },
        apiResponse: response.data
      });
    } catch (apiError) {
      // Restaurar valores anteriores en caso de error
      console.log(`âŒ Error al conectar con nuevas credenciales: ${apiError.message}`);
      console.log('ğŸ”„ Restaurando credenciales anteriores...');
      
      GUPSHUP_API_KEY = previousApiKey;
      GUPSHUP_NUMBER = previousNumber;
      GUPSHUP_USERID = previousUserId;
      
      let errorDetails = {
        message: apiError.message
      };
      
      if (apiError.response) {
        errorDetails.status = apiError.response.status;
        errorDetails.data = apiError.response.data;
        console.log(`âŒ Respuesta de error: ${apiError.response.status} - ${JSON.stringify(apiError.response.data)}`);
      }
      
      return res.status(500).json({
        success: false,
        message: 'Error al conectar con GupShup usando las nuevas credenciales',
        error: errorDetails
      });
    }
  } catch (error) {
    console.error(`âŒ Error general: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// ... existing code ...

// Endpoint para enviar mensajes manuales desde el dashboard
app.post('/api/send-manual-message', async (req, res) => {
  console.log('ğŸ“ Recibida solicitud para enviar mensaje manual:', JSON.stringify(req.body));
  
  try {
    const { phoneNumber, message, mediaUrl, caption, content } = req.body;
    
    // Validar campos requeridos
    if (!phoneNumber || !phoneNumber.trim()) {
      console.error('âŒ Error: No se proporcionÃ³ nÃºmero de telÃ©fono');
      return res.status(400).json({ 
        success: false, 
        error: 'Se requiere nÃºmero de telÃ©fono' 
      });
    }
    
    // Permitir que el mensaje venga en 'message' o 'content' para mayor compatibilidad
    const messageContent = message || content || '';
    if (!messageContent.trim() && !mediaUrl) {
      console.error('âŒ Error: No se proporcionÃ³ mensaje ni media');
      return res.status(400).json({ 
        success: false, 
        error: 'Se requiere mensaje o URL de media' 
      });
    }
    
    // Formatear nÃºmero de telÃ©fono (eliminar espacios, guiones, etc.)
    let formattedPhone = phoneNumber.replace(/\D/g, '');
    
    // Asegurarse de que tenga el formato correcto para WhatsApp
    if (formattedPhone.endsWith('@c.us')) {
      // Si tiene @c.us al final, quitarlo para usar con GupShup
      formattedPhone = formattedPhone.replace('@c.us', '');
    }
    
    // Agregar cÃ³digo de paÃ­s si no lo tiene
    if (formattedPhone.length <= 10) {
      formattedPhone = `521${formattedPhone}`;
    }
    
    console.log(`ğŸ“± Enviando mensaje a: ${formattedPhone}`);
    console.log(`ğŸ’¬ Mensaje: ${messageContent}`);
    
    // Si hay URL de media, enviar mensaje con media
    if (mediaUrl) {
      console.log(`ğŸ–¼ï¸ Enviando mensaje con imagen a ${formattedPhone}`);
      console.log(`ğŸ–¼ï¸ URL de imagen: ${mediaUrl}`);
      
      try {
        // Usar la funciÃ³n de envÃ­o de media GupShup
        const captionText = caption || messageContent || '';
        const result = await sendMediaMessageGupShup(formattedPhone, mediaUrl, captionText);
        
        console.log('âœ… Mensaje con media enviado con Ã©xito usando GupShup');
        return res.json({
          success: true,
          message: 'Mensaje con media enviado con Ã©xito',
          details: result
        });
      } catch (mediaError) {
        console.error('âŒ Error al enviar mensaje con media:', mediaError);
        
        // Si falla el envÃ­o con media, intentar enviar solo el texto
        if (messageContent.trim()) {
          try {
            const textResult = await sendTextMessageGupShup(formattedPhone, messageContent);
            console.log('âœ… Se enviÃ³ el mensaje de texto (sin la imagen)');
            
        return res.json({
          success: true,
              message: 'Mensaje de texto enviado (sin la imagen)', 
              warning: 'No se pudo enviar la imagen',
              details: textResult
        });
      } catch (textError) {
            throw new Error(`Error al enviar texto despuÃ©s de fallo de media: ${textError.message}`);
      }
    } else {
          throw new Error('No se pudo enviar el mensaje con media y no hay texto alternativo');
        }
      }
    } else {
      // Enviar mensaje de texto normal con GupShup
      try {
        const result = await sendTextMessageGupShup(formattedPhone, messageContent);
        console.log('âœ… Mensaje de texto enviado con Ã©xito');
        
        return res.json({ 
          success: true, 
          message: 'Mensaje enviado con Ã©xito',
          details: result
        });
      } catch (textError) {
        throw new Error(`Error al enviar mensaje de texto: ${textError.message}`);
      }
    }
  } catch (error) {
    console.error('âŒ Error al enviar mensaje manual:', error);
    res.status(500).json({ 
      success: false,
      error: error.message || 'Error interno del servidor' 
    });
  }
});

// FunciÃ³n para enviar mensajes de texto a WhatsApp
async function sendWhatsAppTextMessage(phoneNumber, message) {
  console.log(`ğŸ“¤ Enviando mensaje de texto a ${phoneNumber}: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
  
  try {
    const response = await axios.post(
      'https://api.gupshup.io/sm/api/v1/msg',
      `channel=whatsapp&source=${GUPSHUP_NUMBER}&destination=${phoneNumber}&message=${encodeURIComponent(message)}&disablePreview=false&source=${GUPSHUP_NUMBER}`,
      {
        headers: {
          'Cache-Control': 'no-cache',
          'Content-Type': 'application/x-www-form-urlencoded',
          'apikey': GUPSHUP_API_KEY,
          'Accept': 'application/json'
        }
      }
    );
    
    console.log('âœ… Respuesta de GupShup al enviar texto:', JSON.stringify(response.data));
    return true;
  } catch (error) {
    console.error('âŒ Error en sendWhatsAppTextMessage:', error.message);
    throw error;
  }
}

async function sendMediaMessage(recipient, mediaUrl, caption = '') {
    try {
        console.log(`ğŸ“¤ Enviando media a ${recipient} - URL: ${mediaUrl}`);
        
        if (!recipient || !mediaUrl) {
            console.error('âŒ Error: Destinatario o URL de media faltantes');
            return false;
        }
        
        // Formatear el nÃºmero (eliminar + al principio si existe)
        const formattedNumber = recipient.startsWith('+') 
            ? recipient.substring(1) 
            : recipient;
        
        // Verificar que el nÃºmero contenga solo dÃ­gitos
        if (!/^\d+$/.test(formattedNumber)) {
            console.error(`âŒ NÃºmero invÃ¡lido: ${formattedNumber}`);
            return false;
        }
        
        // Verificar la URL
        if (!mediaUrl.startsWith('http')) {
            console.error(`âŒ URL de imagen invÃ¡lida: ${mediaUrl}`);
            return false;
        }
        
        // Verificar credenciales de GupShup
        if (!GUPSHUP_API_KEY || !GUPSHUP_NUMBER || !GUPSHUP_USERID) {
            console.error('âŒ CREDENCIALES FALTANTES:', {
                apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
                number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
                userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA'
            });
            return false;
        }
        
        // API v1 de GupShup
        const apiUrl = 'https://api.gupshup.io/wa/api/v1/msg';
        const apiKey = GUPSHUP_API_KEY;
        const source = GUPSHUP_NUMBER;
        
        console.log(`ğŸ”‘ Usando API Key para media: ${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 5)}`);
        console.log(`ğŸ“± Usando nÃºmero en GupShup: ${source}`);
        console.log(`ğŸ“± Hacia nÃºmero: ${formattedNumber}`);
        
        // Crear el mensaje para imagen
        const mediaMessage = {
            type: "image",
            originalUrl: mediaUrl,
            previewUrl: mediaUrl,
            caption: caption || ""
        };
        
        const formData = new URLSearchParams();
        formData.append('channel', 'whatsapp');
        formData.append('source', source);
        formData.append('destination', formattedNumber);
        formData.append('src.name', source);
        formData.append('message', JSON.stringify(mediaMessage));
        
        const headers = {
            'Cache-Control': 'no-cache',
            'Content-Type': 'application/x-www-form-urlencoded',
            'apikey': apiKey,
            'userid': GUPSHUP_USERID
        };
        
        console.log('ğŸ”„ Enviando imagen a WhatsApp...');
        console.log('ğŸ“¦ Payload:', JSON.stringify({
            message: mediaMessage,
            destination: formattedNumber
        }, null, 2));
        
        try {
            const response = await axios.post(apiUrl, formData, { headers });
            
            console.log('ğŸ“¡ Respuesta de GupShup Media:', JSON.stringify(response.data));
            
            if (response.status >= 200 && response.status < 300) {
                console.log('âœ… Imagen enviada exitosamente a WhatsApp');
                
                // Guardar mensaje en la base de datos
                try {
                    await global.registerBotResponse(
                        recipient,
                        caption || 'Imagen enviada',
                        BUSINESS_ID, 
                        'bot',
                        mediaUrl
                    );
                    console.log('âœ… Mensaje media guardado en Supabase');
                } catch (dbError) {
                    console.error(`âš ï¸ Error guardando mensaje media en Supabase: ${dbError.message}`);
                }
                
                return true;
            } else {
                console.error(`âŒ Error: CÃ³digo de respuesta ${response.status}`);
                return false;
            }
        } catch (apiError) {
            console.error(`âŒ Error en solicitud de media a GupShup:`, apiError.message);
            
            if (apiError.response) {
                console.error(`- Status: ${apiError.response.status}`);
                console.error(`- Datos: `, JSON.stringify(apiError.response.data, null, 2));
                console.error(`- Headers: `, JSON.stringify(apiError.response.headers, null, 2));
            } else if (apiError.request) {
                console.error(`- No hubo respuesta del servidor`);
            } else {
                console.error(`- Error al configurar la solicitud:`, apiError.message);
            }
            
            // Intentar enviando como texto con el link
            console.log('âš ï¸ Fallback: Intentando enviar el enlace de la imagen como texto');
            await sendWhatsAppResponse(recipient, `No se pudo enviar la imagen directamente. AquÃ­ estÃ¡ el enlace: ${mediaUrl}\n\n${caption || ''}`);
            
            return false;
        }
    } catch (error) {
        console.error(`âŒ Error general en sendMediaMessage:`, error.message);
        console.error(error.stack);
        
        // Intentar enviando como texto con el link
        console.log('âš ï¸ Fallback: Enviando enlace como texto despuÃ©s de error general');
        await sendWhatsAppResponse(recipient, `No se pudo enviar la imagen. AquÃ­ estÃ¡ el enlace: ${mediaUrl}\n\n${caption || ''}`);
        
        return false;
    }
}

// FunciÃ³n para manejar mensajes con imÃ¡genes
async function handleMediaMessage(req, res) {
    try {
        console.log('âš™ï¸ Procesando webhook de imagen en WhatsApp');
        
        // Extraer datos del cuerpo del mensaje
        const webhookData = req.body;
        console.log('ğŸ“¦ Datos del webhook:', JSON.stringify(webhookData, null, 2));
        
        if (!webhookData || !webhookData.payload) {
            console.error('âŒ Estructura de webhook no vÃ¡lida');
            return res.status(400).json({ error: 'Estructura de webhook no vÃ¡lida' });
        }
        
        // Extraer informaciÃ³n del payload
        const { payload } = webhookData;
        const { sender, type } = payload;
        
        if (!sender || !sender.phone) {
            console.error('âŒ No se encontrÃ³ informaciÃ³n del remitente');
            return res.status(400).json({ error: 'No se encontrÃ³ informaciÃ³n del remitente' });
        }
        
        // Obtener el nÃºmero de telÃ©fono del remitente
        const senderPhone = sender.phone;
        console.log(`ğŸ“± NÃºmero del remitente: ${senderPhone}`);
        
        // Guardar mensaje en la base de datos si es un mensaje de tipo imagen
        if (type === 'image' && payload.payload && payload.payload.url) {
            try {
                const imageUrl = payload.payload.url;
                const caption = payload.payload.caption || '';
                
                console.log(`ğŸ–¼ï¸ URL de la imagen recibida: ${imageUrl}`);
                console.log(`ğŸ“ Caption: ${caption}`);
                
                // Registramos el mensaje en la base de datos
                await global.registerMessage(
                    senderPhone,
                    caption || 'Imagen recibida',
                    BUSINESS_ID,
                    'customer',
                    imageUrl  // Incluimos la URL de la imagen
                );
                
                console.log('âœ… Mensaje con imagen guardado en Supabase');
                
                // Respondemos al webhook
                res.status(200).json({ success: true });
                
                // Enviar a la API de procesamiento
                await processImage(senderPhone, imageUrl, caption);
                
                return;
            } catch (error) {
                console.error('âŒ Error procesando imagen:', error.message);
                return res.status(500).json({ error: 'Error procesando imagen' });
            }
        } else {
            console.log('âš ï¸ No es un mensaje de tipo imagen o falta URL');
            return res.status(400).json({ error: 'No es un mensaje de imagen o falta URL' });
        }
    } catch (error) {
        console.error('âŒ Error general en handleMediaMessage:', error.message);
        console.error(error.stack);
        return res.status(500).json({ error: 'Error interno del servidor' });
    }
}

// FunciÃ³n para procesar imÃ¡genes recibidas
async function processImage(senderPhone, imageUrl, caption = '') {
    try {
        console.log(`ğŸ”„ Procesando imagen de ${senderPhone}: ${imageUrl}`);
        
        // AquÃ­ puedes implementar lÃ³gica para procesar la imagen
        // Por ejemplo, enviarla a un servicio de IA para anÃ¡lisis
        
        // Por ahora, simplemente enviamos un mensaje de confirmaciÃ³n
        await sendWhatsAppResponse(
            senderPhone,
            `âœ… Hemos recibido tu imagen. La estamos procesando...`
        );
        
        // Simular respuesta despuÃ©s de "procesar" la imagen
        setTimeout(async () => {
            await sendWhatsAppResponse(
                senderPhone,
                `ğŸ“¸ Imagen procesada correctamente.\n${caption ? `Tu mensaje: "${caption}"` : ''}`
            );
        }, 2000);
        
        return true;
    } catch (error) {
        console.error('âŒ Error en processImage:', error.message);
        
        // Intentar enviar mensaje de error al usuario
        try {
            await sendWhatsAppResponse(
                senderPhone,
                "âŒ Lo sentimos, hubo un problema al procesar tu imagen. Por favor, intenta nuevamente mÃ¡s tarde."
            );
        } catch (sendError) {
            console.error('âŒ Error enviando mensaje de error:', sendError.message);
        }
        
        return false;
    }
}

// Extraer datos de mensajes multimedia de WebHook
function extractMediaData(webhookBody) {
    try {
        console.log(`ğŸ“¤ Extrayendo datos de mensaje multimedia`);
        
        if (!webhookBody || !webhookBody.payload) {
            return { error: 'Formato de webhook invÃ¡lido' };
        }
        
        // Extraer informaciÃ³n general
        const { payload } = webhookBody;
        
        // Verificar si es una actualizaciÃ³n de estado
        const isStatusUpdate = payload.type === 'status' || 
            payload.type === 'message-event' || 
            (webhookBody.type && webhookBody.type === 'message-event');
        
        if (isStatusUpdate) {
            return { isStatusUpdate: true };
        }
        
        // Extraer datos segÃºn el tipo de mensaje
        if (payload.type === 'image') {
            // Extraer datos de la imagen
            const sender = payload.sender && payload.sender.phone;
            const imageUrl = payload.payload && payload.payload.url;
            const caption = payload.payload && payload.payload.caption || '';
            const messageId = payload.messageId || payload.id;
            
            return {
                sender,
                messageId,
                isImage: true,
                imageUrl,
                caption,
                message: caption || 'Imagen recibida'
            };
        } else {
            // Para otros tipos, usar el extractor normal
            return extractMessageData(webhookBody);
        }
    } catch (error) {
        console.error(`âŒ Error extrayendo datos multimedia: ${error.message}`);
        return { error: error.message };
    }
}

// FunciÃ³n para manejar mensajes entrantes de texto
async function handleIncomingMessage(req, res) {
    try {
        const body = req.body;
        console.log(`ğŸ“© Mensaje recibido en webhook: ${JSON.stringify(body).substring(0, 500)}...`);
        
        // Extraer datos del mensaje
        const messageData = extractMessageData(body);
        
        // Si es una actualizaciÃ³n de estado, solo registrarla
        if (messageData.isStatusUpdate) {
            console.log(`ğŸ“Š NotificaciÃ³n de estado recibida, no requiere respuesta`);
            console.log(`ğŸ“Š Procesada notificaciÃ³n de estado`);
            return res.sendStatus(200);
        }
        
        const { sender, message, messageId } = messageData;
        
        if (!sender || !message) {
            console.log(`âš ï¸ Mensaje incompleto recibido, ignorando: ${JSON.stringify(messageData)}`);
            return res.sendStatus(200);
        }
        
        console.log(`ğŸ‘¤ Mensaje recibido de ${sender}: ${message}`);
        
        // Verificar si este mensaje ya fue procesado recientemente
        const messageKey = `${messageId || sender}_${message}`;
        if (recentlyProcessedMessages.has(messageKey)) {
            console.log(`âš ï¸ Mensaje duplicado detectado, ignorando: ${messageKey}`);
            return res.sendStatus(200);
        }
        
        // Marcar este mensaje como procesado
        recentlyProcessedMessages.add(messageKey);
        setTimeout(() => recentlyProcessedMessages.delete(messageKey), 60000); // Eliminar despuÃ©s de 1 minuto
        
        // Guardar mensaje en Supabase
        console.log(`ğŸ’¾ Guardando mensaje entrante para ${sender}`);
        let conversationId = null;
        
        try {
            // Verificar si tenemos un ID de conversaciÃ³n mapeado para este nÃºmero
            if (phoneToConversationMap[sender]) {
                conversationId = phoneToConversationMap[sender];
                console.log(`âœ… ID de conversaciÃ³n encontrado en cachÃ©: ${conversationId}`);
            }
            
            // Guardar mensaje del usuario en la base de datos usando registerBotResponse
            console.log(`ğŸ’¾ Guardando mensaje de tipo 'user' para: ${sender}`);
            
            const userMessageResult = await global.registerBotResponse(sender, message, BUSINESS_ID, 'user');
    
            if (userMessageResult && userMessageResult.success) {
                console.log('âœ… Mensaje guardado en Supabase correctamente');
                
                // Actualizar el ID de conversaciÃ³n con el retornado por la funciÃ³n
                if (userMessageResult.conversationId) {
                conversationId = userMessageResult.conversationId;
                    console.log(`âœ… Usando ID de conversaciÃ³n obtenido: ${conversationId}`);
                
                // Actualizar mapeo de conversaciÃ³n
                if (conversationId && sender) {
                    phoneToConversationMap[sender] = conversationId;
                    conversationIdToPhoneMap[conversationId] = sender;
                        console.log(`âœ… Mapeo actualizado: ${sender} -> ${conversationId}`);
                    }
                }
            } else {
                console.error(`âŒ Error al guardar mensaje en Supabase: ${userMessageResult?.error || 'Error desconocido'}`);
            }
        } catch (supabaseError) {
            console.error(`âŒ Error al guardar mensaje en Supabase: ${supabaseError.message}`);
        }
        
        // ğŸ”’ VERIFICACIÃ“N CRÃTICA: Verificar estado del bot para este remitente
        console.log(`ğŸ”’ FORZANDO CONSULTA A BASE DE DATOS para verificar estado actual del bot`);
        let botActive = true;
        
        if (conversationId) {
            // Verificar si el bot estÃ¡ activo para esta conversaciÃ³n
            try {
                const { data: convData, error: convError } = await supabase
                    .from('conversations')
                    .select('is_bot_active')
                    .eq('id', conversationId)
                    .single();
                    
                if (!convError && convData) {
                    botActive = convData.is_bot_active === true;
                    console.log(`ğŸ¤– Estado del bot para conversaciÃ³n ${conversationId}: ${botActive ? 'ACTIVO âœ…' : 'INACTIVO âŒ'}`);
                }
            } catch (error) {
                console.error(`âŒ Error al verificar estado del bot: ${error.message}`);
                // Asumir que el bot estÃ¡ activo por defecto
            }
        }
        
        // Procesar mensaje con OpenAI SOLO si el bot estÃ¡ ACTIVO
        if (botActive) {
            console.log(`âš™ï¸ Procesando mensaje de ${sender} con OpenAI: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
            
            try {
                // Procesar con OpenAI y obtener respuesta
                const botResponse = await processMessageWithOpenAI(sender, message, conversationId);
                
                if (botResponse) {
                    console.log(`âœ… Respuesta generada por OpenAI: "${botResponse.substring(0, 50)}${botResponse.length > 50 ? '...' : ''}"`);
                    
                    // Verificar si la respuesta del bot contiene frases que requieren notificaciÃ³n
                    console.log(`ğŸ”” ANALIZANDO RESPUESTA DEL BOT PARA DETECTAR FRASES DE NOTIFICACIÃ“N:`);
                    const requiresNotification = checkForNotificationPhrases(botResponse);
                    
                    if (requiresNotification) {
                        console.log(`ğŸ”” DETECTADA FRASE QUE REQUIERE NOTIFICACIÃ“N en respuesta del bot`);
                        console.log(`ğŸ“§ Iniciando envÃ­o de notificaciÃ³n para conversaciÃ³n ${conversationId}`);
                        
                        // Enviar notificaciÃ³n
                        const notificationSent = await sendBusinessNotification(conversationId, botResponse, sender);
                        if (notificationSent) {
                            console.log(`âœ… NotificaciÃ³n enviada exitosamente`);
                        } else {
                            console.error(`âŒ Error al enviar notificaciÃ³n`);
                        }
                    } else {
                        console.log(`â„¹ï¸ La respuesta del bot no contiene frases que requieran notificaciÃ³n`);
                    }
                    
                    // Guardar respuesta del bot en Supabase usando el ID de conversaciÃ³n correcto
                    if (conversationId) {
                        console.log(`ğŸ’¾ Guardando respuesta del bot en conversaciÃ³n ${conversationId}`);
                        
                        try {
                            const botMessageResult = await global.registerBotResponse(conversationId, botResponse, BUSINESS_ID, 'bot');
                            
                            if (botMessageResult && botMessageResult.success) {
                                console.log(`âœ… Respuesta del bot guardada correctamente con ID: ${botMessageResult.messageId || 'desconocido'}`);
                            } else {
                                console.error(`âŒ Error al guardar respuesta del bot: ${botMessageResult?.error || 'Error desconocido'}`);
                            }
                        } catch (saveError) {
                            console.error(`âŒ Error al guardar respuesta del bot: ${saveError.message}`);
                        }
                    } else {
                        console.error(`âŒ No hay ID de conversaciÃ³n para guardar la respuesta del bot`);
                    }
                    
                    // Enviar respuesta a WhatsApp
                    const sendResult = await sendWhatsAppResponse(sender, botResponse);
                    
                    if (sendResult) {
                        console.log(`âœ… Respuesta enviada exitosamente a WhatsApp para ${sender}`);
                    } else {
                        console.log(`âš ï¸ No se pudo enviar la respuesta a WhatsApp, pero sÃ­ se guardÃ³ en la base de datos`);
                    }
                } else {
                    console.log(`âš ï¸ OpenAI no generÃ³ respuesta para el mensaje de ${sender}`);
                }
            } catch (error) {
                console.error(`âŒ Error al procesar mensaje con OpenAI:`, error);
                // Continuar con el flujo normal
            }
        } else {
            console.log(`ğŸ”’ Bot inactivo para esta conversaciÃ³n, no se generarÃ¡ respuesta automÃ¡tica`);
        }
        
        // Responder inmediatamente al webhook
        res.sendStatus(200);
    } catch (error) {
        console.error(`âŒ Error en handleIncomingMessage:`, error);
        res.status(500).json({ success: false, error: error.message });
    }
}

// Ruta para enviar imÃ¡genes a travÃ©s de WhatsApp desde el dashboard
app.post('/send-media', async (req, res) => {
    try {
        console.log('ğŸ“¸ Solicitud recibida para enviar imagen por WhatsApp');
        
        // Validar los datos de entrada
        const { phoneNumber, mediaUrl, caption, businessId } = req.body;
        
        if (!phoneNumber || !mediaUrl) {
            console.error('âŒ Faltan datos requeridos para enviar media');
            return res.status(400).json({ 
                success: false, 
                error: 'Se requieren phoneNumber y mediaUrl' 
            });
        }
        
        console.log(`ğŸ“¤ Enviando imagen a ${phoneNumber}. URL: ${mediaUrl}`);
        
        // Verificar el ID de negocio
        if (businessId && businessId !== BUSINESS_ID) {
            console.warn(`âš ï¸ ID de negocio no coincide: recibido ${businessId}, esperado ${BUSINESS_ID}`);
            // Continuamos de todas formas
        }
        
        // Enviar la imagen a WhatsApp
        const result = await sendMediaMessage(phoneNumber, mediaUrl, caption || '');
        
        if (result) {
            console.log('âœ… Imagen enviada exitosamente por WhatsApp');
            return res.status(200).json({ 
                success: true, 
                message: 'Imagen enviada correctamente' 
            });
        } else {
            console.error('âŒ Error al enviar la imagen por WhatsApp');
            return res.status(500).json({ 
                success: false, 
                error: 'Error al enviar la imagen por WhatsApp' 
            });
        }
    } catch (error) {
        console.error('âŒ Error en la ruta /send-media:', error.message);
        console.error(error.stack);
        
        return res.status(500).json({ 
            success: false, 
            error: 'Error interno del servidor' 
        });
    }
});

// Endpoint para probar credenciales sin enviar mensaje real
app.get('/test-credentials', (req, res) => {
    try {
        // Verificar credenciales
        const credentialStatus = {
            apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
            number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
            userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA',
            businessId: BUSINESS_ID || 'No configurado'
        };
        
        // Mostrar versiÃ³n parcial de API key por seguridad
        let maskedApiKey = null;
        if (GUPSHUP_API_KEY) {
            maskedApiKey = `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}`;
        }
        
        res.status(200).json({
            success: true,
            message: 'Estado de credenciales',
            credentials: credentialStatus,
            apiKeyPrefix: maskedApiKey,
            serverVersion: '1.2.0'
        });
    } catch (error) {
        console.error('âŒ Error en test-credentials:', error.message);
        res.status(500).json({ success: false, error: 'Error interno' });
    }
});

// Endpoint para enviar mensajes manuales a WhatsApp (desde el panel)
// FunciÃ³n para enviar mensajes de texto usando GupShup
// Usar la versiÃ³n importada del mÃ³dulo sendTextMessageGupShup
// const { sendTextMessageGupShup } = require('./sendTextMessageGupShup');

// Importar sistema de notificaciones - agregado para el deployment en Render
global.notificationModule = require('./notification-patch');
// Exponer funciones del mÃ³dulo de notificaciones a variables globales
global.processMessageForNotification = global.notificationModule.processMessageForNotification;
global.sendWhatsAppResponseWithNotification = global.notificationModule.sendWhatsAppResponseWithNotification;
global.checkForNotificationPhrases = global.notificationModule.checkForNotificationPhrases;
global.sendBusinessNotification = global.notificationModule.sendBusinessNotification;

// Fin de importaciÃ³n del sistema de notificaciones


// Endpoint de health check para monitoreo
app.get('/health', (req, res) => {
  try {
    // Verificar credenciales
    const credentialStatus = {
      apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
      number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
      userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA',
      businessId: BUSINESS_ID || 'No configurado'
    };
    
    // Mostrar versiÃ³n parcial de API key por seguridad
    let maskedApiKey = null;
    if (GUPSHUP_API_KEY) {
      maskedApiKey = `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}`;
    }
    
    res.status(200).json({
      status: 'ok',
      uptime: process.uptime(),
      serverVersion: '1.2.1',
      credentials: credentialStatus,
      apiKeyPrefix: maskedApiKey,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ Error en health check:', error.message);
    res.status(500).json({ status: 'error', error: 'Error interno' });
  }
});

// Endpoint para diagnÃ³stico de GupShup y envÃ­o de mensajes de prueba
app.get('/api/gupshup-diagnostic', (req, res) => {
  try {
    // Verificar credenciales
    const credentialStatus = {
      apiKey: GUPSHUP_API_KEY ? 'Configurada' : 'FALTA',
      number: GUPSHUP_NUMBER ? 'Configurado' : 'FALTA',
      userId: GUPSHUP_USERID ? 'Configurado' : 'FALTA',
      businessId: BUSINESS_ID || 'No configurado'
    };
    
    // Mostrar versiÃ³n parcial de API key por seguridad
    let maskedApiKey = null;
    if (GUPSHUP_API_KEY) {
      maskedApiKey = `${GUPSHUP_API_KEY.substring(0, 8)}...${GUPSHUP_API_KEY.substring(GUPSHUP_API_KEY.length - 5)}`;
    }
    
    // Enviar respuesta con estado actual
    res.status(200).json({
      status: 'ok',
      uptime: process.uptime(),
      serverVersion: '1.2.1',
      credentials: credentialStatus,
      apiKeyPrefix: maskedApiKey,
      endpoint: 'https://api.gupshup.io/wa/api/v1/msg',
      testEndpoint: '/api/gupshup-test',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ Error en gupshup-diagnostic:', error.message);
    res.status(500).json({ status: 'error', error: 'Error interno' });
  }
});

// Endpoint para enviar un mensaje de prueba directo a GupShup
app.post('/api/gupshup-test', async (req, res) => {
  try {
    const { phoneNumber, message } = req.body;
    
    // Validar campos requeridos
    if (!phoneNumber || !phoneNumber.trim()) {
      console.error('âŒ Error: No se proporcionÃ³ nÃºmero de telÃ©fono para prueba');
      return res.status(400).json({ 
        success: false,
        error: 'Se requiere nÃºmero de telÃ©fono' 
      });
    }
    
    // Mensaje predeterminado o el proporcionado
    const messageContent = message || `Mensaje de prueba de GupShup desde ${req.headers.host || 'API'} - ${new Date().toISOString()}`;
    
    console.log(`ğŸ§ª Realizando prueba de GupShup con:`);
    console.log(`ğŸ“± TelÃ©fono: ${phoneNumber}`);
    console.log(`ğŸ’¬ Mensaje: ${messageContent}`);
    
    try {
      // Intentar enviar mensaje usando la funciÃ³n principal
      const result = await sendTextMessageGupShup(phoneNumber, messageContent);
      
      console.log(`âœ… Prueba de GupShup exitosa:`, result);
      return res.json({
        success: true,
        message: 'Mensaje de prueba enviado correctamente',
        details: result,
        actualPhoneNumber: phoneNumber.replace(/\D/g, ''),
        note: 'Revisa tu WhatsApp para confirmar si el mensaje llegÃ³. Si no llega, verifica que el nÃºmero sea correcto y que tu cuenta de GupShup estÃ© activa.'
      });
    } catch (error) {
      console.error(`âŒ Error en prueba de GupShup:`, error);
      return res.status(500).json({
        success: false,
        error: error.message || 'Error al enviar mensaje de prueba',
        recommendation: 'Verifica las credenciales de GupShup y asegÃºrate de que la cuenta estÃ© activa.'
      });
    }
  } catch (error) {
    console.error(`âŒ Error general en gupshup-test:`, error);
    res.status(500).json({
      success: false,
      error: error.message || 'Error interno del servidor' 
    });
  }
});

// ... existing code ...

// Endpoint para enviar mensajes manuales desde el dashboard
app.post('/api/send-manual-message', async (req, res) => {
  try {
    const { phoneNumber, message } = req.body;
    
    if (!phoneNumber || !message) {
      return res.status(400).json({ 
      success: false,
        error: 'Se requiere phoneNumber y message' 
      });
    }
    
    console.log(`ğŸ“¨ Solicitud para enviar mensaje manual a ${phoneNumber}: "${message.substring(0, 30)}${message.length > 30 ? '...' : ''}"`);
    
    // Usar nuestra funciÃ³n para enviar el mensaje
    const response = await sendTextMessageGupShup(phoneNumber, message);
    
    return res.status(200).json({ 
          success: true,
      message: 'Mensaje enviado correctamente',
      response
    });
  } catch (error) {
    console.error('âŒ Error al enviar mensaje manual:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'Error al enviar mensaje'
    });
  }
});

// Iniciar el servidor
app.listen(PORT, () => {
  console.log(`ğŸš€ Servidor de WhatsApp corriendo en puerto ${PORT}`);
});

// Resto del cÃ³digo del archivo...

const botConfirmationPhrases = [
  // Solicitud de asistencia humana
  "he registrado tu solicitud para hablar con un asesor",
  "un representante se pondrÃ¡ en contacto contigo",
  
  // ConfirmaciÃ³n de cita
  "tu cita ha sido agendada para",
  "hemos registrado tu cita para el dÃ­a",
  "cita confirmada para el",
  "cita para", 
  "calendly",
  "agendar cita",
  "link donde podrÃ¡s registrarla",
  
  // Solicitud de llamada
  "te llamaremos pronto al nÃºmero",
  "hemos registrado tu solicitud de llamada",
  "recibirÃ¡s una llamada en",
  
  // Seguimiento
  "daremos seguimiento a tu caso",
  "caso registrado con el folio",
  
  // Nuevas frases de confirmaciÃ³n (2025)
  "Â¡Perfecto! tu cita ha sido confirmada para",
  "Â¡Perfecto! un asesor te llamarÃ¡",
  "Â¡Perfecto! un asesor te contactarÃ¡",
  "Â¡Perfecto! una persona te contactarÃ¡",
  "Â¡Perfecto! Un asesor te llamarÃ¡ hoy a las 5",
  "Â¡Perfecto! un asesor te llamarÃ¡ maÃ±ana a las",
  "Â¡Perfecto! un asesor te llamarÃ¡ el"
];

function checkForNotificationPhrases(message) {
  console.log(`ğŸ” === INICIO DE VERIFICACIÃ“N DE NOTIFICACIÃ“N PARA MENSAJE ===`);
  console.log(`ğŸ” Mensaje original: "${message}"`);
  
  if (!message || typeof message !== 'string') {
    console.log('âŒ No se puede verificar un mensaje vacÃ­o o no vÃ¡lido');
    return false;
  }
  
  // Normalizar el mensaje: convertir a minÃºsculas y eliminar acentos
  const normalizedMessage = message.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  
  console.log(`ğŸ” Mensaje normalizado: "${normalizedMessage}"`);
  
  // FRASES CRÃTICAS que deben activar una notificaciÃ³n - independientemente de lo que venga antes o despuÃ©s
  const criticalPatterns = [
    /perfecto.*cita ha sido confirmada/i,
    /perfecto.*un asesor te llamar/i,
    /perfecto.*un asesor te contactar/i,
    /perfecto.*una persona te contactar/i,
    /tu cita ha sido confirmada para/i,
    /cita.*confirmada para/i,
    /asesor te llamar/i,
    /asesor te contactar/i,
    /persona te contactar/i
  ];
  
  // Verificar patrones con expresiones regulares
  for (const pattern of criticalPatterns) {
    if (pattern.test(message)) {
      console.log(`âœ… COINCIDENCIA CON PATRÃ“N: ${pattern}`);
    return true;
    }
  }
  
  // PALABRAS CLAVE que deben aparecer juntas
  const keywordGroups = [
    ['perfecto', 'cita', 'confirmada'],
    ['perfecto', 'asesor', 'llamar'],
    ['perfecto', 'asesor', 'contactar'],
    ['perfecto', 'persona', 'contactar']
  ];
  
  // Verificar grupos de palabras clave
  for (const group of keywordGroups) {
    const allKeywordsPresent = group.every(keyword => normalizedMessage.includes(keyword));
    if (allKeywordsPresent) {
      console.log(`âœ… COINCIDENCIA POR PALABRAS CLAVE: ${group.join(' + ')}`);
      return true;
    }
  }
  
  // FRASES EXACTAS que tambiÃ©n deben activar notificaciÃ³n
  const exactPhrases = [
    "Â¡Perfecto! tu cita ha sido confirmada para",
    "Â¡Perfecto! un asesor te llamarÃ¡",
    "Â¡Perfecto! un asesor te contactarÃ¡",
    "Â¡Perfecto! una persona te contactarÃ¡",
    "Perfecto! tu cita ha sido confirmada para",
    "Perfecto! un asesor te llamarÃ¡",
    "Perfecto! un asesor te contactarÃ¡",
    "Perfecto! una persona te contactarÃ¡"
  ];
  
  // Verificar frases exactas (por si acaso los patrones fallan)
  for (const phrase of exactPhrases) {
    if (message.includes(phrase)) {
      console.log(`ğŸš¨ COINCIDENCIA EXACTA CON FRASE: "${phrase}"`);
      return true;
    }
  }
  
  console.log(`âŒ NO SE DETECTARON FRASES DE NOTIFICACIÃ“N en el mensaje`);
  console.log(`ğŸ” === FIN DE VERIFICACIÃ“N DE NOTIFICACIÃ“N ===`);
  return false;
}

// ... existing code ...
async function sendBusinessNotification(conversationId, botMessage, clientPhoneNumber) {
  console.log(`\nğŸ“§ ============= INICIANDO PROCESO DE NOTIFICACIÃ“N =============`);
  console.log(`ğŸ“§ ConversaciÃ³n: ${conversationId}`);
  console.log(`ğŸ“§ TelÃ©fono cliente: ${clientPhoneNumber}`);
  
  try {
    // Registrar inicio de intento en la base de datos
    try {
      const { error: insertError } = await supabase
        .from('notification_attempts')
        .insert({
          conversation_id: conversationId,
          phone_number: clientPhoneNumber,
          message_content: botMessage.substring(0, 255), // Limitar longitud
          status: 'iniciado',
          details: 'Intento de notificaciÃ³n iniciado'
        });
      
      if (insertError) {
        console.error(`âŒ Error al registrar inicio de notificaciÃ³n: ${insertError.message}`);
      }
    } catch (dbError) {
      console.error(`âŒ Error en base de datos al iniciar notificaciÃ³n: ${dbError.message}`);
    }
    
    // Configurar destinatarios
    const targetEmail = process.env.NOTIFICATION_EMAIL || 'joaquinisaza@hotmail.com';
    const bccEmail = process.env.NOTIFICATION_BCC || 'copia@brexor.com';
    
    console.log(`ğŸ“§ Email destino: ${targetEmail}`);
    console.log(`ğŸ“§ Email BCC: ${bccEmail}`);
    
    // Obtener historial reciente de la conversaciÃ³n
    let conversationHistory = [];
    try {
      const { data: history, error: historyError } = await supabase
        .from('messages')
        .select('*')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: false })
        .limit(10);
      
      if (!historyError && history) {
        conversationHistory = history.reverse(); // Ordenar cronolÃ³gicamente
        console.log(`ğŸ“§ Historial obtenido: ${history.length} mensajes`);
      } else if (historyError) {
        console.error(`âŒ Error al obtener historial: ${historyError.message}`);
      }
    } catch (dbError) {
      console.error(`âŒ Error en consulta de historial: ${dbError.message}`);
    }

    // Formatear el historial de conversaciÃ³n para el correo
    const formattedHistory = conversationHistory.length > 0 ? 
      conversationHistory.map(msg => {
        const sender = msg.sender_type === 'user' ? 'Cliente' : 'Bot';
        const time = new Date(msg.created_at || Date.now()).toLocaleString();
        const content = msg.content || '(sin contenido)';
        
        return `<div style="margin-bottom: 10px; padding: 8px; border-radius: 5px; background-color: ${msg.sender_type === 'user' ? '#f0f0f0' : '#e6f7ff'};">
          <strong>${sender} (${time}):</strong><br/>
          ${content}
        </div>`;
      }).join('') : '<p>No hay mensajes recientes</p>';
    
    // Preparar el HTML del correo con diseÃ±o mejorado
    const emailHTML = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #e1e1e1; border-radius: 8px; overflow: hidden;">
        <div style="background-color: #2c3e50; color: white; padding: 20px; text-align: center;">
          <h2 style="margin: 0;">ğŸ”” NotificaciÃ³n de Cliente - IMPORTANTE</h2>
        </div>
        
        <div style="padding: 20px;">
          <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #3498db;">
            <h3 style="margin-top: 0; color: #34495e; margin-bottom: 10px;">Datos del Cliente</h3>
            <p style="margin: 0;"><strong>TelÃ©fono:</strong> ${clientPhoneNumber}</p>
            <p style="margin: 0;"><strong>ID ConversaciÃ³n:</strong> ${conversationId}</p>
            <p style="margin: 0;"><strong>Fecha:</strong> ${new Date().toLocaleString()}</p>
          </div>
        
          <div style="margin-bottom: 20px;">
            <h3 style="color: #34495e; margin-bottom: 10px;">Mensaje que GenerÃ³ la NotificaciÃ³n</h3>
            <div style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; border-left: 4px solid #2196f3;">
              ${botMessage}
            </div>
          </div>
        
          <div style="margin-bottom: 20px;">
            <h3 style="color: #34495e; margin-bottom: 10px;">Historial Reciente de la ConversaciÃ³n</h3>
            ${formattedHistory}
          </div>
        
          <div style="text-align: center; margin-top: 30px;">
            <p>Este es un correo automÃ¡tico enviado por el sistema de notificaciones.</p>
            <p>Se activÃ³ por una respuesta del bot que requiere tu atenciÃ³n</p>
          </div>
        </div>
      </div>
    `;

    // Configurar opciones del correo
    const mailOptions = {
      from: `"Bot de WhatsApp ğŸ¤–" <${process.env.EMAIL_USER || 'bexorai@gmail.com'}>`,
      to: targetEmail,
      subject: `ğŸ”” NotificaciÃ³n de Cliente - ${clientPhoneNumber}`,
      html: emailHTML
    };
    
    // Agregar BCC si estÃ¡ configurado
    if (bccEmail) {
      mailOptions.bcc = bccEmail;
    }

    console.log(`ğŸ“§ ENVIANDO CORREO DE NOTIFICACIÃ“N...`);
    
    // Verificar que el transporter estÃ© configurado
    if (!transporter) {
      console.error(`âŒ TRANSPORTER NO CONFIGURADO`);
      
      // Registrar fallo en base de datos
      try {
        await supabase
          .from('notification_attempts')
          .insert({
            conversation_id: conversationId,
            phone_number: clientPhoneNumber,
            status: 'fallido',
            details: 'Error: Transporter de correo no configurado'
          });
      } catch (e) {
        console.error(`âŒ Error al registrar fallo de notificaciÃ³n: ${e.message}`);
      }
      
      return false;
    }
    
    try {
      // Intentar enviar con el transporter principal
      console.log(`ğŸ“§ INTENTO PRINCIPAL DE ENVÃO...`);
      const info = await transporter.sendMail(mailOptions);
      
      console.log(`âœ… CORREO ENVIADO EXITOSAMENTE`);
      console.log(`âœ… ID del mensaje: ${info.messageId}`);
      
      // Registrar Ã©xito en base de datos
      try {
        await supabase
          .from('notification_attempts')
          .insert({
            conversation_id: conversationId,
            phone_number: clientPhoneNumber,
            message_id: info.messageId,
            status: 'exitoso',
            details: 'NotificaciÃ³n enviada exitosamente'
          });
      } catch (e) {
        console.error(`âŒ Error al registrar Ã©xito de notificaciÃ³n: ${e.message}`);
      }
      
      console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N COMPLETADO =============`);
      return true;
    } catch (emailError) {
      console.error(`âŒ ERROR EN ENVÃO PRINCIPAL:`);
      console.error(`âŒ Mensaje: ${emailError.message}`);
      
      // Intentar con configuraciÃ³n alternativa
      try {
        console.log(`ğŸ”„ INTENTO ALTERNATIVO DE ENVÃO...`);
        
        // Crear un transporter alternativo
        const altTransporter = nodemailer.createTransport({
          host: 'smtp.gmail.com',
          port: 587,
          secure: false,
          auth: {
            user: process.env.EMAIL_USER || 'bexorai@gmail.com',
            pass: process.env.EMAIL_PASSWORD || 'gqwi aker jgrn kylf'
          },
          tls: {
            rejectUnauthorized: false
          }
        });
        
        const altInfo = await altTransporter.sendMail(mailOptions);
        console.log(`âœ… CORREO ENVIADO CON MÃ‰TODO ALTERNATIVO`);
        console.log(`âœ… ID del mensaje: ${altInfo.messageId}`);
        
        // Registrar Ã©xito del intento alternativo
        try {
          await supabase
            .from('notification_attempts')
            .insert({
              conversation_id: conversationId,
              phone_number: clientPhoneNumber,
              message_id: altInfo.messageId,
              status: 'exitoso_alternativo',
              details: 'NotificaciÃ³n enviada con mÃ©todo alternativo'
            });
        } catch (e) {
          console.error(`âŒ Error al registrar Ã©xito alternativo: ${e.message}`);
        }
        
        console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N COMPLETADO (ALTERNATIVO) =============`);
        return true;
      } catch (altError) {
        console.error(`âŒ ERROR TAMBIÃ‰N EN ENVÃO ALTERNATIVO:`);
        console.error(`âŒ Mensaje: ${altError.message}`);
        
        // Registrar fallo en base de datos
        try {
          await supabase
            .from('notification_attempts')
            .insert({
              conversation_id: conversationId,
              phone_number: clientPhoneNumber,
              status: 'fallido',
              details: `Error principal: ${emailError.message}; Error alternativo: ${altError.message}`
            });
        } catch (e) {
          console.error(`âŒ Error al registrar fallo de notificaciÃ³n: ${e.message}`);
        }
        
        console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N FALLIDO =============`);
        return false;
      }
    }
  } catch (error) {
    console.error(`âŒ ERROR GENERAL EN PROCESO DE NOTIFICACIÃ“N:`);
    console.error(`âŒ Mensaje: ${error.message}`);
    console.error(`âŒ Stack: ${error.stack}`);
    
    // Registrar error general
    try {
      await supabase
        .from('notification_attempts')
        .insert({
          conversation_id: conversationId,
          phone_number: clientPhoneNumber,
          status: 'error_general',
          details: `Error general: ${error.message}`
        });
    } catch (e) {
      console.error(`âŒ Error al registrar error general: ${e.message}`);
    }
    
    console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N FALLIDO (ERROR GENERAL) =============`);
    return false;
  }
}
// ... existing code ...

async function processMessage(message) {
  try {
    console.log(`ğŸš€ Procesando mensaje en processMessage: "${message.content}"`);
    console.log(`ğŸš€ ConversaciÃ³n ID: ${message.conversation_id}`);
    console.log(`ğŸš€ Tipo de mensaje: ${message.sender_type}`);

    // Verificar si es un mensaje del bot que requiere notificaciÃ³n
    if (message.sender_type === 'bot') {
      console.log(`ğŸ” === VERIFICACIÃ“N DE NOTIFICACIÃ“N PARA MENSAJE BOT ===`);
      console.log(`ğŸ” Mensaje completo a analizar: "${message.content}"`);
      
      // =================== FORZAR NOTIFICACIONES =================== //
      // Comprobar explÃ­citamente las frases crÃ­ticas de notificaciÃ³n
      const messageContent = message.content || '';
      const forceNotification = 
        messageContent.includes("Â¡Perfecto! un asesor te llamarÃ¡") || 
        messageContent.includes("Â¡Perfecto! un asesor te contactarÃ¡") ||
        messageContent.includes("Â¡Perfecto! una persona te contactarÃ¡") ||
        messageContent.includes("Perfecto! un asesor te llamarÃ¡") || 
        messageContent.includes("Perfecto! un asesor te contactarÃ¡") ||
        messageContent.includes("Perfecto! una persona te contactarÃ¡") ||
        messageContent.includes("Â¡Perfecto! tu cita ha sido confirmada") ||
        messageContent.includes("Perfecto! tu cita ha sido confirmada");
      
      if (forceNotification) {
        console.log(`ğŸš¨ FORZANDO NOTIFICACIÃ“N para mensaje: "${messageContent}"`);
        
        // Obtener el ID de conversaciÃ³n y nÃºmero de telÃ©fono
        const conversationId = message.conversation_id;
        let clientPhoneNumber = conversationIdToPhoneMap[conversationId];
        
        // Si no estÃ¡ en el mapa, intentar obtenerlo de la base de datos
        if (!clientPhoneNumber) {
          console.log(`ğŸ” Consultando conversaciÃ³n ${conversationId} para obtener nÃºmero de telÃ©fono...`);
          try {
            const { data: conversation, error } = await supabase
              .from('conversations')
              .select('user_id')
              .eq('id', conversationId)
              .single();
              
            if (error) {
              console.error(`âŒ Error al consultar Supabase: ${error.message}`);
            } else if (conversation && conversation.user_id) {
              clientPhoneNumber = conversation.user_id;
              console.log(`ğŸ“± NÃºmero de telÃ©fono obtenido: ${clientPhoneNumber}`);
              // Actualizar mapeo en memoria
              conversationIdToPhoneMap[conversationId] = clientPhoneNumber;
              phoneToConversationMap[clientPhoneNumber] = conversationId;
            }
          } catch (error) {
            console.error(`âŒ Error en consulta Supabase: ${error.message}`);
          }
        }
        
        // Intentar enviar la notificaciÃ³n
        if (conversationId && clientPhoneNumber) {
          console.log(`ğŸ“§ ENVIANDO NOTIFICACIÃ“N FORZADA`);
          console.log(`ğŸ“§ ConversaciÃ³n: ${conversationId}`);
          console.log(`ğŸ“§ NÃºmero: ${clientPhoneNumber}`);
          
          try {
            // Intentamos 3 veces para asegurar la entrega
            for (let attempt = 1; attempt <= 3; attempt++) {
              console.log(`ğŸ“§ Intento ${attempt}/3 de envÃ­o de notificaciÃ³n forzada`);
              const result = await sendBusinessNotification(conversationId, messageContent, clientPhoneNumber);
              
              if (result) {
                console.log(`ğŸ“§ Ã‰XITO âœ… NotificaciÃ³n forzada enviada en intento ${attempt}`);
                break;
              } else if (attempt < 3) {
                console.log(`âš ï¸ Intento ${attempt} fallido, reintentando...`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo antes de reintentar
              } else {
                console.error(`âŒ Todos los intentos de envÃ­o de notificaciÃ³n forzada fallaron`);
              }
            }
          } catch (emailError) {
            console.error(`âŒ Error al enviar notificaciÃ³n forzada: ${emailError.message}`);
            console.error(emailError.stack);
          }
        } else {
          console.error(`âŒ No se pudo obtener informaciÃ³n completa para la notificaciÃ³n forzada`);
          console.error(`ğŸ“± TelÃ©fono: ${clientPhoneNumber || 'NO DISPONIBLE'}`);
          console.error(`ğŸ†” ConversaciÃ³n: ${conversationId || 'NO DISPONIBLE'}`);
        }
      } else {
        // VerificaciÃ³n normal con checkForNotificationPhrases
        console.log(`ğŸ” Ejecutando verificaciÃ³n regular con checkForNotificationPhrases`);
      const requiresNotification = checkForNotificationPhrases(message.content);
        console.log(`ğŸ” Resultado: ${requiresNotification ? 'âœ… REQUIERE NOTIFICACIÃ“N' : 'âŒ NO REQUIERE NOTIFICACIÃ“N'}`);
      
      if (requiresNotification) {
        // Obtener el ID de conversaciÃ³n y nÃºmero de telÃ©fono
        const conversationId = message.conversation_id;
        let clientPhoneNumber = conversationIdToPhoneMap[conversationId];
        
        // Si no estÃ¡ en el mapa, intentar obtenerlo de la base de datos
        if (!clientPhoneNumber) {
          try {
              console.log(`ğŸ” Buscando nÃºmero para conversaciÃ³n: ${conversationId}`);
            const { data: conversation, error } = await supabase
              .from('conversations')
              .select('user_id')
              .eq('id', conversationId)
              .single();
              
            if (error) {
              console.error(`âŒ Error en consulta a Supabase: ${error.message}`);
              } else if (conversation && conversation.user_id) {
              clientPhoneNumber = conversation.user_id;
                console.log(`âœ… NÃºmero encontrado: ${clientPhoneNumber}`);
              conversationIdToPhoneMap[conversationId] = clientPhoneNumber;
            }
          } catch (error) {
            console.error(`âŒ Error al obtener nÃºmero: ${error.message}`);
          }
        }
        
          // Enviar notificaciÃ³n si corresponde
        if (conversationId && clientPhoneNumber) {
            console.log(`ğŸ“§ ENVIANDO NOTIFICACIÃ“N DESDE PROCESS_MESSAGE`);
          console.log(`ğŸ“§ ConversaciÃ³n: ${conversationId}`);
          console.log(`ğŸ“§ TelÃ©fono: ${clientPhoneNumber}`);
          
          try {
            const result = await sendBusinessNotification(conversationId, message.content, clientPhoneNumber);
              console.log(`ğŸ“§ RESULTADO de notificaciÃ³n: ${result ? 'Ã‰XITO âœ…' : 'FALLIDO âŒ'}`);
              
              if (!result) {
                console.log(`ğŸ“§ PRIMER INTENTO FALLIDO, REINTENTANDO...`);
                const result2 = await sendBusinessNotification(conversationId, message.content, clientPhoneNumber);
                console.log(`ğŸ“§ RESULTADO de segundo intento: ${result2 ? 'Ã‰XITO âœ…' : 'FALLIDO âŒ'}`);
              }
            } catch (error) {
              console.error(`âŒ Error al enviar notificaciÃ³n: ${error.message}`);
        }
      } else {
            console.error(`âŒ No se pudo obtener informaciÃ³n completa para la notificaciÃ³n`);
      }
    } else {
          console.log(`â„¹ï¸ Mensaje no requiere notificaciÃ³n segÃºn las reglas configuradas`);
        }
      }
    }

    // Resto del cÃ³digo existente...
  } catch (error) {
    console.error(`âŒ Error general en processMessage: ${error.message}`);
    console.error(error.stack);
  }
}

// ... existing code ...

// Configurar transporter de nodemailer para envÃ­o de correos
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER || 'bexorai@gmail.com',
    pass: process.env.EMAIL_PASSWORD || 'gqwi aker jgrn kylf'
  },
  debug: true // Activar modo debug para ver mÃ¡s informaciÃ³n
});

// Verificar conexiÃ³n del transporter al iniciar
transporter.verify(function(error, success) {
  if (error) {
    console.error('âŒ Error en configuraciÃ³n de nodemailer:', error);
  } else {
    console.log('âœ… Servidor SMTP listo para enviar correos');
  }
});

// Tipos de notificaciÃ³n para asunto del correo
const notificationTypes = {
  appointment: "ğŸ—“ï¸ Solicitud de Cita",
  callback: "ğŸ“ Solicitud de Llamada",
  support: "ğŸ”§ Solicitud de Soporte",
  default: "ğŸ”” NotificaciÃ³n de Cliente"
};

// FunciÃ³n para determinar tipo de notificaciÃ³n
function getNotificationType(message) {
  const lowerMessage = message.toLowerCase();
  
  if (lowerMessage.includes("cita") || lowerMessage.includes("agendar") || lowerMessage.includes("calendario") || lowerMessage.includes("calendly")) {
    return "appointment";
  } else if (lowerMessage.includes("llamar") || lowerMessage.includes("llamada") || lowerMessage.includes("contactar") || lowerMessage.includes("telÃ©fono")) {
    return "callback";
  } else if (lowerMessage.includes("problema") || lowerMessage.includes("ayuda") || lowerMessage.includes("soporte") || lowerMessage.includes("error")) {
    return "support";
  }
  
  return "default";
}

// FunciÃ³n para registrar la respuesta del bot
global.registerBotResponse = async function(conversationId, botMessage, businessId, senderType = 'bot') {
    try {
        console.log(`\nğŸ¤– === REGISTRANDO RESPUESTA DEL BOT ===`);
        console.log(`ğŸ†” ConversaciÃ³n: ${conversationId}`);
        console.log(`ğŸ’¬ Mensaje: "${botMessage.substring(0, 50)}${botMessage.length > 50 ? '...' : ''}"`);
        console.log(`ğŸ‘¤ Tipo de remitente: ${senderType}`);
        console.log(`ğŸ¢ ID de negocio: ${businessId}`);

        // 1. Verificar si el mensaje ya existe (prevenir duplicaciÃ³n)
        const messageHash = crypto.createHash('md5').update(`${conversationId}-${botMessage}-${new Date().toISOString().split('T')[0]}`).digest('hex');
        console.log(`ğŸ”‘ Hash de mensaje: ${messageHash}`);
        
        if (recentMessageHashes.has(messageHash)) {
            console.warn(`âš ï¸ Mensaje duplicado detectado, evitando registro repetido`);
            return { success: false, error: 'Mensaje duplicado', id: null };
        }
        
        recentMessageHashes.add(messageHash);
        console.log(`âœ… Hash de mensaje registrado para prevenir duplicaciÃ³n`);
        
        // 2. Registrar el mensaje del bot en la base de datos vÃ­a API del dashboard
        const dashboardUrl = process.env.DASHBOARD_URL || 'http://localhost:3010';
        console.log(`ğŸŒ URL del dashboard: ${dashboardUrl}`);
        
        try {
            console.log(`ğŸ“¤ Enviando mensaje al dashboard: ${conversationId}`);
            
            const response = await axios.post(`${dashboardUrl}/api/messages`, {
                conversationId: conversationId,
                message: botMessage,
                senderType: senderType,
                businessId: businessId,
                alreadySent: true // Marcar como ya enviado a WhatsApp para evitar loop
            }, {
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            console.log(`âœ… Mensaje registrado en dashboard, ID: ${response.data.id}`);
            
            // 3. Procesar mensaje para verificar si se requiere notificaciÃ³n
            if (senderType === 'bot') {
                console.log(`\nğŸ” LLAMANDO AL ENDPOINT DE NOTIFICACIONES...`);
                
                // Obtener el nÃºmero de telÃ©fono del cliente
                let clientPhoneNumber = conversationIdToPhoneMap[conversationId];
                
                // Si no estÃ¡ en el mapa, intentar obtenerlo de la base de datos
                if (!clientPhoneNumber) {
                    try {
                        const { data: conversation, error } = await supabase
                            .from('conversations')
                            .select('user_id')
                            .eq('id', conversationId)
                            .single();
                            
                        if (conversation && conversation.user_id) {
                            clientPhoneNumber = conversation.user_id;
                            conversationIdToPhoneMap[conversationId] = clientPhoneNumber;
                        }
                    } catch (dbError) {
                        console.error(`âŒ Error al obtener nÃºmero de telÃ©fono: ${dbError.message}`);
                    }
                }
                
                if (clientPhoneNumber) {
                    try {
                        // Llamar al endpoint especÃ­fico para procesamiento de notificaciones
                        const notificationResponse = await axios.post(`${dashboardUrl}/api/process-whatsapp-message`, {
                            message: botMessage,
                            isFromBot: true,
                            conversationId: conversationId,
                            phoneNumber: clientPhoneNumber
                        }, {
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        console.log(`ğŸ“Š Respuesta del procesamiento: ${JSON.stringify(notificationResponse.data || {})}`);
                        
                        if (notificationResponse.data && notificationResponse.data.notificationSent) {
                            console.log(`âœ… NOTIFICACIÃ“N ENVIADA EXITOSAMENTE`);
                        } else {
                            console.log(`â„¹ï¸ No se requiriÃ³ notificaciÃ³n o fallÃ³ el envÃ­o: ${notificationResponse.data?.message || 'Sin detalles'}`);
                        }
                    } catch (notificationError) {
                        console.error(`âŒ Error al procesar notificaciÃ³n: ${notificationError.message}`);
                    }
                } else {
                    console.warn(`âš ï¸ No se pudo obtener el nÃºmero de telÃ©fono para el proceso de notificaciÃ³n`);
                }
            }
            
            // 4. Retornar Ã©xito con el ID del mensaje
            return { success: true, id: response.data.id };
            
        } catch (dashboardError) {
            console.error(`âŒ Error al registrar mensaje en el dashboard: ${dashboardError.message}`);
            
            // En caso de error, intentar directamente con Supabase como respaldo
            try {
                console.log(`ğŸ”„ Intentando registrar mensaje directamente en Supabase como respaldo...`);
                
                const { data: directData, error: directError } = await supabase
                    .from('messages')
                    .insert([{
                        conversation_id: conversationId,
                        content: botMessage,
                        sender_type: senderType,
                        created_at: new Date().toISOString(),
                        business_id: businessId,
                        sent_to_whatsapp: true
                    }])
                    .select();
                
                if (directError) {
                    throw new Error(`Error directo en Supabase: ${directError.message}`);
                }
                
                console.log(`âœ… Mensaje registrado directamente en Supabase: ${directData[0].id}`);
                return { success: true, id: directData[0].id };
                
            } catch (directError) {
                console.error(`âŒ Error respaldo directo Supabase: ${directError.message}`);
                throw new Error(`No se pudo registrar el mensaje: ${dashboardError.message} | Respaldo: ${directError.message}`);
            }
        }
    } catch (error) {
        console.error(`âŒ Error global en registerBotResponse: ${error.message}`);
        return { success: false, error: error.message, id: null };
    }
};

// FunciÃ³n para verificar si un mensaje contiene una frase que requiere notificaciÃ³n

/* FUNCIÃ“N DUPLICADA - COMENTADA AUTOMÃTICAMENTE

/* FUNCIÃ“N DUPLICADA - COMENTADA AUTOMÃTICAMENTE
function checkForNotificationPhrases(message) {
  console.log(`ğŸ” === VERIFICANDO FRASES PARA NOTIFICACIÃ“N ===`);
  console.log(`ğŸ” Mensaje a verificar: "${message}
FIN DE FUNCIÃ“N DUPLICADA */
FIN DE FUNCIÃ“N DUPLICADA */"`);
  
  // Asegurarse de que el mensaje es una cadena
  if (!message || typeof message !== 'string') {
    console.error(`âŒ El mensaje no es vÃ¡lido: ${message}`);
    return false;
  }
  
  // Normalizar mensaje (quitar acentos, convertir a minÃºsculas)
  const normalizedMessage = message.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  
  // Lista ampliada de frases que requieren notificaciÃ³n
  const notificationPhrases = [
    "perfecto! un asesor te llamara", 
    "perfecto! un asesor te llamarÃ¡",
    "Â¡perfecto! un asesor te llamarÃ¡",
    "Â¡perfecto! un asesor te llamara",
    "perfecto un asesor te",
    "perfecto! tu cita ha sido confirmada",
    "Â¡perfecto! tu cita ha sido confirmada",
    "perfecto! tu cita ha sido registrada",
    "Â¡perfecto! tu cita ha sido registrada",
    "hemos registrado tu cita",
    "tu cita ha sido",
    "se ha creado la cita",
    "asesor te contactara",
    "asesor te contactarÃ¡",
    "Â¡perfecto!",
    "cita confirmada",
    "cita registrada",
    "te contactarÃ¡",
    "te contactara"
  ];
  
  // Lista ampliada de palabras clave para verificaciÃ³n adicional
  const keyWords = [
    "cita", 
    "asesor", 
    "llamarÃ¡", 
    "llamara",
    "contactarÃ¡", 
    "contactara",
    "confirmada", 
    "registrada", 
    "perfecto",
    "reservada",
    "agendada"
  ];
  
  // Verificar si el mensaje contiene alguna de las frases de notificaciÃ³n
  for (const phrase of notificationPhrases) {
    if (normalizedMessage.includes(phrase)) {
      console.log(`âœ… COINCIDENCIA EXACTA detectada con frase: "${phrase}"`);
      return true;
    }
  }
  
  // Verificar coincidencia parcial (al menos 2 palabras clave)
  let keyWordCount = 0;
  const matchedKeywords = [];
  for (const word of keyWords) {
    if (normalizedMessage.includes(word)) {
      keyWordCount++;
      matchedKeywords.push(word);
      console.log(`ğŸ”‘ Palabra clave "${word}" encontrada (${keyWordCount}/${keyWords.length})`);
    }
  }
  
  if (keyWordCount >= 2) {
    console.log(`âœ… COINCIDENCIA PARCIAL: ${keyWordCount} palabras clave encontradas: [${matchedKeywords.join(', ')}]`);
    return true;
  }
  
  // Verificar patrones especÃ­ficos
  if (
    (normalizedMessage.includes("perfecto") && normalizedMessage.includes("asesor")) ||
    (normalizedMessage.includes("cita") && normalizedMessage.includes("confirmada")) ||
    (normalizedMessage.includes("cita") && normalizedMessage.includes("registrada")) ||
    (normalizedMessage.includes("perfecto") && normalizedMessage.includes("cita"))
  ) {
    console.log(`âœ… PATRÃ“N ESPECÃFICO detectado: combinaciÃ³n de palabras clave`);
    return true;
  }
  
  console.log(`âŒ No se detectaron frases que requieran notificaciÃ³n`);
  return false;
}

/**
 * EnvÃ­a una notificaciÃ³n al negocio sobre la conversaciÃ³n del cliente.
 * @param {string} conversationId - ID de la conversaciÃ³n
 * @param {string} botMessage - Mensaje del bot que desencadenÃ³ la notificaciÃ³n
 * @param {string} clientPhoneNumber - NÃºmero de telÃ©fono del cliente
 * @returns {Promise<boolean>} - True si la notificaciÃ³n se enviÃ³ correctamente
 */

/* FUNCIÃ“N DUPLICADA - COMENTADA AUTOMÃTICAMENTE
async function sendBusinessNotification(conversationId, botMessage, clientPhoneNumber) {
  try {
    console.log(`ğŸ“§ INICIANDO PROCESO DE NOTIFICACIÃ“N para conversaciÃ³n: ${conversationId}
FIN DE FUNCIÃ“N DUPLICADA */`);
    console.log(`ğŸ“§ Mensaje del bot que activÃ³ la notificaciÃ³n: "${botMessage}"`);
    console.log(`ğŸ“§ NÃºmero de telÃ©fono del cliente: ${clientPhoneNumber}`);
    
    // Configurar destinatarios fijos para pruebas
    const targetEmail = 'joaquinisaza@hotmail.com'; // Email principal fijo
    const bccEmail = 'copia@brexor.com'; // Email BCC fijo
    
    console.log(`ğŸ“§ Email de destino: ${targetEmail}`);
    console.log(`ğŸ“§ Email BCC: ${bccEmail}`);
    
    // Obtener historial reciente de la conversaciÃ³n (si estÃ¡ disponible)
    let conversationHistory = [];
    try {
      const { data: history, error: historyError } = await supabase
        .from('messages')
        .select('*')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: false })
        .limit(10);
      
      if (!historyError && history) {
        conversationHistory = history;
        console.log(`ğŸ“§ Historial de conversaciÃ³n obtenido: ${history.length} mensajes`);
      } else if (historyError) {
        console.error(`âŒ Error al obtener historial: ${historyError.message}`);
      }
    } catch (dbError) {
      console.error(`âŒ Error en consulta de historial: ${dbError.message}`);
    }

    // Formatear el historial de conversaciÃ³n para el correo
    const formattedHistory = conversationHistory.length > 0 ? 
      conversationHistory.map(msg => {
      const sender = msg.sender_type === 'user' ? 'Cliente' : 'Bot';
        const time = new Date(msg.created_at || Date.now()).toLocaleString();
      const content = msg.content || '(sin contenido)';
      
      return `<div style="margin-bottom: 10px; padding: 8px; border-radius: 5px; background-color: ${msg.sender_type === 'user' ? '#f0f0f0' : '#e6f7ff'};">
        <strong>${sender} (${time}):</strong><br/>
        ${content}
      </div>`;
      }).join('') : '<p>No hay mensajes recientes</p>';
    
    // Preparar el HTML del correo con diseÃ±o mejorado
    const emailHTML = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #e1e1e1; border-radius: 8px; overflow: hidden;">
        <div style="background-color: #2c3e50; color: white; padding: 20px; text-align: center;">
          <h2 style="margin: 0;">ğŸ”” NotificaciÃ³n de Cliente - IMPORTANTE</h2>
        </div>
        
        <div style="padding: 20px;">
          <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #3498db;">
            <h3 style="margin-top: 0; color: #34495e; margin-bottom: 10px;">Datos del Cliente</h3>
            <p style="margin: 0;"><strong>TelÃ©fono:</strong> ${clientPhoneNumber}</p>
            <p style="margin: 0;"><strong>ID ConversaciÃ³n:</strong> ${conversationId}</p>
            <p style="margin: 0;"><strong>Fecha:</strong> ${new Date().toLocaleString()}</p>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: #34495e; margin-bottom: 10px;">Mensaje que GenerÃ³ la NotificaciÃ³n</h3>
            <div style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; border-left: 4px solid #2196f3;">
            ${botMessage}
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: #34495e; margin-bottom: 10px;">Historial Reciente de la ConversaciÃ³n</h3>
            ${formattedHistory}
        </div>
        
        <div style="text-align: center; margin-top: 30px;">
            <p>Este es un correo automÃ¡tico enviado por el sistema de notificaciones.</p>
            <p>Se activÃ³ por una respuesta del bot que requiere tu atenciÃ³n</p>
        </div>
        </div>
      </div>
    `;

    // Configurar opciones del correo
    const mailOptions = {
      from: `"Bot de WhatsApp ğŸ¤–" <bexorai@gmail.com>`,
      to: targetEmail,
      subject: `ğŸ”” NotificaciÃ³n de Cliente - ${clientPhoneNumber}`,
      html: emailHTML
    };
    
    // Agregar BCC si estÃ¡ configurado
    if (bccEmail) {
      mailOptions.bcc = bccEmail;
      console.log(`ğŸ“§ Agregando BCC: ${bccEmail}`);
    }

    console.log(`ğŸ“§ ENVIANDO CORREO DE NOTIFICACIÃ“N...`);
    
    // Verificar que el transporter estÃ© configurado
    if (!transporter) {
      console.error(`âŒ TRANSPORTER NO CONFIGURADO`);
      
      // Registrar fallo en base de datos
      try {
        await supabase
          .from('notification_attempts')
          .insert({
            conversation_id: conversationId,
            phone_number: clientPhoneNumber,
            status: 'fallido',
            details: 'Error: Transporter de correo no configurado'
          });
      } catch (e) {
        console.error(`âŒ Error al registrar fallo de notificaciÃ³n: ${e.message}`);
      }
      
      return false;
    }
    
    try {
      // Intentar enviar con el transporter principal
      console.log(`ğŸ“§ INTENTO PRINCIPAL DE ENVÃO...`);
      const info = await transporter.sendMail(mailOptions);
      
      console.log(`âœ… CORREO ENVIADO EXITOSAMENTE`);
      console.log(`âœ… ID del mensaje: ${info.messageId}`);
      
      // Registrar Ã©xito en base de datos
      try {
        await supabase
          .from('notification_attempts')
          .insert({
            conversation_id: conversationId,
            phone_number: clientPhoneNumber,
            message_id: info.messageId,
            status: 'exitoso',
            details: 'NotificaciÃ³n enviada exitosamente'
          });
      } catch (e) {
        console.error(`âŒ Error al registrar Ã©xito de notificaciÃ³n: ${e.message}`);
      }
      
      console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N COMPLETADO =============`);
      return true;
    } catch (emailError) {
      console.error(`âŒ ERROR EN ENVÃO PRINCIPAL:`);
      console.error(`âŒ Mensaje: ${emailError.message}`);
      
      // Intentar con configuraciÃ³n alternativa
      try {
        console.log(`ğŸ”„ INTENTO ALTERNATIVO DE ENVÃO...`);
        
        // Crear un transporter alternativo
        const altTransporter = nodemailer.createTransport({
          host: 'smtp.gmail.com',
          port: 587,
          secure: false,
          auth: {
            user: process.env.EMAIL_USER || 'bexorai@gmail.com',
            pass: process.env.EMAIL_PASSWORD || 'gqwi aker jgrn kylf'
          },
          tls: {
            rejectUnauthorized: false
          }
        });
        
        const altInfo = await altTransporter.sendMail(mailOptions);
        console.log(`âœ… CORREO ENVIADO CON MÃ‰TODO ALTERNATIVO`);
        console.log(`âœ… ID del mensaje: ${altInfo.messageId}`);
        
        // Registrar Ã©xito del intento alternativo
        try {
          await supabase
            .from('notification_attempts')
            .insert({
              conversation_id: conversationId,
              phone_number: clientPhoneNumber,
              message_id: altInfo.messageId,
              status: 'exitoso_alternativo',
              details: 'NotificaciÃ³n enviada con mÃ©todo alternativo'
            });
        } catch (e) {
          console.error(`âŒ Error al registrar Ã©xito alternativo: ${e.message}`);
        }
        
        console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N COMPLETADO (ALTERNATIVO) =============`);
        return true;
      } catch (altError) {
        console.error(`âŒ ERROR TAMBIÃ‰N EN ENVÃO ALTERNATIVO:`);
        console.error(`âŒ Mensaje: ${altError.message}`);
        
        // Registrar fallo en base de datos
        try {
          await supabase
            .from('notification_attempts')
            .insert({
              conversation_id: conversationId,
              phone_number: clientPhoneNumber,
              status: 'fallido',
              details: `Error principal: ${emailError.message}; Error alternativo: ${altError.message}`
            });
        } catch (e) {
          console.error(`âŒ Error al registrar fallo de notificaciÃ³n: ${e.message}`);
        }
        
        console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N FALLIDO =============`);
        return false;
      }
    }
  } catch (error) {
    console.error(`âŒ ERROR GENERAL EN PROCESO DE NOTIFICACIÃ“N:`);
    console.error(`âŒ Mensaje: ${error.message}`);
    console.error(`âŒ Stack: ${error.stack}`);
    
    // Registrar error general
    try {
      await supabase
        .from('notification_attempts')
        .insert({
          conversation_id: conversationId,
          phone_number: clientPhoneNumber,
          status: 'error_general',
          details: `Error general: ${error.message}`
        });
    } catch (e) {
      console.error(`âŒ Error al registrar error general: ${e.message}`);
    }
    
    console.log(`\nğŸ“§ ============= PROCESO DE NOTIFICACIÃ“N FALLIDO (ERROR GENERAL) =============`);
    return false;
  }
}

// Exportar funciones importantes para uso externo
module.exports = {
  sendBusinessNotification,
  checkForNotificationPhrases,
  processMessage,
  // Otras funciones pÃºblicas que quieras exponer
};

// ... existing code ...

// FunciÃ³n que envÃ­a la respuesta al WhatsApp despuÃ©s de obtenerla de OpenAI
async function sendWhatsAppResponse(responseText, phoneNumber, thread_id, conversation_id, messageId) {
  try {
    console.log('\n============= ğŸ“± ENVIANDO RESPUESTA A WHATSAPP ğŸ“± =============');
    console.log(`ğŸ“± ENVIANDO MENSAJE A: ${phoneNumber}`);
    console.log(`ğŸ’¬ MENSAJE: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`);
    
    // 1. VERIFICAR SI EL MENSAJE REQUIERE NOTIFICACIÃ“N
    console.log(`\nğŸ” VERIFICANDO SI EL MENSAJE REQUIERE NOTIFICACIÃ“N`);
    const needsNotification = checkForNotificationPhrases(responseText);
    console.log(`ğŸ” RESULTADO: ${needsNotification ? 'âœ… REQUIERE NOTIFICACIÃ“N' : 'âŒ NO REQUIERE NOTIFICACIÃ“N'}`);
    
    // 2. BUSCAR CONVERSACIÃ“N ID SI NO SE PROPORCIONÃ“
    let conversationId = conversation_id;
    if (!conversationId && phoneNumber) {
      console.log(`ğŸ” Buscando conversaciÃ³n para el nÃºmero ${phoneNumber}...`);
      // Verificar primero en el mapeo en memoria
      conversationId = phoneToConversationMap[phoneNumber];
      
      // Si no estÃ¡ en memoria, buscar en la base de datos
      if (!conversationId) {
        try {
          const { data, error } = await supabase
            .from('conversations')
            .select('id')
            .eq('user_id', phoneNumber)
            .eq('business_id', BUSINESS_ID)
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (data && data.length > 0) {
            conversationId = data[0].id;
            // Actualizar mapeo en memoria
            phoneToConversationMap[phoneNumber] = conversationId;
            conversationIdToPhoneMap[conversationId] = phoneNumber;
            console.log(`âœ… ConversaciÃ³n encontrada: ${conversationId}`);
          }
        } catch (error) {
          console.error(`âŒ Error buscando conversaciÃ³n: ${error.message}`);
        }
      } else {
        console.log(`âœ… ConversaciÃ³n encontrada en cachÃ©: ${conversationId}`);
      }
    }
    
    // 3. ENVIAR RESPUESTA A WHATSAPP
    console.log(`ğŸ“¤ Enviando mensaje a WhatsApp...`);
    const whatsappResult = await sendTextMessageGupShup(phoneNumber, responseText);
    console.log(whatsappResult.success 
      ? `âœ… Mensaje enviado exitosamente a WhatsApp` 
      : `âŒ Error enviando mensaje a WhatsApp: ${whatsappResult.error || 'Desconocido'}`);
    
    // 4. ENVIAR NOTIFICACIÃ“N SI ES NECESARIO
    if (needsNotification && conversationId) {
      console.log(`\nğŸš¨ === INICIANDO PROCESO DE NOTIFICACIÃ“N ===`);
      console.log(`ğŸš¨ El mensaje contiene frases que requieren notificaciÃ³n`);
      
      try {
        const notificationResult = await sendBusinessNotification(conversationId, responseText, phoneNumber);
        console.log(`ğŸ“§ RESULTADO de notificaciÃ³n: ${notificationResult ? 'âœ… ENVIADA EXITOSAMENTE' : 'âŒ FALLÃ“ EL ENVÃO'}`);
        
        if (!notificationResult) {
          console.log(`ğŸ“§ REINTENTANDO ENVÃO DE NOTIFICACIÃ“N...`);
          const secondAttempt = await sendBusinessNotification(conversationId, responseText, phoneNumber);
          console.log(`ğŸ“§ RESULTADO segundo intento: ${secondAttempt ? 'âœ… EXITOSO' : 'âŒ FALLIDO'}`);
        }
      } catch (notificationError) {
        console.error(`âŒ Error en proceso de notificaciÃ³n: ${notificationError.message}`);
      }
    } else if (needsNotification) {
      console.warn(`âš ï¸ SE REQUIERE NOTIFICACIÃ“N pero no se encontrÃ³ ID de conversaciÃ³n`);
    }
    
    // 5. REGISTRAR RESPUESTA DEL BOT EN BASE DE DATOS
    try {
      console.log(`\nğŸ—„ï¸ Registrando respuesta en la base de datos...`);
      const registerResult = await registerBotResponse(
        conversationId || thread_id, 
        responseText, 
        BUSINESS_ID
      );
      
      console.log(registerResult.success 
        ? `âœ… Respuesta registrada en la base de datos` 
        : `âŒ Error registrando respuesta: ${registerResult.error || 'Desconocido'}`);
    } catch (registerError) {
      console.error(`âŒ Error registrando respuesta: ${registerError.message}`);
    }
    
    console.log('============= ğŸ“± FIN DE ENVÃO A WHATSAPP ğŸ“± =============\n');
    return true;
  } catch (error) {
    console.error(`âŒ Error general en sendWhatsAppResponse: ${error.message}`);
    console.error(error.stack);
    return false;
  }
}

// ... existing code ...