// Webhook corregido para recibir mensajes de WhatsApp
// Incluye soporte mejorado para mensajes de audio
app.post('/webhook', async (req, res) => {
    try {
        const body = req.body;
        console.log(`üì© Mensaje recibido en webhook: ${JSON.stringify(body).substring(0, 500)}...`);
        
        // Extraer datos del mensaje
        const messageData = extractMessageData(body);
        
        // Si es una actualizaci√≥n de estado, solo registrarla
        if (messageData.isStatusUpdate) {
            console.log(`üìä Notificaci√≥n de estado recibida, no requiere respuesta`);
            console.log(`üìä Procesada notificaci√≥n de estado`);
            return res.sendStatus(200);
        }
        
        const { sender, message, messageId, isImage, isAudio } = messageData;
        
        if (!sender) {
            console.log(`‚ö†Ô∏è Mensaje sin remitente, ignorando: ${JSON.stringify(messageData)}`);
            return res.sendStatus(200);
        }
        
        // Modificar esta condici√≥n para permitir mensajes de audio/imagen sin contenido de texto
        if (!message && !isImage && !isAudio) {
            console.log(`‚ö†Ô∏è Mensaje sin contenido v√°lido, ignorando: ${JSON.stringify(messageData)}`);
            return res.sendStatus(200);
        }
        
        console.log(`üë§ Mensaje recibido de ${sender}: ${message || (isImage ? "[IMAGEN]" : isAudio ? "[AUDIO]" : "[DESCONOCIDO]")}`);
        
        // Verificar si este mensaje ya fue procesado recientemente
        // Generar una clave √∫nica para este mensaje que tenga en cuenta su tipo
        const messageKey = `${messageId || sender}_${message || (isImage ? "IMAGEN" : isAudio ? "AUDIO" : "DESCONOCIDO")}`;
        if (recentlyProcessedMessages.has(messageKey)) {
            console.log(`‚ö†Ô∏è Mensaje duplicado detectado, ignorando: ${messageKey}`);
            return res.sendStatus(200);
        }
        
        // Marcar este mensaje como procesado
        recentlyProcessedMessages.add(messageKey);
        setTimeout(() => recentlyProcessedMessages.delete(messageKey), 60000); // Eliminar despu√©s de 1 minuto
        
        // Guardar mensaje en Supabase
        console.log(`üíæ Guardando mensaje entrante para ${sender}`);
        let conversationId = null;
        
        try {
            // Verificar si tenemos un ID de conversaci√≥n mapeado para este n√∫mero
            if (phoneToConversationMap[sender]) {
                conversationId = phoneToConversationMap[sender];
                console.log(`‚úÖ ID de conversaci√≥n encontrado en cach√©: ${conversationId}`);
            }
            
            // Guardar mensaje del usuario en la base de datos
            console.log(`üíæ Guardando mensaje de tipo 'user' para: ${sender}`);
            const userMessageResult = await global.registerBotResponse(sender, message || (isImage ? "[IMAGEN RECIBIDA]" : "[AUDIO RECIBIDO]"), BUSINESS_ID, 'user');
      
            if (userMessageResult && userMessageResult.success) {
                console.log('‚úÖ Mensaje guardado en Supabase correctamente');
                conversationId = userMessageResult.conversationId;
                
                // Actualizar mapeo de conversaci√≥n
                if (conversationId && sender) {
                    phoneToConversationMap[sender] = conversationId;
                    conversationIdToPhoneMap[conversationId] = sender;
                }
            } else {
                console.error(`‚ùå Error al guardar mensaje en Supabase: ${userMessageResult?.error || 'Error desconocido'}`);
            }
        } catch (supabaseError) {
            console.error(`‚ùå Error al guardar mensaje en Supabase: ${supabaseError.message}`);
        }
        
        // üîí VERIFICACI√ìN CR√çTICA: Verificar estado del bot para este remitente
        console.log(`üîí FORZANDO CONSULTA A BASE DE DATOS para verificar estado actual del bot`);
        let botActive = true;
        
        try {
            // Primero intentar con el ID de conversaci√≥n si lo tenemos
            if (conversationId) {
                const { data: convData, error: convError } = await supabase
                    .from('conversations')
                    .select('is_bot_active')
                    .eq('id', conversationId)
                    .single();
                
                if (convError) {
                    console.error(`‚ùå Error consultando estado del bot: ${convError.message}`);
                } else if (convData) {
                    botActive = convData.is_bot_active === true; // Comparaci√≥n estricta
                    console.log(`‚ÑπÔ∏è ESTADO DIRECTO DB: Bot ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'} para la conversaci√≥n ${conversationId} (n√∫mero ${sender})`);
                    
                    // Actualizar cach√©
                    senderBotStatusMap[sender] = botActive;
                    console.log(`üìù Cach√© actualizada: senderBotStatusMap[${sender}] = ${botActive}`);
                }
            } else {
                // Si no tenemos ID, buscar por n√∫mero
                const { data: convByNumber, error: numberError } = await supabase
                    .from('conversations')
                    .select('id, is_bot_active')
                    .eq('user_id', sender)
                    .single();
                
                if (numberError) {
                    console.error(`‚ùå Error consultando por n√∫mero: ${numberError.message}`);
                } else if (convByNumber) {
                    botActive = convByNumber.is_bot_active === true;
                    console.log(`‚ÑπÔ∏è ESTADO POR N√öMERO: Bot ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'} para ${sender}`);
                    
                    // Actualizar cach√© y mapeo
                    senderBotStatusMap[sender] = botActive;
                    console.log(`üìù Cach√© actualizada: senderBotStatusMap[${sender}] = ${botActive}`);
                    
                    // Actualizar tambi√©n el ID de conversaci√≥n
                    conversationId = convByNumber.id;
                    phoneToConversationMap[sender] = conversationId;
                    conversationIdToPhoneMap[conversationId] = sender;
                }
            }
        } catch (dbError) {
            console.error(`‚ùå Error cr√≠tico consultando estado del bot: ${dbError.message}`);
        }
        
        // Verificaci√≥n final antes de procesar
        console.log(`üîê VERIFICACI√ìN FINAL antes de procesar: Bot para ${sender} est√° ${botActive ? 'ACTIVO ‚úÖ' : 'INACTIVO ‚ùå'}`);
      
        // Si es una imagen, enviar una respuesta est√°ndar inmediatamente
        if (isImage && botActive) {
            console.log('üñºÔ∏è Respondiendo a mensaje de imagen con respuesta est√°ndar');
            
            const imageResponse = "Lo siento, actualmente no puedo procesar im√°genes. Por favor, env√≠a tu consulta como mensaje de texto o, si necesitas asistencia con esta imagen, puedo transferirte con un asesor.";
            
            try {
                await sendWhatsAppResponse(sender, imageResponse);
                
                // Registrar la respuesta en la base de datos
                if (conversationId) {
                    await registerBotResponse(conversationId, imageResponse);
                    console.log('‚úÖ Respuesta a imagen registrada en la base de datos');
                }
            } catch (responseError) {
                console.error(`‚ùå Error enviando respuesta a imagen: ${responseError.message}`);
            }
            
            // Terminar aqu√≠, no pasamos la imagen al procesamiento normal
            return res.sendStatus(200);
        }
        
        // Si es un audio, enviar una respuesta est√°ndar inmediatamente
        if (isAudio && botActive) {
            console.log('üîä Respondiendo a mensaje de audio con respuesta est√°ndar');
            
            // Respuesta personalizada para mensajes de audio
            const audioResponse = "Lo siento, actualmente no puedo procesar mensajes de audio. Por favor, env√≠a tu consulta como mensaje de texto o, si necesitas ayuda con lo que mencionaste en el audio, puedo transferirte con un asesor.";
            
            try {
                await sendWhatsAppResponse(sender, audioResponse);
                
                // Registrar la respuesta en la base de datos
                if (conversationId) {
                    await registerBotResponse(conversationId, audioResponse);
                    console.log('‚úÖ Respuesta a audio registrada en la base de datos');
                }
            } catch (responseError) {
                console.error(`‚ùå Error enviando respuesta a audio: ${responseError.message}`);
            }
            
            // Terminar aqu√≠, no pasamos el audio al procesamiento normal
            return res.sendStatus(200);
        }
      
        // Procesar mensaje con OpenAI SOLO si el bot est√° ACTIVO y no es una imagen ni un audio
        if (botActive && !isImage && !isAudio) {
            console.log(`üîç Intentando procesar mensaje de texto con OpenAI`);
            
            try {
                // Procesar el mensaje con OpenAI y enviar la respuesta
                const openAIResponse = await processMessageWithOpenAI(sender, message, conversationId);
                
                if (openAIResponse && openAIResponse.success) {
                    console.log(`‚úÖ Respuesta de OpenAI enviada correctamente`);
                } else {
                    console.error(`‚ùå Error procesando mensaje con OpenAI: ${openAIResponse?.error || 'Desconocido'}`);
                    
                    // Si falla OpenAI, intentar enviar mensaje de error gen√©rico
                    try {
                        const errorMessage = 'Lo siento, estoy teniendo problemas para procesar tu mensaje. Por favor, intenta m√°s tarde o contacta a un asesor.';
                        await sendWhatsAppResponse(sender, errorMessage);
                        
                        // Registrar la respuesta de error en la base de datos
                        if (conversationId) {
                            await registerBotResponse(conversationId, errorMessage);
                        }
                    } catch (fallbackError) {
                        console.error(`‚ùå Error enviando mensaje de error: ${fallbackError.message}`);
                    }
                }
            } catch (processingError) {
                console.error(`‚ùå Error cr√≠tico al procesar mensaje: ${processingError.message}`);
            }
        } else {
            console.log(`‚è© Saltando procesamiento con OpenAI: bot ${botActive ? 'activo' : 'inactivo'}, imagen: ${isImage}, audio: ${isAudio}`);
        }
        
        // Responder al webhook para evitar timeouts
        return res.sendStatus(200);
    } catch (error) {
        console.error('‚ùå Error en webhook:', error);
        return res.sendStatus(200); // Responder 200 de todos modos para evitar reintentos
    }
}); 